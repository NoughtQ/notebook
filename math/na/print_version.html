<!DOCTYPE html>
<html class="no-js" lang="zh">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width,initial-scale=1" name="viewport"/>
<meta content="NoughtQ的笔记本，主要记录一些 CS 相关的笔记" name="description"/>
<meta content="NoughtQ" name="author"/>
<link href="https://notebook.noughtq.top/math/na/print_version.html" rel="canonical"/>
<link href="../../feed_rss_created.xml" rel="alternate" title="RSS 订阅" type="application/rss+xml"/>
<link href="../../feed_rss_updated.xml" rel="alternate" title="已更新内容的 RSS 订阅" type="application/rss+xml"/>
<link href="../../assets/favicon.png" rel="icon"/>
<meta content="mkdocs-1.6.1, mkdocs-material-9.6.14" name="generator"/>
<title>Chap 1: Mathematical Premiminaries - NoughtQ的笔记本</title>
<link href="../../assets/stylesheets/main.342714a4.min.css" rel="stylesheet"/>
<link href="../../assets/stylesheets/palette.06af60db.min.css" rel="stylesheet"/>
<link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect"/>
<link href="https://fonts.googleapis.com/css?family=JetBrains+Mono,+LXGW+WenKai+Screen+GB+Screen:300,300i,400,400i,700,700i%7CJetBrains+Mono,+Consolas:400,400i,700,700i&amp;display=fallback" rel="stylesheet"/>
<style>:root{--md-text-font:"JetBrains Mono, LXGW WenKai Screen GB Screen";--md-code-font:"JetBrains Mono, Consolas"}</style>
<link href="../../css/heti.css" rel="stylesheet"/>
<link href="../../css/toc_extra.css" rel="stylesheet"/>
<link href="../../css/timeline.css" rel="stylesheet"/>
<link href="../../css/card.css" rel="stylesheet"/>
<link href="../../css/custom.css" rel="stylesheet"/>
<link href="../../css/extra_changelog.css" rel="stylesheet"/>
<link href="../../css/header.css" rel="stylesheet"/>
<link href="../../css/sidebar.css" rel="stylesheet"/>
<link href="https://unpkg.com/katex@0/dist/katex.min.css" rel="stylesheet"/>
<link href="https://gcore.jsdelivr.net/npm/lxgw-wenkai-screen-webfont@1.1.0/style.css" rel="stylesheet"/>
<link href="https://gcore.jsdelivr.net/npm/lxgw-wenkai-webfont@1.1.0/style.css" rel="stylesheet"/>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&amp;display=swap" rel="stylesheet"/>
<script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
<script id="__analytics">function __md_analytics(){function e(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],e("js",new Date),e("config","G-43NH8CVRCJ"),document.addEventListener("DOMContentLoaded",(function(){document.forms.search&&document.forms.search.query.addEventListener("blur",(function(){this.value&&e("event","search",{search_term:this.value})}));document$.subscribe((function(){var t=document.forms.feedback;if(void 0!==t)for(var a of t.querySelectorAll("[type=submit]"))a.addEventListener("click",(function(a){a.preventDefault();var n=document.location.pathname,d=this.getAttribute("data-md-value");e("event","feedback",{page:n,data:d}),t.firstElementChild.disabled=!0;var r=t.querySelector(".md-feedback__note [data-md-value='"+d+"']");r&&(r.hidden=!1)})),t.hidden=!1})),location$.subscribe((function(t){e("config","G-43NH8CVRCJ",{page_path:t.pathname})}))}));var t=document.createElement("script");t.async=!0,t.src="https://www.googletagmanager.com/gtag/js?id=G-43NH8CVRCJ",document.getElementById("__analytics").insertAdjacentElement("afterEnd",t)}</script>
<script>"undefined"!=typeof __md_analytics&&__md_analytics()</script>
</head>
<body data-md-color-accent="indigo" data-md-color-primary="indigo" data-md-color-scheme="slate" dir="ltr">
<input autocomplete="off" class="md-toggle" data-md-toggle="drawer" id="__drawer" type="checkbox"/>
<input autocomplete="off" class="md-toggle" data-md-toggle="search" id="__search" type="checkbox"/>
<label class="md-overlay" for="__drawer"></label>
<div data-md-component="skip">
<a class="md-skip" href="#chap-1-mathematical-premiminaries">
          跳转至
        </a>
</div>
<div data-md-component="announce">
</div>
<header class="md-header" data-md-component="header">
<nav aria-label="页眉" class="md-header__inner md-grid">
<a aria-label="NoughtQ的笔记本" class="md-header__button md-logo" data-md-component="logo" href="../.." title="NoughtQ的笔记本">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M9.05 9H7.06V6h1.99V4.03H7.06v-1c0-1.11.89-1.99 1.99-1.99h5.98V8l2.47-1.5L20 8V1.04h1c1.05 0 2 .96 2 1.99V17c0 1.03-.95 2-2 2H9.05c-1.05 0-1.99-.95-1.99-2v-1h1.99v-2H7.06v-3h1.99zM1 18h2v-3H1v-2h2v-3H1V8h2V5h2v3H3v2h2v3H3v2h2v3H3v2h2v1h16v2H5a2 2 0 0 1-2-2v-1H1z"></path></svg>
</a>
<label class="md-header__button md-icon" for="__drawer">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"></path></svg>
</label>
<div class="md-header__title" data-md-component="header-title">
<div class="md-header__ellipsis">
<div class="md-header__topic">
<span class="md-ellipsis">
            NoughtQ的笔记本
          </span>
</div>
<div class="md-header__topic" data-md-component="header-topic">
<span class="md-ellipsis">
            
              Chap 1: Mathematical Premiminaries
            
          </span>
</div>
</div>
</div>
<form class="md-header__option" data-md-component="palette">
<input aria-label="Dark Mode" class="md-option" data-md-color-accent="indigo" data-md-color-media="(prefer-color-scheme: dark)" data-md-color-primary="indigo" data-md-color-scheme="slate" id="__palette_0" name="__palette" type="radio"/>
<label class="md-header__button md-icon" for="__palette_1" hidden="" title="Dark Mode">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="m17.75 4.09-2.53 1.94.91 3.06-2.63-1.81-2.63 1.81.91-3.06-2.53-1.94L12.44 4l1.06-3 1.06 3zm3.5 6.91-1.64 1.25.59 1.98-1.7-1.17-1.7 1.17.59-1.98L15.75 11l2.06-.05L18.5 9l.69 1.95zm-2.28 4.95c.83-.08 1.72 1.1 1.19 1.85-.32.45-.66.87-1.08 1.27C15.17 23 8.84 23 4.94 19.07c-3.91-3.9-3.91-10.24 0-14.14.4-.4.82-.76 1.27-1.08.75-.53 1.93.36 1.85 1.19-.27 2.86.69 5.83 2.89 8.02a9.96 9.96 0 0 0 8.02 2.89m-1.64 2.02a12.08 12.08 0 0 1-7.8-3.47c-2.17-2.19-3.33-5-3.49-7.82-2.81 3.14-2.7 7.96.31 10.98 3.02 3.01 7.84 3.12 10.98.31"></path></svg>
</label>
<input aria-label="Light Mode" class="md-option" data-md-color-accent="indigo" data-md-color-media="(prefer-color-scheme: light)" data-md-color-primary="indigo" data-md-color-scheme="default" id="__palette_1" name="__palette" type="radio"/>
<label class="md-header__button md-icon" for="__palette_0" hidden="" title="Light Mode">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 7a5 5 0 0 1 5 5 5 5 0 0 1-5 5 5 5 0 0 1-5-5 5 5 0 0 1 5-5m0 2a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3m0-7 2.39 3.42C13.65 5.15 12.84 5 12 5s-1.65.15-2.39.42zM3.34 7l4.16-.35A7.2 7.2 0 0 0 5.94 8.5c-.44.74-.69 1.5-.83 2.29zm.02 10 1.76-3.77a7.131 7.131 0 0 0 2.38 4.14zM20.65 7l-1.77 3.79a7.02 7.02 0 0 0-2.38-4.15zm-.01 10-4.14.36c.59-.51 1.12-1.14 1.54-1.86.42-.73.69-1.5.83-2.29zM12 22l-2.41-3.44c.74.27 1.55.44 2.41.44.82 0 1.63-.17 2.37-.44z"></path></svg>
</label>
</form>
<script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
<label class="md-header__button md-icon" for="__search">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"></path></svg>
</label>
<div class="md-search" data-md-component="search" role="dialog">
<label class="md-search__overlay" for="__search"></label>
<div class="md-search__inner" role="search">
<form class="md-search__form" name="search">
<input aria-label="搜索" autocapitalize="off" autocomplete="off" autocorrect="off" class="md-search__input" data-md-component="search-query" name="query" placeholder="搜索" required="" spellcheck="false" type="text"/>
<label class="md-search__icon md-icon" for="__search">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"></path></svg>
<svg viewbox="0 0 320 512" xmlns="http://www.w3.org/2000/svg"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256l137.3-137.4c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"></path></svg>
</label>
<nav aria-label="查找" class="md-search__options">
<a aria-label="分享" class="md-search__icon md-icon" data-clipboard="" data-clipboard-text="" data-md-component="search-share" href="javascript:void(0)" tabindex="-1" title="分享">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9a3 3 0 0 0-3 3 3 3 0 0 0 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.15c-.05.21-.08.43-.08.66 0 1.61 1.31 2.91 2.92 2.91s2.92-1.3 2.92-2.91A2.92 2.92 0 0 0 18 16.08"></path></svg>
</a>
<button aria-label="清空当前内容" class="md-search__icon md-icon" tabindex="-1" title="清空当前内容" type="reset">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"></path></svg>
</button>
</nav>
</form>
<div class="md-search__output">
<div class="md-search__scrollwrap" data-md-scrollfix="" tabindex="0">
<div class="md-search-result" data-md-component="search-result">
<div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
<ol class="md-search-result__list" role="presentation"></ol>
</div>
</div>
</div>
</div>
</div>
<div class="md-header__source">
<a class="md-source" data-md-component="source" href="https://github.com/noughtq/notebook" title="前往仓库">
<div class="md-source__icon md-icon">
<svg viewbox="0 0 448 512" xmlns="http://www.w3.org/2000/svg"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81"></path></svg>
</div>
<div class="md-source__repository">
    NoughtQ/Notebook
  </div>
</a>
</div>
</nav>
</header>
<div class="md-container" data-md-component="container">
<nav aria-label="标签" class="md-tabs" data-md-component="tabs">
<div class="md-grid">
<ul class="md-tabs__list">
<li class="md-tabs__item">
<a class="md-tabs__link" href="../../index.html">
          
  
  
    
  
  🏫主页

        </a>
</li>
<li class="md-tabs__item">
<a class="md-tabs__link" href="../../lang/index.html">
          
  
  
    
  
  🔡语言

        </a>
</li>
<li class="md-tabs__item">
<a class="md-tabs__link" href="../index.html">
          
  
  
    
  
  📊数学相关

        </a>
</li>
<li class="md-tabs__item">
<a class="md-tabs__link" href="../../algorithms/index.html">
          
  
  
    
  
  🧮算法相关

        </a>
</li>
<li class="md-tabs__item">
<a class="md-tabs__link" href="../../software/index.html">
          
  
  
    
  
  💾软件相关

        </a>
</li>
<li class="md-tabs__item">
<a class="md-tabs__link" href="../../system/index.html">
          
  
  
    
  
  💻系统相关

        </a>
</li>
<li class="md-tabs__item">
<a class="md-tabs__link" href="../../web/index.html">
          
  
  
    
  
  🌏Web相关

        </a>
</li>
<li class="md-tabs__item">
<a class="md-tabs__link" href="../../sec/ctf-101/index.html">
          
  
  
    
  
  🛡️信息安全

        </a>
</li>
<li class="md-tabs__item">
<a class="md-tabs__link" href="../../ai/index.html">
          
  
  
    
  
  🤖人工智能

        </a>
</li>
<li class="md-tabs__item">
<a class="md-tabs__link" href="../../misc/index.html">
          
  
  
    
  
  🗃️杂项

        </a>
</li>
<li class="md-tabs__item">
<a class="md-tabs__link" href="../../tools/index.html">
          
  
  
    
  
  🛠️工具

        </a>
</li>
<li class="md-tabs__item">
<a class="md-tabs__link" href="../../papers/index.html">
          
  
  
    
  
  📑论文阅读

        </a>
</li>
</ul>
</div>
</nav>
<main class="md-main" data-md-component="main">
<div class="md-main__inner md-grid">
<div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav aria-label="导航栏" class="md-nav md-nav--primary md-nav--lifted" data-md-level="0">
<label class="md-nav__title" for="__drawer">
<a aria-label="NoughtQ的笔记本" class="md-nav__button md-logo" data-md-component="logo" href="../.." title="NoughtQ的笔记本">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M9.05 9H7.06V6h1.99V4.03H7.06v-1c0-1.11.89-1.99 1.99-1.99h5.98V8l2.47-1.5L20 8V1.04h1c1.05 0 2 .96 2 1.99V17c0 1.03-.95 2-2 2H9.05c-1.05 0-1.99-.95-1.99-2v-1h1.99v-2H7.06v-3h1.99zM1 18h2v-3H1v-2h2v-3H1V8h2V5h2v3H3v2h2v3H3v2h2v3H3v2h2v1h16v2H5a2 2 0 0 1-2-2v-1H1z"></path></svg>
</a>
    NoughtQ的笔记本
  </label>
<div class="md-nav__source">
<a class="md-source" data-md-component="source" href="https://github.com/noughtq/notebook" title="前往仓库">
<div class="md-source__icon md-icon">
<svg viewbox="0 0 448 512" xmlns="http://www.w3.org/2000/svg"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81"></path></svg>
</div>
<div class="md-source__repository">
    NoughtQ/Notebook
  </div>
</a>
</div>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
<a class="md-nav__link" href="../../index.html">
<span class="md-ellipsis">
    🏫主页
    
  </span>
<span class="md-nav__icon md-icon"></span>
</a>
</li>
<li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
<a class="md-nav__link" href="../../lang/index.html">
<span class="md-ellipsis">
    🔡语言
    
  </span>
<span class="md-nav__icon md-icon"></span>
</a>
</li>
<li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
<a class="md-nav__link" href="../index.html">
<span class="md-ellipsis">
    📊数学相关
    
  </span>
<span class="md-nav__icon md-icon"></span>
</a>
</li>
<li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
<a class="md-nav__link" href="../../algorithms/index.html">
<span class="md-ellipsis">
    🧮算法相关
    
  </span>
<span class="md-nav__icon md-icon"></span>
</a>
</li>
<li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
<a class="md-nav__link" href="../../software/index.html">
<span class="md-ellipsis">
    💾软件相关
    
  </span>
<span class="md-nav__icon md-icon"></span>
</a>
</li>
<li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
<a class="md-nav__link" href="../../system/index.html">
<span class="md-ellipsis">
    💻系统相关
    
  </span>
<span class="md-nav__icon md-icon"></span>
</a>
</li>
<li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
<a class="md-nav__link" href="../../web/index.html">
<span class="md-ellipsis">
    🌏Web相关
    
  </span>
<span class="md-nav__icon md-icon"></span>
</a>
</li>
<li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
<a class="md-nav__link" href="../../sec/ctf-101/index.html">
<span class="md-ellipsis">
    🛡️信息安全
    
  </span>
<span class="md-nav__icon md-icon"></span>
</a>
</li>
<li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
<a class="md-nav__link" href="../../ai/index.html">
<span class="md-ellipsis">
    🤖人工智能
    
  </span>
<span class="md-nav__icon md-icon"></span>
</a>
</li>
<li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
<a class="md-nav__link" href="../../misc/index.html">
<span class="md-ellipsis">
    🗃️杂项
    
  </span>
<span class="md-nav__icon md-icon"></span>
</a>
</li>
<li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
<a class="md-nav__link" href="../../tools/index.html">
<span class="md-ellipsis">
    🛠️工具
    
  </span>
<span class="md-nav__icon md-icon"></span>
</a>
</li>
<li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
<a class="md-nav__link" href="../../papers/index.html">
<span class="md-ellipsis">
    📑论文阅读
    
  </span>
<span class="md-nav__icon md-icon"></span>
</a>
</li>
</ul>
</nav>
</div>
</div>
</div>
<div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav aria-label="目录" class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">
<span class="md-nav__icon md-icon"></span>
        目录
      </label>
<ul class="md-nav__list" data-md-component="toc" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="#roundoff-errors-and-computer-arithmetic">
<span class="md-ellipsis">
      Roundoff Errors and Computer Arithmetic
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#algorithms-and-convergence">
<span class="md-ellipsis">
      Algorithms and Convergence
    </span>
</a>
</li>
</ul>
</nav>
</div>
</div>
</div>
<div class="md-content" data-md-component="content">
<article class="md-content__inner md-typeset">
<a class="md-content__button md-icon" href="https://github.com/noughtq/notebook/edit/master/docs/math/na/print_version.md" title="编辑此页">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M10 20H6V4h7v5h5v3.1l2-2V8l-6-6H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h4zm10.2-7c.1 0 .3.1.4.2l1.3 1.3c.2.2.2.6 0 .8l-1 1-2.1-2.1 1-1c.1-.1.2-.2.4-.2m0 3.9L14.1 23H12v-2.1l6.1-6.1z"></path></svg>
</a>
<a class="md-content__button md-icon" href="https://github.com/noughtq/notebook/raw/master/docs/math/na/print_version.md" title="查看本页的源代码">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M17 18c.56 0 1 .44 1 1s-.44 1-1 1-1-.44-1-1 .44-1 1-1m0-3c-2.73 0-5.06 1.66-6 4 .94 2.34 3.27 4 6 4s5.06-1.66 6-4c-.94-2.34-3.27-4-6-4m0 6.5a2.5 2.5 0 0 1-2.5-2.5 2.5 2.5 0 0 1 2.5-2.5 2.5 2.5 0 0 1 2.5 2.5 2.5 2.5 0 0 1-2.5 2.5M9.27 20H6V4h7v5h5v4.07c.7.08 1.36.25 2 .49V8l-6-6H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h4.5a8.2 8.2 0 0 1-1.23-2"></path></svg>
</a>
<div><h1 id="chap-1-mathematical-premiminaries">Chap 1: Mathematical Premiminaries<a class="headerlink" href="#chap-1-mathematical-premiminaries" title="Permanent link">⚓︎</a></h1>
<h2 id="roundoff-errors-and-computer-arithmetic">Roundoff Errors and Computer Arithmetic<a class="headerlink" href="#roundoff-errors-and-computer-arithmetic" title="Permanent link">⚓︎</a></h2>
<p><strong>讨论<span><span class="heti-spacing"> </span>1</span>：近似表示<span><span class="heti-spacing"> </span><span class="arithmatex">\(\int_0^1 e^{-x^2} dx\)</span></span></strong></p>
<p>使用泰勒展开式表示<span><span class="heti-spacing"> </span><span class="arithmatex">\(e^{-x^2}\)</span></span>，因此：</p>
<div class="arithmatex">\[
\begin{align}
\int_0^1 e^{-x^2} dx &amp; = \int_0^1 (1 - x^2 + \dfrac{x^4}{2!} - \dfrac{x^6}{3!} + \dfrac{x^8}{4!} - \dots) dx \notag \\
&amp; = \underbrace{1 - \dfrac{1}{3} + \dfrac{1}{2!} \times \dfrac{1}{5} - \dfrac{1}{3!} \times \dfrac{1}{7}}_{S_4} + \underbrace{\dfrac{1}{4!} \times \dfrac{1}{9} - \dots}_{R_4} \notag
\end{align}
\]</div>
<p>令<span><span class="heti-spacing"> </span><span class="arithmatex">\(\int_0^1 e^{-x^2} dx = S_4 = 1 - \dfrac{1}{3} + \dfrac{1}{10} - \dfrac{1}{42} \approx 1 - 0.333 + 0.1 - 0.024 = 0.743\)</span></span></p>
<p>因为余项<span><span class="heti-spacing"> </span><span class="arithmatex">\(|R_4| = |\dfrac{1}{4!} \times \dfrac{1}{9} - \dfrac{1}{5!} \times \dfrac{1}{11} + \dots| &lt; \dfrac{1}{4!} \times \dfrac{1}{9} &lt; 0.005\)</span></span>，所以上述结果保留到千分位。</p>
<p>综上：</p>
<ul>
<li>舍入误差<span><span class="heti-spacing"> </span>&lt; 0.0005 * 2 = 0.001</span></li>
<li>截断误差<span><span class="heti-spacing"> </span>&lt; 0.005</span></li>
<li><span>|<span class="heti-spacing"> </span></span>总误差<span><span class="heti-spacing"> </span>| &lt; 0.006</span></li>
</ul>
<p>接下来马上介绍误差的概念<span><span class="heti-spacing"> </span>~</span></p>
<p>从<u>成因</u>角度来看，<strong>误差</strong><span>(error)<span class="heti-spacing"> </span></span>可以分为：</p>
<ul>
<li><strong>截断误差</strong>(truncation error)：从用于近似表示无限级数的，截断或有限的求和中得到的误差</li>
<li><strong>舍入误差</strong>(roundoff error)：执行实数计算时得到的误差。由于机器只能表示有限位的数字，因此进行算术运算时会产生这种误差</li>
</ul>
<p>用<strong>规范化</strong><span>(normalized)<span class="heti-spacing"> </span></span>的十进制浮点数形式表示实数（<span><span class="arithmatex">\(k\)</span><span class="heti-spacing"> </span></span>位十进制机器数<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>：</p>
<div class="arithmatex">\[
\pm 0.d_1 d_2 \dots d_k \times 10^n \quad \text{where } 1 \le d_1 \le 9 \text{ and } 0 \le d_i \le 9 (i = 2, \dots, k)
\]</div>
<p>具体来说，假如给定一个实数<span><span class="heti-spacing"> </span><span class="arithmatex">\(y = \textcolor{cornflowerblue}{0.d_1 d_2 \dots d_k} d_{k+1} d_{k+2} \dots \times \textcolor{cornflowerblue}{10^n}\)</span></span>，那么它对应的浮点数形式为：</p>
<div class="arithmatex">\[
fl(y) = \begin{cases}0.d_1 d_2 \dots d_k \times 10^n &amp; \text{Chopping} \\ chop(y + 5 \times 10^{n - (k+1)}) = 0.\delta_1 \delta_2 \dots \delta_k \times 10^n &amp; \text{Rounding}\end{cases}
\]</div>
<hr/>
<p>此外，误差又可按<u>测量</u>方式的不同分为（假设<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(p^*\)</span><span class="heti-spacing"> </span></span>是<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(p\)</span><span class="heti-spacing"> </span></span>的近似形式<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>：</p>
<ul>
<li><strong>绝对误差</strong>(absolute error)：<span class="arithmatex">\(|p - p^*|\)</span></li>
<li><strong>相对误差</strong>(relative error)：<span class="arithmatex">\(\dfrac{|p - p^*|}{|p|}, p \ne 0\)</span></li>
</ul>
<p>如果<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(t\)</span><span class="heti-spacing"> </span></span>是满足下面关系的最大非负整数，那么称<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(p^*\)</span><span class="heti-spacing"> </span></span>是<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(p\)</span><span class="heti-spacing"> </span></span>保留至<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(t\)</span><span class="heti-spacing"> </span></span>位<strong>有效数字</strong><span>(significant digits)<span class="heti-spacing"> </span></span>的近似形式。</p>
<div class="arithmatex">\[
\dfrac{|p - p^*|}{p} &lt; 5 \times 10^{-t}
\]</div>
<blockquote>
<p>所以有效数字的定义是从<strong>相对误差</strong>出发的。</p>
</blockquote>
<p>回到前面对截断和舍入的讨论，比较一下它们的相对误差：</p>
<ul>
<li>
<p><strong>截断</strong>(chopping)</p>
<div class="arithmatex">\[
\begin{align}
\Big|\dfrac{p - p^*}{p}\Big| &amp; = \Big| \dfrac{0.d_1 d_2 \dots d_k d_{k+1} \dots \times 10^n - 0.d_1 d_2 \dots d_k \times 10^n}{0.d_1 d_2 \dots d_k d_{k+1} \dots \times 10^n} \Big| \notag \\
&amp; = \Big|\dfrac{0.d_{k+1} d_{k+2} \dots}{0.d_1 d_2 \dots}\Big| \times 10^{-k} \le \dfrac{1}{0.1} \times 10^{-k} = 10^{-k+1} \notag
\end{align}
\]</div>
</li>
<li>
<p><strong>舍入</strong>(rounding)</p>
<div class="arithmatex">\[
\Big|\dfrac{p - p^*}{p}\Big| \le \dfrac{0.5}{0.1} \times 10^{-k} = 0.5 \times 10^{-k+1}
\]</div>
</li>
</ul>
<p>舍入误差对计算结果的影响：</p>
<ul>
<li>
<p>两个近乎相等的数字相减，会导致有效位数的抵消</p>
<p><strong>例子</strong>:</p>
<p><span><span class="arithmatex">\(a_1 = 0.1234\textcolor{red}{5}, a_2 = 0.1234\textcolor{red}{6}\)</span><span class="heti-spacing"> </span></span>都有<span class="heti-skip"><span class="heti-spacing"> </span>5<span class="heti-spacing"> </span></span>位有效数字，但是<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(a_2 - a_1 = 0.0000\textcolor{red}{1}\)</span><span class="heti-spacing"> </span></span>只有<span class="heti-skip"><span class="heti-spacing"> </span>1<span class="heti-spacing"> </span></span>位有效数字。</p>
</li>
<li>
<p>用一个很小的数去除（或用很大的数去乘）另一个数，会导致误差的扩大</p>
<p><strong>例子</strong>：</p>
<p>假如有一个值<span><span class="heti-spacing"> </span><span class="arithmatex">\(a = \dfrac{p}{q}\)</span></span>，它的近似结果为<span><span class="heti-spacing"> </span><span class="arithmatex">\(a^* = \dfrac{p + \varepsilon_p}{q + \varepsilon_q}\)</span></span>。那么：</p>
<ul>
<li>绝对误差<span><span class="heti-spacing"> </span><span class="arithmatex">\(e_{\text{abs}} = |a^* - a|\)</span></span></li>
<li>相对误差<span><span class="heti-spacing"> </span><span class="arithmatex">\(e_{\text{rel}} = \dfrac{e_{\text{abs}}}{a}\)</span></span></li>
</ul>
<p>我们可以把绝对误差看作是<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(q\)</span><span class="heti-spacing"> </span></span>关于<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\dfrac{p}{q}\)</span><span class="heti-spacing"> </span></span>的函数，对它求导，我们就能观察绝对误差的变化率。所以：</p>
</li>
</ul>
<p>$$
    \begin{align}
    e_{\text{abs}}'(q) &amp; = \dfrac{d\frac{p}{q}}{dq} \notag \
    &amp; = -\dfrac{p}{q^2} \notag
    \end{align}
  $$</p>
<div class="language-text highlight"><pre><span></span><code>因此，如果 $q$ 是一个很小的数，那么对其稍加改动，绝对误差就会产生很大的变化。
</code></pre></div>
<p>启示：在让计算机计算数学公式前，要先对公式化简，以降低对精度的影响。</p>
<p><strong>讨论<span><span class="heti-spacing"> </span>2</span></strong></p>
<p>问题：计算<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f(x) = x^3 - 6.1x^2 + 3.2x + 1.5\)</span><span class="heti-spacing"> </span></span>在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(x = 4.71\)</span><span class="heti-spacing"> </span></span>时的值，保留<span class="heti-skip"><span class="heti-spacing"> </span>3<span class="heti-spacing"> </span></span>位有效数字。</p>
<p>分析：</p>
<p>比较精确计算，以及分别使用截断和舍入两种方法近似的结果：</p>
<div style="text-align: center">
<img src="images/C1/2.png" width="80%/"/>
</div>
<p><strong>注意</strong>：中间结果也要记得截断<span class="heti-skip"><span class="heti-spacing"> </span>/<span class="heti-spacing"> </span></span>舍入，不是只对最终结果截断<span class="heti-skip"><span class="heti-spacing"> </span>/<span class="heti-spacing"> </span></span>舍入！</p>
<p>最终结果：</p>
<ul>
<li><span style="color:cornflowerblue">Exact = -14.263899</span></li>
<li><span style="color:green">Chopping = -13.5</span></li>
<li><span style="color:red">Rounding = -13.4</span></li>
</ul>
<p>相对误差：</p>
<ul>
<li><span style="color:green">Chopping = 5%</span></li>
<li><span style="color:red">Rounding = 6%</span></li>
</ul>
<p>因此两种近似方法得到结果误差都偏大，而且舍入近似法效果更差。</p>
<hr/>
<p>下面介绍一种可以使近似结果更为精确的方法——<a href="https://en.wikipedia.org/wiki/Horner%27s_method"><strong>秦九韶算法</strong></a>（又称<span><span class="heti-spacing"> </span>Horner's Method</span><heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，它可以将多项式转化为：</p>
<div class="arithmatex">\[
\begin{align}
&amp; a_0 + a_1 x + a_2 x^2 + a_3 x^3 + \dots + a_n x^n \notag \\
= &amp; a_0 + x(a_1 + x(a_2 + x(a_3 + \dots + x(a_{n-1} + xa_n) \dots ))) \notag
\end{align}
\]</div>
<p>利用这一公式，我们可以将原函数转换为：</p>
<div class="arithmatex">\[
f(x) = x^3 - 6.1x^2 + 3.2x + 1.5 = ((x - 6.1)x + 3.2)x + 1.5
\]</div>
<p>最终结果：</p>
<ul>
<li><span style="color:green">Chopping = -14.2</span></li>
<li><span style="color:red">Rounding = -14.3</span></li>
</ul>
<p>相对误差：</p>
<ul>
<li><span style="color:green">Chopping = 0.45%</span></li>
<li><span style="color:red">Rounding = 0.25%</span></li>
</ul>
<h2 id="algorithms-and-convergence">Algorithms and Convergence<a class="headerlink" href="#algorithms-and-convergence" title="Permanent link">⚓︎</a></h2>
<p><strong>定义</strong>：</p>
<p>若算法满足：对初始数据的微小改动对最终结果的影响不大，那么称这样的算法是<strong>稳定的</strong>(stable)，否则就是<strong>不稳定的</strong>(unstable)。如果算法仅对某些特定的初始数据改动是稳定的，那么称这种算法是<strong>条件稳定的</strong>(conditionally stable)。</p>
<blockquote>
<p>注：到<a href="5.html#stability">第<span class="heti-skip"><span class="heti-spacing"> </span>5<span class="heti-spacing"> </span></span>章</a>的时候我们还会回过头来看这个概念。</p>
</blockquote>
<p><strong>定义</strong></p>
<p>令<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(E_0 &gt; 0\)</span><span class="heti-spacing"> </span></span>表示初始误差，<span><span class="arithmatex">\(E_n\)</span><span class="heti-spacing"> </span></span>表示<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n\)</span><span class="heti-spacing"> </span></span>次运算后的误差。</p>
<ul>
<li>如果<span><span class="heti-spacing"> </span><span class="arithmatex">\(E_n \approx C n E_0\)</span></span>，其中<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(C\)</span><span class="heti-spacing"> </span></span>是与<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n\)</span><span class="heti-spacing"> </span></span>独立的常量，那么称误差是<strong>线性</strong><span>(linear)<span class="heti-spacing"> </span></span>增长的</li>
<li>如果<span><span class="heti-spacing"> </span><span class="arithmatex">\(E_n \approx C^n E_0\)</span></span>，其中<span><span class="heti-spacing"> </span><span class="arithmatex">\(C &gt; 1\)</span></span>，那么称误差是<strong>指数</strong><span>(exponential)<span class="heti-spacing"> </span></span>增长的</li>
</ul>
<p><strong>注</strong></p>
<ul>
<li>误差的<strong>线性</strong>增长通常是不可避免的，且当<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(C\)</span><span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(E_0\)</span><span class="heti-spacing"> </span></span>都很小的时候，一般而言结果是<strong>可被接受的</strong></li>
<li>误差的<strong>指数</strong>增长应当避免，因为即使对于很小的<span><span class="heti-spacing"> </span><span class="arithmatex">\(n\)</span></span>，<span><span class="arithmatex">\(C^n\)</span><span class="heti-spacing"> </span></span>的值也可能变得很大。无论<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(E_0\)</span><span class="heti-spacing"> </span></span>的大小如何，这样的误差都会导致<strong>不可接受的</strong>不精确结果。</li>
</ul>
<p><strong>例子</strong></p>
<p>题目：计算<span><span class="heti-spacing"> </span><span class="arithmatex">\(I_n = \dfrac{1}{e} \int_0^1 x^n e^x dx, n = 0, 1, 2, \dots\)</span></span></p>
<p>分析：</p>
<p>法<span><span class="heti-spacing"> </span>1</span>：</p>
<ul>
<li>通过分部积分法，可以得到：<span class="arithmatex">\(I_n = 1 - nI_{n-1}\)</span></li>
<li><span class="arithmatex">\(I_0 = \dfrac{1}{e} \int_0^1 e^x dx = 1 - \dfrac{1}{e} \approx 0.63212056 = I_0^*\)</span>，对应的绝对误差<span><span class="heti-spacing"> </span><span class="arithmatex">\(|E_0| = |I_0 - I_0^*| &lt; 0.5 \times 10^{-8}\)</span></span></li>
<li>此外，可以得到不等式：<span class="arithmatex">\(\dfrac{1}{e} \int_0^1 x^n e^0 dx &lt; I_n &lt; \dfrac{1}{e} \int_0^1 x^n e^1 dx\)</span>，因此<span><span class="heti-spacing"> </span><span class="arithmatex">\(I_n \in \Big(\dfrac{1}{e(n+1)}, \dfrac{1}{n+1}\Big)\)</span></span></li>
<li>
<p>然而，借助第<span class="heti-skip"><span class="heti-spacing"> </span>1<span class="heti-spacing"> </span></span>步的等式和第<span class="heti-skip"><span class="heti-spacing"> </span>2<span class="heti-spacing"> </span></span>步的近似结果，我们继续计算后面的结果，发现：</p>
<p></p><div style="text-align: center">
<img src="images/C1/3.png" width="40%/"/>
</div>
<p>误差越来越大，才算了十几项计算的结果就变得很离谱，明显超出第<span class="heti-skip"><span class="heti-spacing"> </span>3<span class="heti-spacing"> </span></span>步得到的不等式范围</p>
</li>
</ul>
<p><strong>讨论<span><span class="heti-spacing"> </span>3</span>：出现上述情况的原因？</strong></p>
<p>绝对误差<span><span class="heti-spacing"> </span><span class="arithmatex">\(|E_n| = |I_n - I_n^*| = |(1 - nI_{n-1}) - (1 - nI_{n-1}^*)| = n|E_{n-1}| = \dots = n!|E_0|\)</span></span>，所以误差是以阶乘速度增长的，比指数级别的增长还要快得多！</p>
<hr/>
<p>法<span><span class="heti-spacing"> </span>2</span>：
- 在法1基础上，将等式 <span class="arithmatex">\(I_n = 1 - nI_{n-1}\)</span> 转换为等价形式 <span class="arithmatex">\(I_{n-1} = \dfrac{1}{n} (1 - I_n)\)</span>
- 同样根据法1得到的不等式，我们取中间值作为 <span class="arithmatex">\(I_n\)</span> 的近似值，即令 <span class="arithmatex">\(I_n^* = \dfrac{1}{2} \Big[\dfrac{1}{e(N+1)} + \dfrac{1}{N+1}\Big] \approx I_n\)</span>
- 此时的绝对误差为：<span class="arithmatex">\(|E_n| = |I_n - I_n^*| \rightarrow 0, n \rightarrow +\infty\)</span>
- 现在得到的计算结果如下所示：</p>
<div class="language-text highlight"><pre><span></span><code>&lt;div style="text-align: center"&gt;
    &lt;img src="images/C1/4.png" width=60%/&gt;
&lt;/div&gt;

可以看到，计算结果的误差变得很小了，到达可以被接受的程度
</code></pre></div>
<ul>
<li>这种转换之所以可行，是因为<span><span class="heti-spacing"> </span><span class="arithmatex">\(|E_{n-1}| = \Big| \dfrac{1}{n} (1 - I_n) - \dfrac{1}{n} (1 - I_n^*) \Big| = \dfrac{1}{n}|E_n|\)</span></span>，从而<span><span class="heti-spacing"> </span><span class="arithmatex">\(|E_n| = \dfrac{1}{N(N-1)\dots(n+1)} |E_N|\)</span></span>，也就是说即使当<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n\)</span><span class="heti-spacing"> </span></span>变得很大，误差还是很小，是稳定的误差</li>
</ul>
<p><strong>注</strong> ：在之后的学习中，我们需时刻关注误差对近似求解的影响；并要记住：输出值的误差来自输入值的误差（误差的<strong>传播性</strong>(propagation)<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>。</p>
<p><strong>补充：收敛速度</strong> ：若<span><span class="heti-spacing"> </span><span class="arithmatex">\(\lim\limits_{h \rightarrow 0} f(h) = L\)</span></span>，那么<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f(h)\)</span><span class="heti-spacing"> </span></span>的收敛速度<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(p\)</span><span class="heti-spacing"> </span></span>满足：<span class="arithmatex">\(f(h) - L = O(h^p)\)</span>。</p>
<h1 id="chap-2-solutions-of-equations-in-one-variable">Chap 2: Solutions of Equations in One Variable<a class="headerlink" href="#chap-2-solutions-of-equations-in-one-variable" title="Permanent link">⚓︎</a></h1>
<p>本章要探讨的问题是：<strong>求<span><span class="heti-spacing"> </span><span class="arithmatex">\(f(x) = 0\)</span></span>（一元方程）的根<span><span class="heti-spacing"> </span>(root)</span></strong>。</p>
<h2 id="the-bisection-method">The Bisection Method<a class="headerlink" href="#the-bisection-method" title="Permanent link">⚓︎</a></h2>
<p>第一种求根方法是<strong>二分法</strong>(bisection method)。它的思路非常简单，以微积分课程中介绍过的<strong>介值定理</strong><span>(intermediate value theorem)<span class="heti-spacing"> </span></span>为理论依据，通过二分不断逼近真正的根。</p>
<p><strong>介值定理</strong> ：如果<span><span class="heti-spacing"> </span><span class="arithmatex">\(f \in C[a, b]\)</span></span>（<span><span class="arithmatex">\(C\)</span><span class="heti-spacing"> </span></span>表示连续函数）且<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(K\)</span><span class="heti-spacing"> </span></span>是介于<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f(a)\)</span><span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f(b)\)</span><span class="heti-spacing"> </span></span>之间的任意值，那么存在一个数<span><span class="heti-spacing"> </span><span class="arithmatex">\(p \in (a, b)\)</span></span>，使得<span><span class="heti-spacing"> </span><span class="arithmatex">\(f(p) = K\)</span></span></p>
<div style="text-align: center">
<img src="images/C2/1.png" width="50%/"/>
</div>
<p>接下来基于上图来演示二分法的过程：</p>
<p><strong>过程演示</strong></p>
<p>Step 1：</p>
<div style="text-align: center">
<img src="images/C2/2.png" width="50%/"/>
</div>
<p>在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(a, b\)</span><span class="heti-spacing"> </span></span>之间取中点<span><span class="heti-spacing"> </span><span class="arithmatex">\(p_1\)</span></span>。观察图像，并根据介值定理，<span><span class="arithmatex">\(f(p_1), f(b)\)</span><span class="heti-spacing"> </span></span>之间存在取值为<span class="heti-skip"><span class="heti-spacing"> </span>0<span class="heti-spacing"> </span></span>的情况，那么真正的根<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(p\)</span><span class="heti-spacing"> </span></span>一定落在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(p_1\)</span><span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(b\)</span><span class="heti-spacing"> </span></span>之间，所以接下来令<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(p_1\)</span><span class="heti-spacing"> </span></span>为下界<span><span class="heti-spacing"> </span><span class="arithmatex">\(a\)</span></span>，继续二分。</p>
<p>Step 2：</p>
<div style="text-align: center">
<img src="images/C2/3.png" width="50%/"/>
</div>
<p>在<span><span class="heti-spacing"> </span><span class="arithmatex">\(a\)</span></span>（原来为<span><span class="heti-spacing"> </span><span class="arithmatex">\(p_1\)</span></span>）<span>, <span class="arithmatex">\(b\)</span><span class="heti-spacing"> </span></span>之间取中点<span><span class="heti-spacing"> </span><span class="arithmatex">\(p_2\)</span></span>。观察图像，并根据介值定理，<span><span class="arithmatex">\(f(a), f(p_2)\)</span><span class="heti-spacing"> </span></span>之间存在取值为<span class="heti-skip"><span class="heti-spacing"> </span>0<span class="heti-spacing"> </span></span>的情况，那么真正的根<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(p\)</span><span class="heti-spacing"> </span></span>一定落在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(a\)</span><span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(p_2\)</span><span class="heti-spacing"> </span></span>之间，所以接下来令<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(p_2\)</span><span class="heti-spacing"> </span></span>为上界<span><span class="heti-spacing"> </span><span class="arithmatex">\(b\)</span></span>，继续二分。</p>
<p>Step X：</p>
<p>后续过程同上所述。</p>
<p><strong>讨论：那么，这一迭代过程何时结束呢？</strong></p>
<p>以下几种条件都可作为停止迭代的根据：</p>
<ul>
<li>绝对误差：<span class="arithmatex">\(|p_N - p_{N-1}| &lt; \varepsilon\)</span></li>
<li>相对误差：<span class="arithmatex">\(\dfrac{|p_N - p_{N-1}|}{|p_N|} &lt; \varepsilon\)</span></li>
<li>函数值：<span class="arithmatex">\(|f(p_N)| &lt; \varepsilon\)</span></li>
</ul>
<p>然而，使用误差作为依据的时候需要当心：因为在实践中，存在序列<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\{p_N\}\)</span><span class="heti-spacing"> </span></span>发散的情况，这个时候不应该将误差作为判断依据。</p>
<div style="text-align: center">
<img src="images/C2/4.png" width="60%/"/>
</div>
<p><strong>定理</strong> ：假设<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f \in C[a, b]\)</span><span class="heti-spacing"> </span></span>且满足<span><span class="heti-spacing"> </span><span class="arithmatex">\(f(a) \cdot f(b) &lt; 0\)</span></span>，那么二分法将产生一个序列<span><span class="heti-spacing"> </span><span class="arithmatex">\(\{p_n\} (n = 1, 2, \dots)\)</span></span>，用于逼近<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f\)</span><span class="heti-spacing"> </span></span>的一个零点<span><span class="heti-spacing"> </span><span class="arithmatex">\(p\)</span></span>，并满足：</p>
<div class="arithmatex">\[
|p_n - p| \le \dfrac{b - a}{2^n} \quad \text{when } n \ge 1
\]</div>
<p><strong>二分法的实现</strong></p>
<p>在连续函数<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f\)</span><span class="heti-spacing"> </span></span>的区间<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\([a, b]\)</span><span class="heti-spacing"> </span></span>上寻找<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f(x) = 0\)</span><span class="heti-spacing"> </span></span>的解，其中<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f(a), f(b)\)</span><span class="heti-spacing"> </span></span>符号相反。</p>
<ul>
<li>输入：端点<span><span class="heti-spacing"> </span><span class="arithmatex">\(a, b\)</span></span>；容忍值<span><span class="heti-spacing"> </span>(tolerance) <span class="arithmatex">\(TOL\)</span></span>；最大迭代次数<span><span class="heti-spacing"> </span><span class="arithmatex">\(N_{max}\)</span></span></li>
<li>输出：<span><span class="arithmatex">\(p\)</span><span class="heti-spacing"> </span></span>的近似解或失败信息</li>
</ul>
<div class="language-cpp highlight"><pre><span></span><code><span id="__span-0-1"><a href="#__codelineno-0-1" id="__codelineno-0-1" name="__codelineno-0-1"></a><span class="n">Step</span><span class="w"> </span><span class="mi">1</span><span class="w">  </span><span class="n">Set</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
</span><span id="__span-0-2"><a href="#__codelineno-0-2" id="__codelineno-0-2" name="__codelineno-0-2"></a><span class="w">            </span><span class="n">FA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
</span><span id="__span-0-3"><a href="#__codelineno-0-3" id="__codelineno-0-3" name="__codelineno-0-3"></a><span class="n">Step</span><span class="w"> </span><span class="mi">2</span><span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">N_max</span><span class="p">)</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="n">steps</span><span class="w"> </span><span class="mi">3-6</span>
</span><span id="__span-0-4"><a href="#__codelineno-0-4" id="__codelineno-0-4" name="__codelineno-0-4"></a><span class="hll"><span class="w">        </span><span class="n">Step</span><span class="w"> </span><span class="mi">3</span><span class="w">  </span><span class="n">Set</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w">  </span><span class="c1">// computer p_i</span>
</span></span><span id="__span-0-5"><a href="#__codelineno-0-5" id="__codelineno-0-5" name="__codelineno-0-5"></a><span class="w">                </span><span class="n">FP</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
</span><span id="__span-0-6"><a href="#__codelineno-0-6" id="__codelineno-0-6" name="__codelineno-0-6"></a><span class="w">        </span><span class="n">Step</span><span class="w"> </span><span class="mi">4</span><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">FP</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">TOL</span><span class="w"> </span><span class="n">then</span><span class="w"> </span><span class="n">Output</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
</span><span id="__span-0-7"><a href="#__codelineno-0-7" id="__codelineno-0-7" name="__codelineno-0-7"></a><span class="w">                </span><span class="n">STOP</span><span class="p">;</span><span class="w">  </span><span class="c1">// successful</span>
</span><span id="__span-0-8"><a href="#__codelineno-0-8" id="__codelineno-0-8" name="__codelineno-0-8"></a><span class="w">        </span><span class="n">Step</span><span class="w"> </span><span class="mi">5</span><span class="w">  </span><span class="n">Set</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">;</span>
</span><span id="__span-0-9"><a href="#__codelineno-0-9" id="__codelineno-0-9" name="__codelineno-0-9"></a><span class="hll"><span class="w">        </span><span class="n">Step</span><span class="w"> </span><span class="mi">6</span><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="n">sign</span><span class="p">(</span><span class="n">FA</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">sign</span><span class="p">(</span><span class="n">FP</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">then</span><span class="w"> </span><span class="n">Set</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">;</span><span class="w"> </span><span class="n">FA</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FP</span><span class="p">;</span>
</span></span><span id="__span-0-10"><a href="#__codelineno-0-10" id="__codelineno-0-10" name="__codelineno-0-10"></a><span class="w">                </span><span class="k">else</span><span class="w"> </span><span class="n">set</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">;</span><span class="w">  </span><span class="c1">// update a_i, b_i</span>
</span><span id="__span-0-11"><a href="#__codelineno-0-11" id="__codelineno-0-11" name="__codelineno-0-11"></a><span class="n">Step</span><span class="w"> </span><span class="mi">7</span><span class="w">  </span><span class="n">Output</span><span class="p">(</span><span class="n">Method</span><span class="w"> </span><span class="n">failed</span><span class="w"> </span><span class="n">after</span><span class="w"> </span><span class="n">N_max</span><span class="w"> </span><span class="n">iterations</span><span class="p">);</span><span class="w">  </span><span class="c1">// unsuccessful</span>
</span><span id="__span-0-12"><a href="#__codelineno-0-12" id="__codelineno-0-12" name="__codelineno-0-12"></a><span class="w">        </span><span class="n">Stop</span><span class="p">.</span>
</span></code></pre></div>
<p><strong>思考伪代码中的高亮部分</strong></p>
<p>问题：</p>
<ul>
<li>为什么取中值的代码不写成 <code>p = (a + b) / 2</code>？</li>
<li>为什么判断上下界的代码不写成 <code>FA * FP &gt; 0</code>？</li>
</ul>
<p>答案：</p>
<p>主要是为了防止<strong>溢出</strong>(overflow)。因为无论是 <code>a + b</code> 还是 <code>FA * FP</code>，如果它们的符号一致，且数值特别大的时候，它们的和或积可能是计算机无法表示出来的东西，也就是产生了溢出的问题，此时该算法可能返回的是一个意料之外的结果，而不产生报错。所以我们需要好好关注这些细节！</p>
<p><strong>对二分法的评价</strong></p>
<p>优点：</p>
<ul>
<li>简单，只要求函数<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f\)</span><span class="heti-spacing"> </span></span>是连续的</li>
<li>结果总是会收敛到真正的解</li>
</ul>
<p>缺点：</p>
<ul>
<li>收敛速度过慢，并且在计算过程中，更好的介值近似可能在不经意间被抛弃掉了</li>
<li>不适用于寻找多根和复数根的情况</li>
</ul>
<p><strong>实际使用时的建议</strong></p>
<ul>
<li>在使用二分法之前先画一幅<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f(x)\)</span><span class="heti-spacing"> </span></span>的草图，先观察二分法是否可行</li>
<li>或者用一个子程序将完整的区间划分为多个子区间<span><span class="heti-spacing"> </span><span class="arithmatex">\([a_k, b_k]\)</span></span>，这样的话即使<span><span class="heti-spacing"> </span><span class="arithmatex">\(f(a) \cdot f(b)\)</span></span>，也可以保证<span><span class="heti-spacing"> </span><span class="arithmatex">\(f(a_k) \cdot f(b_k) &lt; 0\)</span></span></li>
</ul>
<h2 id="fixed-point-iteration">Fixed-Point Iteration<a class="headerlink" href="#fixed-point-iteration" title="Permanent link">⚓︎</a></h2>
<p>接下来介绍第二种求根方法：<strong>不动点迭代</strong>(fixed-point iteration)。</p>
<blockquote>
<p>wiki: <a href="https://en.wikipedia.org/wiki/Fixed_point_(mathematics)">Fixed point</a></p>
</blockquote>
<p>首先，我们要将<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f(x)\)</span><span class="heti-spacing"> </span></span>的根看作<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(g(x)\)</span><span class="heti-spacing"> </span></span>的不动点，即：</p>
<div class="arithmatex">\[
f(x) = 0 \xLeftrightarrow{\text{equivalent}} x = g(x)
\]</div>
<p>基本思路是：从初始的近似值<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(p_0\)</span><span class="heti-spacing"> </span></span>开始，通过<span><span class="heti-spacing"> </span><span class="arithmatex">\(p_n = g(p_{n-1})\)</span></span>（其中<span><span class="heti-spacing"> </span><span class="arithmatex">\(n \ge 1\)</span></span><heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，产生序列<span><span class="heti-spacing"> </span><span class="arithmatex">\(\{p_n\}_{n=0}^\infty\)</span></span>。如果该序列能收敛到<span><span class="heti-spacing"> </span><span class="arithmatex">\(p\)</span></span>，且<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(g\)</span><span class="heti-spacing"> </span></span>是一个连续函数，那么：</p>
<div class="arithmatex">\[
p = \lim\limits_{n \rightarrow \infty} p_n = \lim\limits_{n \rightarrow \infty} g(p_{n-1}) = g(\lim\limits_{n \rightarrow \infty} p_{n-1}) = g(p) 
\]</div>
<p>这个方法看似特别简单：只需不断的迭代，我们总能找到解。但实际上，并不是所有的<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(g(x)\)</span><span class="heti-spacing"> </span></span>都能做到让序列收敛，具体来看下面几个例子：</p>
<p><strong>例子</strong></p>
<p>题目</p>
<p>判断以下几种<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(g(x)\)</span><span class="heti-spacing"> </span></span>中，哪个能做到收敛，为什么？</p>
<blockquote>
<p>建议在阅读答案前，先自己动手画画看</p>
</blockquote>
<div style="text-align: center">
<img src="images/C2/5.png" width="80%/"/>
</div>
<p>答案</p>
<div style="text-align: center">
<img src="images/C2/6.png" width="80%/"/>
</div>
<blockquote>
<p><del>让我不禁回忆起浙江高考恶心人的数列大题</del></p>
</blockquote>
<p><strong>不动点定理</strong> ：令<span><span class="heti-spacing"> </span><span class="arithmatex">\(g \in C[a, b]\)</span></span>，且满足<span><span class="heti-spacing"> </span><span class="arithmatex">\(\forall x \in [a, b]\)</span></span>，有<span><span class="heti-spacing"> </span><span class="arithmatex">\(g(x) \in [a, b]\)</span></span>。并且一阶导函数<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(g'\)</span><span class="heti-spacing"> </span></span>存在于区间<span><span class="heti-spacing"> </span><span class="arithmatex">\((a, b)\)</span></span>，且满足<span><span class="heti-spacing"> </span><span class="arithmatex">\(\forall x \in (a, b)\)</span></span>，<span><span class="arithmatex">\(\exists\)</span><span class="heti-spacing"> </span></span>常数<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(k \in (0, 1)\)</span><span class="heti-spacing"> </span></span>使得<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(|g'(x)| \le k\)</span><span class="heti-spacing"> </span></span>成立。那么<span><span class="heti-spacing"> </span><span class="arithmatex">\(\forall p_0 \in [a, b]\)</span></span>，由<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(p_n = g(p_{n-1}), n \ge 1\)</span><span class="heti-spacing"> </span></span>定义的序列会收敛到位于区间<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\([a, b]\)</span><span class="heti-spacing"> </span></span>上的唯一不动点。</p>
<p><strong>推论</strong> ：如果<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(g\)</span><span class="heti-spacing"> </span></span>满足不动点定理的假设，那么用<span><span class="heti-spacing"> </span><span class="arithmatex">\(p_n\)</span></span>（<span class="arithmatex">\(\forall n \ge 1\)</span>）近似表示<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(p\)</span><span class="heti-spacing"> </span></span>所产生的误差边界为：</p>
<div class="arithmatex">\[
|p_n - p| \le \dfrac{1}{1 - k}|p_{n+1} - p_n| \quad \text{and} \quad |p_n - p| \le \dfrac{k^n}{1 - k} |p_1 - p_0|
\]</div>
<p><strong>讨论：思考这两个不等式的意义</strong></p>
<ul>
<li>前者可以用来控制计算的精度</li>
<li>后者告诉我们：<span><span class="arithmatex">\(k\)</span><span class="heti-spacing"> </span></span>越小，收敛速度越快</li>
</ul>
<p><strong>不动点迭代的实现</strong></p>
<p>给定一个初始近似值<span><span class="heti-spacing"> </span><span class="arithmatex">\(p_0\)</span></span>，找到<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(p = g(p)\)</span><span class="heti-spacing"> </span></span>的一个解。</p>
<ul>
<li>输入：初始近似值<span><span class="heti-spacing"> </span><span class="arithmatex">\(p_0\)</span></span>；容忍值<span><span class="heti-spacing"> </span><span class="arithmatex">\(TOL\)</span></span>；最大迭代次数<span><span class="heti-spacing"> </span><span class="arithmatex">\(N_{max}\)</span></span></li>
<li>输出：近似解<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(p\)</span><span class="heti-spacing"> </span></span>或错误信息</li>
</ul>
<div class="language-cpp highlight"><pre><span></span><code><span id="__span-1-1"><a href="#__codelineno-1-1" id="__codelineno-1-1" name="__codelineno-1-1"></a><span class="n">Step</span><span class="w"> </span><span class="mi">1</span><span class="w">  </span><span class="n">Set</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
</span><span id="__span-1-2"><a href="#__codelineno-1-2" id="__codelineno-1-2" name="__codelineno-1-2"></a><span class="n">Step</span><span class="w"> </span><span class="mi">2</span><span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">N_max</span><span class="p">)</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="n">steps</span><span class="w"> </span><span class="mi">3-6</span>
</span><span id="__span-1-3"><a href="#__codelineno-1-3" id="__codelineno-1-3" name="__codelineno-1-3"></a><span class="w">        </span><span class="n">Step</span><span class="w"> </span><span class="mi">3</span><span class="w">  </span><span class="n">Set</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g</span><span class="p">(</span><span class="n">p_0</span><span class="p">);</span><span class="w">  </span><span class="c1">// compute p_i</span>
</span><span id="__span-1-4"><a href="#__codelineno-1-4" id="__codelineno-1-4" name="__codelineno-1-4"></a><span class="w">        </span><span class="n">Step</span><span class="w"> </span><span class="mi">4</span><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="o">|</span><span class="n">p</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">p_0</span><span class="o">|</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">TOL</span><span class="w"> </span><span class="n">then</span><span class="w"> </span><span class="n">Output</span><span class="p">(</span><span class="n">p</span><span class="p">);</span><span class="w">  </span><span class="c1">// successful</span>
</span><span id="__span-1-5"><a href="#__codelineno-1-5" id="__codelineno-1-5" name="__codelineno-1-5"></a><span class="w">            </span><span class="n">STOP</span><span class="p">;</span>
</span><span id="__span-1-6"><a href="#__codelineno-1-6" id="__codelineno-1-6" name="__codelineno-1-6"></a><span class="w">        </span><span class="n">Step</span><span class="w"> </span><span class="mi">5</span><span class="w">  </span><span class="n">Set</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">;</span>
</span><span id="__span-1-7"><a href="#__codelineno-1-7" id="__codelineno-1-7" name="__codelineno-1-7"></a><span class="w">        </span><span class="n">Step</span><span class="w"> </span><span class="mi">6</span><span class="w">  </span><span class="n">Set</span><span class="w"> </span><span class="n">p_0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">;</span><span class="w">  </span><span class="c1">// update p_0</span>
</span><span id="__span-1-8"><a href="#__codelineno-1-8" id="__codelineno-1-8" name="__codelineno-1-8"></a><span class="n">Step</span><span class="w"> </span><span class="mi">7</span><span class="w">  </span><span class="n">Output</span><span class="p">(</span><span class="n">The</span><span class="w"> </span><span class="n">method</span><span class="w"> </span><span class="n">failed</span><span class="w"> </span><span class="n">after</span><span class="w"> </span><span class="n">N_max</span><span class="w"> </span><span class="n">iterations</span><span class="p">);</span><span class="w">  </span><span class="c1">// unsuccessful</span>
</span></code></pre></div>
<p><strong>例题</strong></p>
<p>题目</p>
<div style="text-align: center">
<img src="images/C2/7.png" width="80%/"/>
</div>
<p>解答</p>
<p>如果无脑迭代的话，会得到以下结果：</p>
<div style="text-align: center">
<img src="images/C2/8.png" width="80%/"/>
</div>
<p>可以看到<span class="heti-skip"><span class="heti-spacing"> </span>a<span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span>b<span class="heti-spacing"> </span></span>不太行，<span>c, d, e<span class="heti-spacing"> </span></span>都可以迭代下去。不行的原因分别是一个不收敛，另一个出现对负数开根号的情况。但即使是<span class="heti-skip"><span class="heti-spacing"> </span>OK<span class="heti-spacing"> </span></span>的那几个，也有一些小小的差别：</p>
<ul>
<li><span>c.<span class="heti-spacing"> </span></span>在区间<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\([1, 1.5]\)</span><span class="heti-spacing"> </span></span>时，<span class="arithmatex">\(k \approx 0.66\)</span>，也就是说该方程收敛较慢</li>
<li>d. <span class="arithmatex">\(k \approx 0.15\)</span>，收敛速度中等</li>
<li><span>e. <span class="arithmatex">\(k\)</span><span class="heti-spacing"> </span></span>更小，收敛很快（实际上它就是下面要介绍的<a href="#newtons-method">牛顿法</a>）</li>
</ul>
<h2 id="newtons-method">Newton's Method<a class="headerlink" href="#newtons-method" title="Permanent link">⚓︎</a></h2>
<p>最后要介绍的求根方法是<strong>牛顿法</strong>(Newton's method)，它的基本思想是使用<a href="https://en.wikipedia.org/wiki/Taylor_series"><strong>泰勒展开式</strong></a><span>(Taylor's expansion)<span class="heti-spacing"> </span></span>来线性化一个非线性的函数。</p>
<p>具体来说，令<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(p_0 \in [a, b]\)</span><span class="heti-spacing"> </span></span>为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(p\)</span><span class="heti-spacing"> </span></span>的一个近似值，满足<span><span class="heti-spacing"> </span><span class="arithmatex">\(f'(p) \ne 0\)</span></span>。考虑以下<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f(x)\)</span><span class="heti-spacing"> </span></span>关于<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(p_0\)</span><span class="heti-spacing"> </span></span>的泰勒多项式：</p>
<div class="arithmatex">\[
f(x) = f(p_0) + f'(p_0)(x - p_0) + \dfrac{f''(\xi_x)}{2!} (x - p_0)^2 \quad \text{where } \xi_x \text{ lies between } p_0 \text{ and } x
\]</div>
<p>假设<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(|p - p_0|\)</span><span class="heti-spacing"> </span></span>很小，那么<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\((p - p_0)^2\)</span><span class="heti-spacing"> </span></span>会更小，那么：</p>
<div class="arithmatex">\[
0  = f(p) \approx f(p_0) + f'(p_0) (p - p_0) \Rightarrow p \approx p_0 - \dfrac{f(p_0)}{f'(p_0)}
\]</div>
<p><strong>动画演示</strong></p>
<p>Step 1：</p>
<p>先取一个近似值<span><span class="heti-spacing"> </span><span class="arithmatex">\(p_0\)</span></span>。</p>
<div style="text-align: center">
<img src="images/C2/9.png" width="40%/"/>
</div>
<div class="language-text highlight"><pre><span></span><code>
</code></pre></div>
<p>求该位置下的导数，然后在对应点上做一条切线，该切线与<span class="heti-skip"><span class="heti-spacing"> </span>x<span class="heti-spacing"> </span></span>轴的交点即为下一个近似值，该近似值更加接近于真实值。</p>
<div style="text-align: center">
<img src="images/C2/10.png" width="40%/"/>
</div>
<p>Step 2：</p>
<div style="text-align: center">
<img src="images/C2/11.png" width="40%/"/>
</div>
<p>从新的近似值出发，求该位置下的导数，然后在对应点上做一条切线，该切线与<span class="heti-skip"><span class="heti-spacing"> </span>x<span class="heti-spacing"> </span></span>轴的交点即为下一个近似值，该近似值更加接近于真实值。</p>
<p>Step X：</p>
<p>重复上述过程，直至逼近真正的解<span><span class="heti-spacing"> </span><span class="arithmatex">\(p\)</span></span>。</p>
<p>将这些过程压缩在一张图中：</p>
<div style="text-align: center">
<img src="images/C2/11.png" width="40%/"/>
</div>
<p>从上述过程中，我们不难得到以下递推关系式：</p>
<div class="arithmatex">\[
p_n = p_{n-1} - \dfrac{f(p_{n-1})}{f'(p_{n-1})} \quad \text{for } n \ge 1
\]</div>
<p><strong>定理</strong> ：令<span><span class="heti-spacing"> </span><span class="arithmatex">\(f \in C^2[a, b]\)</span></span>（即函数具有二阶连续导数<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>。如果<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(p \in [a, b]\)</span><span class="heti-spacing"> </span></span>满足<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f(p) = 0\)</span><span class="heti-spacing"> </span></span>且<span><span class="heti-spacing"> </span><span class="arithmatex">\(f'(p) \ne 0\)</span></span>，那么存在一个<span><span class="heti-spacing"> </span><span class="arithmatex">\(\delta &gt; 0\)</span></span>，使得牛顿法产生一个序列<span><span class="heti-spacing"> </span><span class="arithmatex">\(\{p_n\} (n = 1, 2, \dots)\)</span></span>，对任意近似值<span><span class="heti-spacing"> </span><span class="arithmatex">\(p_0 \in [p - \delta, p + \delta]\)</span></span>，该序列收敛于<span><span class="heti-spacing"> </span><span class="arithmatex">\(p\)</span></span>。</p>
<p><strong>牛顿法的实现</strong></p>
<p>给定一个初始近似值<span><span class="heti-spacing"> </span><span class="arithmatex">\(p_0\)</span></span>，找到<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f(x) = 0\)</span><span class="heti-spacing"> </span></span>的一个解。</p>
<ul>
<li>输入：初始近似值<span><span class="heti-spacing"> </span><span class="arithmatex">\(p_0\)</span></span>；容忍值<span><span class="heti-spacing"> </span><span class="arithmatex">\(TOL\)</span></span>；最大迭代次数<span><span class="heti-spacing"> </span><span class="arithmatex">\(N_{max}\)</span></span></li>
<li>输出：近似解<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(p\)</span><span class="heti-spacing"> </span></span>或错误信息</li>
</ul>
<div class="language-cpp highlight"><pre><span></span><code><span id="__span-2-1"><a href="#__codelineno-2-1" id="__codelineno-2-1" name="__codelineno-2-1"></a><span class="n">Step</span><span class="w"> </span><span class="mi">1</span><span class="w">  </span><span class="n">Set</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
</span><span id="__span-2-2"><a href="#__codelineno-2-2" id="__codelineno-2-2" name="__codelineno-2-2"></a><span class="n">Step</span><span class="w"> </span><span class="mi">2</span><span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">N_max</span><span class="p">)</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="n">steps</span><span class="w"> </span><span class="mi">3-6</span>
</span><span id="__span-2-3"><a href="#__codelineno-2-3" id="__codelineno-2-3" name="__codelineno-2-3"></a><span class="hll"><span class="w">        </span><span class="n">Step</span><span class="w"> </span><span class="mi">3</span><span class="w">  </span><span class="n">Set</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p_0</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">p_0</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">f</span><span class="err">'</span><span class="p">(</span><span class="n">p_0</span><span class="p">);</span><span class="w">  </span><span class="c1">// compute p_i</span>
</span></span><span id="__span-2-4"><a href="#__codelineno-2-4" id="__codelineno-2-4" name="__codelineno-2-4"></a><span class="w">        </span><span class="n">Step</span><span class="w"> </span><span class="mi">4</span><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="o">|</span><span class="n">p</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">p_0</span><span class="o">|</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">TOL</span><span class="w"> </span><span class="n">then</span><span class="w"> </span><span class="n">Output</span><span class="p">(</span><span class="n">p</span><span class="p">);</span><span class="w">  </span><span class="c1">// successful</span>
</span><span id="__span-2-5"><a href="#__codelineno-2-5" id="__codelineno-2-5" name="__codelineno-2-5"></a><span class="w">            </span><span class="n">STOP</span><span class="p">;</span>
</span><span id="__span-2-6"><a href="#__codelineno-2-6" id="__codelineno-2-6" name="__codelineno-2-6"></a><span class="w">        </span><span class="n">Step</span><span class="w"> </span><span class="mi">5</span><span class="w">  </span><span class="n">Set</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">;</span>
</span><span id="__span-2-7"><a href="#__codelineno-2-7" id="__codelineno-2-7" name="__codelineno-2-7"></a><span class="w">        </span><span class="n">Step</span><span class="w"> </span><span class="mi">6</span><span class="w">  </span><span class="n">Set</span><span class="w"> </span><span class="n">p_0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">;</span><span class="w">  </span><span class="c1">// update p_0</span>
</span><span id="__span-2-8"><a href="#__codelineno-2-8" id="__codelineno-2-8" name="__codelineno-2-8"></a><span class="n">Step</span><span class="w"> </span><span class="mi">7</span><span class="w">  </span><span class="n">Output</span><span class="p">(</span><span class="n">The</span><span class="w"> </span><span class="n">method</span><span class="w"> </span><span class="n">failed</span><span class="w"> </span><span class="n">after</span><span class="w"> </span><span class="n">N_max</span><span class="w"> </span><span class="n">iterations</span><span class="p">);</span><span class="w">  </span><span class="c1">// unsuccessful</span>
</span></code></pre></div>
<blockquote>
<p>相比不动点迭代的实现，只有高亮行发生了变化。</p>
</blockquote>
<p><strong>注意</strong> ：牛顿法的收敛性取决于初始近似值的选择。如下图所示，如果选择不当的话，牛顿法就会失效：</p>
<div style="text-align: center">
<img src="images/C2/12.png" width="80%/"/>
</div>
<h2 id="error-analysis-for-iterative-methods">Error Analysis for Iterative Methods<a class="headerlink" href="#error-analysis-for-iterative-methods" title="Permanent link">⚓︎</a></h2>
<p><strong>定义</strong></p>
<p>假设<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\{p_n\} (n = 0, 1, 2, \dots)\)</span><span class="heti-spacing"> </span></span>是一个收敛到<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(p\)</span><span class="heti-spacing"> </span></span>的序列，且<span><span class="heti-spacing"> </span><span class="arithmatex">\(\forall n, p_n \ne p\)</span></span>。若存在正常数<span><span class="heti-spacing"> </span><span class="arithmatex">\(\alpha, \lambda\)</span></span>，使得：</p>
<div class="arithmatex">\[
\lim\limits_{n \rightarrow \infty} \dfrac{|p_{n+1} - p|}{|p_n - p|^\alpha} = \lambda
\]</div>
<p>成立，那么<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\{p_n\} (n = 0, 1, 2, \dots)\)</span><span class="heti-spacing"> </span></span>以阶数<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\alpha\)</span><span class="heti-spacing"> </span></span>收敛到<span><span class="heti-spacing"> </span><span class="arithmatex">\(p\)</span></span>，且渐进误差常量为<span><span class="heti-spacing"> </span><span class="arithmatex">\(\lambda\)</span></span>。</p>
<ul>
<li>若<span><span class="heti-spacing"> </span><span class="arithmatex">\(\alpha = 1\)</span></span>，那么序列是<strong>线性</strong><span>(linearly)<span class="heti-spacing"> </span></span>收敛的</li>
<li>若<span><span class="heti-spacing"> </span><span class="arithmatex">\(\alpha = 2\)</span></span>，那么序列是<strong>二次</strong><span>(quadratically)<span class="heti-spacing"> </span></span>收敛的</li>
</ul>
<p>所以，<span><span class="arithmatex">\(\alpha\)</span><span class="heti-spacing"> </span></span>越大，收敛速度越快。</p>
<blockquote>
<p>注意：阶数<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\alpha\)</span><span class="heti-spacing"> </span></span>可以不是整数。</p>
</blockquote>
<p><strong>思考</strong></p>
<p>问题：对于<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(g'(p) \ne 0\)</span><span class="heti-spacing"> </span></span>的迭代法，收敛的阶数是多少？</p>
<p>解答：</p>
<div class="arithmatex">\[
\lim\limits_{n \rightarrow \infty} \dfrac{|p_{n+1} - p|}{|p_n - p|^\alpha} = \lim\limits_{n \rightarrow \infty} \dfrac{g'(\xi_n)|p_n - p|}{|p_n - p|^\alpha} = |g'(p)|
\]</div>
<p>因此是线性收敛的。</p>
<p><strong>讨论</strong></p>
<p>问题：牛顿法的收敛阶数是多少（此时<span><span class="heti-spacing"> </span><span class="arithmatex">\(g'(p) = 0\)</span></span><heti-adjacent class="heti-adjacent-half">）</heti-adjacent>？</p>
<p>解答：</p>
<p>通过泰勒展开式可以得到：</p>
<div class="arithmatex">\[
\begin{align}
0 = f(p) &amp; = f(p_n) + f'(p_n)(p - p_n) + \dfrac{f''(\xi_n)}{2!} (p - p_n)^2 \notag \\
\Rightarrow p &amp; = \underbrace{p_n - \dfrac{f(p_n)}{f'(p_n)}}_{p_{n+1}} - \dfrac{f''(\xi_n)}{2! f'(p_n)}(p - p_n)^2 \Rightarrow \dfrac{|p_{n+1} - p|}{|p_n - p|^2} = \dfrac{f''(\xi_n)}{2f'(p_n)} \notag
\end{align}
\]</div>
<p>只要<span><span class="heti-spacing"> </span><span class="arithmatex">\(f'(p) \ne 0\)</span></span>（在一个简单根附近<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，那么牛顿法至少是<strong>二次收敛</strong>的。</p>
<p><strong>定理</strong> ：令<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(p\)</span><span class="heti-spacing"> </span></span>是<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(g(x)\)</span><span class="heti-spacing"> </span></span>的不动点。如果存在一些常量<span><span class="heti-spacing"> </span><span class="arithmatex">\(\alpha \ge 2\)</span></span>，使得<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(g \in C^\alpha [p - \delta, p + \delta], \textcolor{red}{g'(p) = \dots = g^{(\alpha - 1)}(p) = 0}\)</span><span class="heti-spacing"> </span></span>且<span><span class="heti-spacing"> </span><span class="arithmatex">\(\textcolor{red}{g^{(\alpha)}(p) \ne 0}\)</span></span>。那么关于<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(p_n = g(p_{n-1}), n \ge 1\)</span><span class="heti-spacing"> </span></span>的迭代是<span style="text-color: red"><span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\alpha\)</span><span class="heti-spacing"> </span></span>阶</span>收敛的。</p>
<p><strong>讨论</strong></p>
<p>题目：如果根<strong>不是</strong>简单的<span><span class="heti-spacing"> </span>(simple)</span>（即有<strong>重根</strong>(multiple roots)<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，那么牛顿法的收敛阶数是多少？</p>
<p>答案：</p>
<p>如果<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(p\)</span><span class="heti-spacing"> </span></span>是<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f\)</span><span class="heti-spacing"> </span></span>中的一个根，且重数<span class="heti-skip"><span class="heti-spacing"> </span>(multiplicity)<span class="heti-spacing"> </span></span>为<span><span class="heti-spacing"> </span><span class="arithmatex">\(m\)</span></span>，那么<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f(x) = (x - p)^m q(x)\)</span><span class="heti-spacing"> </span></span>且<span><span class="heti-spacing"> </span><span class="arithmatex">\(q(p) \ne 0\)</span></span>。</p>
<p>根据牛顿法：<span class="arithmatex">\(p_n = g(p_{n-1}) \text{ for } n \ge 1 \text{ with } g(x) = x - \dfrac{f(x)}{f'(x)}\)</span>，得到：</p>
<div class="arithmatex">\[
g'(p) = \Big|1 - \dfrac{f'(p)^2 - f(p)f''(p)}{f'(p)^2}\Big| = 1 - \dfrac{1}{m} &lt; 1
\]</div>
<p>所以此时牛顿法收敛，但不是二次收敛。</p>
<hr/>
<p>幸运的是，存在一种可以加快收敛速度的方法：将有重根的<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f\)</span><span class="heti-spacing"> </span></span>转换为等价的另一个有<strong>简单根</strong>的函数，在这个新的函数上使用牛顿法。具体来说：</p>
<ul>
<li>
<p>令<span><span class="heti-spacing"> </span><span class="arithmatex">\(\mu(x) = \dfrac{f(x)}{f'(x)}\)</span></span>，那么<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f\)</span><span class="heti-spacing"> </span></span>的重根<span class="heti-skip"><span class="heti-spacing"> </span>= <span class="arithmatex">\(\mu\)</span><span class="heti-spacing"> </span></span>的简单根</p>
</li>
<li>
<p>在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\mu\)</span><span class="heti-spacing"> </span></span>上应用牛顿法：</p>
</li>
</ul>
<p>$$
  g(x) = x - \dfrac{\mu(x)}{\mu'(x)} = x - \dfrac{f(x)f'(x)}{[f'(x)]^2 - f(x)f''(x)}
  $$</p>
<p><strong>对上述方法的评价</strong></p>
<ul>
<li>优点：二次收敛</li>
<li>缺点：<ul>
<li>需要额外计算<span><span class="heti-spacing"> </span><span class="arithmatex">\(f''(x)\)</span></span></li>
<li>分母是两个都接近于<span class="heti-skip"><span class="heti-spacing"> </span>0<span class="heti-spacing"> </span></span>的数的差</li>
</ul>
</li>
</ul>
<h2 id="accelerating-convergence">Accelerating Convergence<a class="headerlink" href="#accelerating-convergence" title="Permanent link">⚓︎</a></h2>
<h3 id="aitkens-delta2-method">Aitken's <span class="arithmatex">\(\Delta^2\)</span> Method<a class="headerlink" href="#aitkens-delta2-method" title="Permanent link">⚓︎</a></h3>
<p><strong>定义（作为背景知识）</strong> ：对于给定的序列<span><span class="heti-spacing"> </span><span class="arithmatex">\(\{p_n\} (n = 1, 2, \dots)\)</span></span>，<strong>前向差</strong>(forward difference) <span class="arithmatex">\(\Delta p_n = p_{n+1} - p_n (n \ge 0)\)</span>。更高次的幂<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\Delta^k p_n\)</span><span class="heti-spacing"> </span></span>可以被递归定义为<span><span class="heti-spacing"> </span><span class="arithmatex">\(\Delta^k p_n = \Delta (\Delta^{k-1} p_n) (k \ge 2)\)</span></span></p>
<p>虽然二次收敛效果很好，但并不是所有方法都能二次收敛——我们还得关注那些<strong>线性收敛</strong>的方法。因此下面将介绍一些能够加速线性收敛的技术。我们先来认识第一种方法：<strong><span>Aitken's <span class="arithmatex">\(\Delta^2\)</span><span class="heti-spacing"> </span></span>方法</strong>。</p>
<p><strong>推导过程</strong></p>
<p>假设<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\{p_n\}_{n=0}^\infty\)</span><span class="heti-spacing"> </span></span>是线性收敛的序列，且极限为<span><span class="heti-spacing"> </span><span class="arithmatex">\(p\)</span></span>。为了构造一个收敛至<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(p\)</span><span class="heti-spacing"> </span></span>更快的序列<span><span class="heti-spacing"> </span><span class="arithmatex">\(\{\hat{p_n}\}\)</span></span>，我们先假设<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(p_n - p, p_{n+1} - p, p_{n+2} - p\)</span><span class="heti-spacing"> </span></span>的结果符号一致，且<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n\)</span><span class="heti-spacing"> </span></span>足够大，使得 </p>
<div class="arithmatex">\[
\dfrac{p_{n+1} - p}{p_n - p} \approx \dfrac{p_{n+2} - p}{p_{n+1} - p}
\]</div>
<p>成立。那么通过一系列的转化，可以得到：</p>
<div class="arithmatex">\[
p \approx \dfrac{p_{n+2}p_n - p_{n+1}^2}{p_{n+2} - 2p_{n+1} + p_n}
\]</div>
<p>再次转化，得到：<span class="arithmatex">\(p \approx p_n - \dfrac{(p_{n+1} - p_n)^2}{p_{n+2} - 2p_{n+1} + p_n}\)</span></p>
<blockquote>
<p>这里用到了<a href="#fixed-point-iteration">不动点迭代</a>的知识。</p>
</blockquote>
<p>利用前面介绍的前向差概念，替换上述等式中的记号，最终得到以下公式，即为<span class="heti-skip"><span class="heti-spacing"> </span>Atiken's <span class="arithmatex">\(\Delta^2\)</span><span class="heti-spacing"> </span></span>方法所得到的加速收敛序列的递推公式：</p>
<div class="arithmatex">\[
\hat{p}_n = \{\Delta^2\}(p_n) = p_n - \dfrac{(\Delta p_n)^2}{\Delta^2 p_n} (n \ge 0)
\]</div>
<p><span>Aitken's <span class="arithmatex">\(\Delta^2\)</span><span class="heti-spacing"> </span></span>方法的思想在于：用多项低阶去产生高阶精度，从而避免多次迭代。</p>
<p><strong>定理</strong> ：假设序列<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\{p_n\} (n = 1, 2, \dots)\)</span><span class="heti-spacing"> </span></span>线性收敛到极限<span><span class="heti-spacing"> </span><span class="arithmatex">\(p\)</span></span>；且对于所有充分大的数<span><span class="heti-spacing"> </span><span class="arithmatex">\(n\)</span></span>，有<span><span class="heti-spacing"> </span><span class="arithmatex">\((p_n - p)(p_{n+1} - p) &gt; 0\)</span></span>。那么序列<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\{\hat{p}_n\} (n = 1, 2, \dots)\)</span><span class="heti-spacing"> </span></span>收敛到<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(p\)</span><span class="heti-spacing"> </span></span>的速度快于<span><span class="heti-spacing"> </span><span class="arithmatex">\(\{p_n\} (n = 1, 2, \dots)\)</span></span>，即：</p>
<div class="arithmatex">\[
\lim\limits_{n \rightarrow \infty} \dfrac{\hat{p}_n - p}{p_n - p} = 0
\]</div>
<h3 id="steffensens-method">Steffensen's Method<a class="headerlink" href="#steffensens-method" title="Permanent link">⚓︎</a></h3>
<p>在<span class="heti-skip"><span class="heti-spacing"> </span>Aitken's <span class="arithmatex">\(\Delta^2\)</span><span class="heti-spacing"> </span></span>方法的基础上稍作修改，我们就能得到用于加速<strong>二次收敛</strong>的技术——<strong><span>Steffensen<span class="heti-spacing"> </span></span>方法</strong>。用这种方法构造出来的序列如下所示：</p>
<div class="arithmatex">\[
\begin{align}
p_0^{(0)}, p_1^{(0)} = g(p_0^{(0)}), p_2^{(0)} = g(p_2^{(0)})  \notag \\
p_0^{(1)} = \{\Delta^2\}(p_0^{(0)}), p_1^{(1)} = \{\Delta^2\}(p_0^{(1)}) , p_2^{(1)} = \{\Delta^2\}(p_1^{(1)})\notag \\
p_0^{(2)} = \{\Delta^2\}(p_0^{(1)}), \dots \notag
\end{align}
\]</div>
<p><strong>注意</strong> ：该方法的使用前提是<span><span class="heti-spacing"> </span><span class="arithmatex">\(g'(p) \ne 1\)</span></span>。</p>
<p><strong>算法：<span>Steffensen<span class="heti-spacing"> </span></span>加速</strong></p>
<p>对于给定初始值<span><span class="heti-spacing"> </span><span class="arithmatex">\(p_0\)</span></span>，寻找<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(x = g(x)\)</span><span class="heti-spacing"> </span></span>的解。</p>
<ul>
<li>输入：初始近似值<span><span class="heti-spacing"> </span><span class="arithmatex">\(p_0\)</span></span>；容忍值<span><span class="heti-spacing"> </span><span class="arithmatex">\(TOL\)</span></span>；最大迭代次数<span><span class="heti-spacing"> </span><span class="arithmatex">\(N_{max}\)</span></span></li>
<li>输出：近似解<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(x\)</span><span class="heti-spacing"> </span></span>或失败信息</li>
</ul>
<div class="language-cpp highlight"><pre><span></span><code><span id="__span-3-1"><a href="#__codelineno-3-1" id="__codelineno-3-1" name="__codelineno-3-1"></a><span class="n">Step</span><span class="w"> </span><span class="mi">1</span><span class="w">  </span><span class="n">Set</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
</span><span id="__span-3-2"><a href="#__codelineno-3-2" id="__codelineno-3-2" name="__codelineno-3-2"></a><span class="n">Step</span><span class="w"> </span><span class="mi">2</span><span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">N_max</span><span class="p">)</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="n">steps</span><span class="w"> </span><span class="mi">3-6</span>
</span><span id="__span-3-3"><a href="#__codelineno-3-3" id="__codelineno-3-3" name="__codelineno-3-3"></a><span class="w">        </span><span class="n">Step</span><span class="w"> </span><span class="mi">3</span><span class="w">  </span><span class="n">Set</span><span class="w"> </span><span class="n">p_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g</span><span class="p">(</span><span class="n">p_0</span><span class="p">);</span>
</span><span id="__span-3-4"><a href="#__codelineno-3-4" id="__codelineno-3-4" name="__codelineno-3-4"></a><span class="w">                    </span><span class="n">p_2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">g</span><span class="p">(</span><span class="n">p_1</span><span class="p">);</span>
</span><span id="__span-3-5"><a href="#__codelineno-3-5" id="__codelineno-3-5" name="__codelineno-3-5"></a><span class="w">                    </span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p_0</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="n">p_1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">p_0</span><span class="p">)</span><span class="o">^</span><span class="mi">2</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">p_2</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">p_1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">p_0</span><span class="p">);</span>
</span><span id="__span-3-6"><a href="#__codelineno-3-6" id="__codelineno-3-6" name="__codelineno-3-6"></a><span class="w">        </span><span class="n">Step</span><span class="w"> </span><span class="mi">4</span><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="o">|</span><span class="n">p</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">p_0</span><span class="o">|</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">TOL</span><span class="w"> </span><span class="n">then</span><span class="w"> </span><span class="n">Output</span><span class="p">(</span><span class="n">p</span><span class="p">);</span><span class="w">  </span><span class="c1">// successful</span>
</span><span id="__span-3-7"><a href="#__codelineno-3-7" id="__codelineno-3-7" name="__codelineno-3-7"></a><span class="w">            </span><span class="n">STOP</span><span class="p">;</span>
</span><span id="__span-3-8"><a href="#__codelineno-3-8" id="__codelineno-3-8" name="__codelineno-3-8"></a><span class="w">        </span><span class="n">Step</span><span class="w"> </span><span class="mi">5</span><span class="w">  </span><span class="n">Set</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">;</span>
</span><span id="__span-3-9"><a href="#__codelineno-3-9" id="__codelineno-3-9" name="__codelineno-3-9"></a><span class="w">        </span><span class="n">Step</span><span class="w"> </span><span class="mi">6</span><span class="w">  </span><span class="n">Set</span><span class="w"> </span><span class="n">p_0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p</span><span class="p">;</span><span class="w">  </span><span class="c1">// update p_0</span>
</span><span id="__span-3-10"><a href="#__codelineno-3-10" id="__codelineno-3-10" name="__codelineno-3-10"></a><span class="n">Step</span><span class="w"> </span><span class="mi">7</span><span class="w">  </span><span class="n">Output</span><span class="p">(</span><span class="n">The</span><span class="w"> </span><span class="n">method</span><span class="w"> </span><span class="n">failed</span><span class="w"> </span><span class="n">after</span><span class="w"> </span><span class="n">N_max</span><span class="w"> </span><span class="n">iterations</span><span class="p">);</span><span class="w">  </span><span class="c1">// unsuccessful</span>
</span></code></pre></div>
<h1 id="chap-6-direct-methods-for-solving-linear-systems">Chap 6: Direct Methods for Solving Linear Systems<a class="headerlink" href="#chap-6-direct-methods-for-solving-linear-systems" title="Permanent link">⚓︎</a></h1>
<p>目标：求解<span><span class="heti-spacing"> </span><span class="arithmatex">\(A \boldsymbol{x} = \boldsymbol{b}\)</span></span></p>
<p><strong>逆矩阵的求解</strong></p>
<p>个人比较喜欢<strong>高斯<span class="heti-skip"><span class="heti-spacing"> </span>-<span class="heti-spacing"> </span></span>约旦消元法</strong>(Gauss-Jordan elimination)（计算机也常用这种方法<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，其大致步骤如下：</p>
<ol>
<li>构造增广矩阵<span><span class="heti-spacing"> </span><span class="arithmatex">\([A | I]\)</span></span></li>
<li>对增广矩阵进行行初等变换（目标是将左侧的<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>变为单位矩阵<span><span class="heti-spacing"> </span><span class="arithmatex">\(I\)</span></span><heti-adjacent class="heti-adjacent-half">）</heti-adjacent>：<ul>
<li>交换两行。</li>
<li>将某一行乘以一个非零常数。</li>
<li>将某一行的一个倍数加到另一行。 </li>
</ul>
</li>
<li>检查结果：如果左侧成功变为<span><span class="heti-spacing"> </span><span class="arithmatex">\(I\)</span></span>，则右侧的矩阵就是<span><span class="heti-spacing"> </span><span class="arithmatex">\(A^{-1}\)</span></span>。如果左侧在变换过程中出现全零行（或列<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，则<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>不可逆。</li>
</ol>
<h2 id="linear-systems-for-equations">Linear Systems for Equations<a class="headerlink" href="#linear-systems-for-equations" title="Permanent link">⚓︎</a></h2>
<h3 id="gaussian-elimination">Gaussian Elimination<a class="headerlink" href="#gaussian-elimination" title="Permanent link">⚓︎</a></h3>
<p><strong>高斯消元法</strong><span>(Gaussian elimination)<span class="heti-spacing"> </span></span>的基本思路：</p>
<ul>
<li>首先将矩阵<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>归约成一个<strong>上三角</strong><span>(upper-triangular)<span class="heti-spacing"> </span></span>矩阵</li>
<li>然后通过<strong>回代</strong><span>(backward-substitution)<span class="heti-spacing"> </span></span>来求解未知量</li>
</ul>
<div style="text-align: center">
<img src="images/C6/1.png" width="30%/"/>
</div>
<p>先来看<strong>消元</strong><span>(elimination)<span class="heti-spacing"> </span></span>的实现：先令<span><span class="heti-spacing"> </span><span class="arithmatex">\(A^{(1)} = A = (a_{ij}^{(1)})_{n \times n}, \boldsymbol{b}^{(1)} = \boldsymbol{b} = \begin{bmatrix}b_1^{(1)} \\ \vdots \\ b_n^{(1)}\end{bmatrix}\)</span></span></p>
<ul>
<li>
<p>第<span class="heti-skip"><span class="heti-spacing"> </span>1<span class="heti-spacing"> </span></span>步：</p>
</li>
<li>
<p>如果<span><span class="heti-spacing"> </span><span class="arithmatex">\(a_{11}^{(1)} \ne 0\)</span></span>，计算<span><span class="heti-spacing"> </span><span class="arithmatex">\(m_{i1} = \dfrac{a_{i1}^{(1)}}{a_{11}^{(1)}}, (i = 2, \dots, n)\)</span></span></p>
</li>
<li>
<p>那么增广矩阵<span class="heti-skip"><span class="heti-spacing"> </span>(augmented matrix)<span class="heti-spacing"> </span></span>的第<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(i\)</span><span class="heti-spacing"> </span></span>行<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\text{row}_i\)</span><span class="heti-spacing"> </span></span>为：<span class="arithmatex">\(m_{i1} \times \text{row}_1\)</span>，得到</p>
<div class="arithmatex">\[
\left[
\begin{array}{cccc|c}
a_{11}^{(1)} &amp; a_{12}^{(1)} &amp; \cdots &amp; a_{1n}^{(1)} &amp; b_1^{(1)} \\
0 &amp; &amp; A^{(2)} &amp; &amp; \boldsymbol{b}^{(2)} \\
\end{array}
\right]
\]</div>
<p>其中<span><span class="heti-spacing"> </span><span class="arithmatex">\(\begin{cases}a_{ij}^{(2)} = a_{ij}^{(1)} - m_{i1} a_{1j}^{1} \\ b_i^{(2)} = b_i^{(1)} - m_{i1} b_1^{(1)}\end{cases}, (i, j = 2, \dots, n)\)</span></span></p>
</li>
<li>
<p>第<span class="heti-skip"><span class="heti-spacing"> </span>k<span class="heti-spacing"> </span></span>步：</p>
</li>
<li>
<p>如果<span><span class="heti-spacing"> </span><span class="arithmatex">\(a_{kk}^{(k)} \ne 0\)</span></span>，计算<span><span class="heti-spacing"> </span><span class="arithmatex">\(m_{ik} = \dfrac{a_{ik}^{(k)}}{a_{kk}^{(k)}}, (i = k+1, \dots, n)\)</span></span></p>
</li>
<li>
<p><span class="arithmatex">\(\begin{cases}a_{ij}^{(k+1)} = a_{ij}^{(k)} - m_{ik} a_{kj}^{k} \\ b_i^{(k+1)} = b_i^{(k)} - m_{ik} b_k^{(k)}\end{cases}, (i, j = k+1, \dots, n)\)</span></p>
</li>
<li>
<p><span>n-1<span class="heti-spacing"> </span></span>步后：</p>
</li>
</ul>
<p>$$
  \begin{bmatrix} a_{11}^{(1)} &amp; a_{12}^{(1)} &amp; \dots &amp; a_{1n}^{(1)} \ &amp; a_{22}^{(2)} &amp; \dots &amp; a_{2n}^{(2)} \ &amp; &amp; \dots &amp; \vdots \ &amp; &amp; &amp; a_{nn}^{(n)}\end{bmatrix} \begin{bmatrix}x_1 \ x_2 \ \vdots \ x_n\end{bmatrix} = \begin{bmatrix}b_1^{(1)} \ b_2^{(2)} \ \vdots \ b_n^{(n)}\end{bmatrix}
  $$</p>
<hr/>
<p>接下来看<strong>回代</strong>：</p>
<ul>
<li><span class="arithmatex">\(x_n = \dfrac{b_n^{(n)}}{a_{nn}^{(n)}}\)</span></li>
<li><span class="arithmatex">\(x_i = \dfrac{b_i^{(i)} - \sum\limits_{j=i+1}^n a_{ij}^{(i)} x_j}{a_{ii}^{(i)}}, (i = n - 1, \dots, 1)\)</span></li>
<li>我们必须找到最小的整数<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(k \ge i\)</span><span class="heti-spacing"> </span></span>且<span><span class="heti-spacing"> </span><span class="arithmatex">\(a_{ki}^{(i)} \ne 0\)</span></span>，然后交换第<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(k\)</span><span class="heti-spacing"> </span></span>行和第<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(i\)</span><span class="heti-spacing"> </span></span>行</li>
</ul>
<p><strong>代码实现</strong></p>
<p>求解<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n \times n\)</span><span class="heti-spacing"> </span></span>线性方程组：</p>
<div class="arithmatex">\[
\begin{align}
E_1: &amp; a_{11} x_1 + a_{12} x_2 + \dots + a_{1n} x_n = a_{1, n+1} \notag \\
E_2: &amp; a_{21} x_1 + a_{22} x_2 + \dots + a_{2n} x_n = a_{2, n+1} \notag \\
\vdots \quad &amp;  \quad \vdots \quad \quad \quad\ \vdots \quad \quad \quad \quad \quad \quad \vdots \quad \quad \quad \vdots \notag \\
E_n: &amp; a_{n1} x_1 + a_{n2} x_2 + \dots + a_{nn} x_n = a_{n, n+1} \notag \\
\end{align}
\]</div>
<ul>
<li>输入：未知量和方程的数量<span><span class="heti-spacing"> </span><span class="arithmatex">\(n\)</span></span>；增广矩阵<span><span class="heti-spacing"> </span><span class="arithmatex">\(A = (a_{ij})\)</span></span>，其中<span><span class="heti-spacing"> </span><span class="arithmatex">\(1 \le i \le n, 1 \le j \le n+1\)</span></span></li>
<li>输出：解<span><span class="heti-spacing"> </span><span class="arithmatex">\(x_1, x_2, \dots, x_n\)</span></span>，或者线性方程组没有唯一解的信息</li>
</ul>
<div class="language-cpp highlight"><pre><span></span><code><span id="__span-4-1"><a href="#__codelineno-4-1" id="__codelineno-4-1" name="__codelineno-4-1"></a><span class="n">Step</span><span class="w"> </span><span class="mi">1</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="n">Steps</span><span class="w"> </span><span class="mi">2-4</span><span class="o">:</span>
</span><span id="__span-4-2"><a href="#__codelineno-4-2" id="__codelineno-4-2" name="__codelineno-4-2"></a><span class="w">    </span><span class="n">Step</span><span class="w"> </span><span class="mi">2</span><span class="w">  </span><span class="n">Let</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">smallest</span><span class="w"> </span><span class="n">integer</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">p</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
</span><span id="__span-4-3"><a href="#__codelineno-4-3" id="__codelineno-4-3" name="__codelineno-4-3"></a><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">no</span><span class="w"> </span><span class="n">integer</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">can</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">found</span>
</span><span id="__span-4-4"><a href="#__codelineno-4-4" id="__codelineno-4-4" name="__codelineno-4-4"></a><span class="w">                </span><span class="n">then</span><span class="w"> </span><span class="n">Output</span><span class="p">(</span><span class="err">'</span><span class="n">no</span><span class="w"> </span><span class="n">unique</span><span class="w"> </span><span class="n">solution</span><span class="w"> </span><span class="n">exists</span><span class="err">'</span><span class="p">);</span>
</span><span id="__span-4-5"><a href="#__codelineno-4-5" id="__codelineno-4-5" name="__codelineno-4-5"></a><span class="w">                </span><span class="n">STOP</span><span class="p">;</span>
</span><span id="__span-4-6"><a href="#__codelineno-4-6" id="__codelineno-4-6" name="__codelineno-4-6"></a><span class="w">            </span><span class="c1">// row exchange</span>
</span><span id="__span-4-7"><a href="#__codelineno-4-7" id="__codelineno-4-7" name="__codelineno-4-7"></a><span class="w">    </span><span class="n">Step</span><span class="w"> </span><span class="mi">3</span><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="n">then</span><span class="w"> </span><span class="n">perform</span><span class="w"> </span><span class="p">(</span><span class="n">E</span><span class="p">[</span><span class="n">p</span><span class="p">])</span><span class="w"> </span><span class="o">&lt;-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span><span id="__span-4-8"><a href="#__codelineno-4-8" id="__codelineno-4-8" name="__codelineno-4-8"></a><span class="w">            </span><span class="c1">// elimination</span>
</span><span id="__span-4-9"><a href="#__codelineno-4-9" id="__codelineno-4-9" name="__codelineno-4-9"></a><span class="w">    </span><span class="n">Step</span><span class="w"> </span><span class="mi">4</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="n">Step</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="mi">6</span><span class="o">:</span>
</span><span id="__span-4-10"><a href="#__codelineno-4-10" id="__codelineno-4-10" name="__codelineno-4-10"></a><span class="w">        </span><span class="n">Step</span><span class="w"> </span><span class="mi">5</span><span class="w">  </span><span class="n">Set</span><span class="w"> </span><span class="n">m</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
</span><span id="__span-4-11"><a href="#__codelineno-4-11" id="__codelineno-4-11" name="__codelineno-4-11"></a><span class="w">        </span><span class="n">Step</span><span class="w"> </span><span class="mi">6</span><span class="w">  </span><span class="n">Perform</span><span class="w"> </span><span class="p">(</span><span class="n">E</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">m</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">E</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
</span><span id="__span-4-12"><a href="#__codelineno-4-12" id="__codelineno-4-12" name="__codelineno-4-12"></a><span class="w">    </span><span class="n">Step</span><span class="w"> </span><span class="mi">7</span><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">n</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">then</span><span class="w"> </span><span class="n">Output</span><span class="p">(</span><span class="err">'</span><span class="n">no</span><span class="w"> </span><span class="n">unique</span><span class="w"> </span><span class="n">solution</span><span class="w"> </span><span class="n">exists</span><span class="err">'</span><span class="p">);</span>
</span><span id="__span-4-13"><a href="#__codelineno-4-13" id="__codelineno-4-13" name="__codelineno-4-13"></a><span class="w">                </span><span class="n">STOP</span><span class="p">;</span>
</span><span id="__span-4-14"><a href="#__codelineno-4-14" id="__codelineno-4-14" name="__codelineno-4-14"></a><span class="w">            </span><span class="c1">// backward substitution</span>
</span><span id="__span-4-15"><a href="#__codelineno-4-15" id="__codelineno-4-15" name="__codelineno-4-15"></a><span class="w">    </span><span class="n">Step</span><span class="w"> </span><span class="mi">8</span><span class="w">  </span><span class="n">Set</span><span class="w"> </span><span class="n">x_n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">n</span><span class="p">]</span>
</span><span id="__span-4-16"><a href="#__codelineno-4-16" id="__codelineno-4-16" name="__codelineno-4-16"></a><span class="w">    </span><span class="n">Step</span><span class="w"> </span><span class="mi">9</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">set</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">sum</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">])]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">];</span>
</span><span id="__span-4-17"><a href="#__codelineno-4-17" id="__codelineno-4-17" name="__codelineno-4-17"></a><span class="w">    </span><span class="n">Step</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="n">Output</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="n">n</span><span class="p">]);</span>
</span><span id="__span-4-18"><a href="#__codelineno-4-18" id="__codelineno-4-18" name="__codelineno-4-18"></a><span class="w">            </span><span class="n">STOP</span><span class="p">;</span><span class="w">    </span><span class="c1">// success</span>
</span></code></pre></div>
<h3 id="amount-of-computation">Amount of Computation<a class="headerlink" href="#amount-of-computation" title="Permanent link">⚓︎</a></h3>
<p>现在我们来统计一下计算量（仅考虑乘法<span class="heti-skip"><span class="heti-spacing"> </span>/<span class="heti-spacing"> </span></span>除法<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>。</p>
<ul>
<li>消元：<span class="arithmatex">\(\sum\limits_{k=1}^{n-1} (n - k)(n - k + 2) = \dfrac{n^3}{3} + \dfrac{n^2}{2} - \dfrac{5}{6}n\)</span></li>
<li>回代：<span class="arithmatex">\(1 + \sum\limits_{i=1}^{n-1}(n - i + 1) = \dfrac{n^2}{2} + \dfrac{n}{2}\)</span></li>
</ul>
<p>所以对于很大的<span><span class="heti-spacing"> </span><span class="arithmatex">\(n\)</span></span>，乘法和除法的总数大约为<span><span class="heti-spacing"> </span><span class="arithmatex">\(\textcolor{red}{\dfrac{n^3}{3}}\)</span></span>。也就是说，高斯消元法的时间复杂度为 <strong><span class="arithmatex">\(O(n^3)\)</span></strong>。</p>
<h2 id="pivoting-strategies">Pivoting Strategies<a class="headerlink" href="#pivoting-strategies" title="Permanent link">⚓︎</a></h2>
<blockquote>
<p>除非有特殊说明，以下的<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(k\)</span><span class="heti-spacing"> </span></span>指的是第<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(k\)</span><span class="heti-spacing"> </span></span>次高斯消元。</p>
</blockquote>
<p><strong>一般高斯消元法的问题</strong></p>
<p>在高斯消元的过程中，如果其中一个<strong>主元</strong>(pivot) <span class="arithmatex">\(a_{kk}^{(k)} = 0\)</span>，那么就需要进行行交换<span><span class="heti-spacing"> </span><span class="arithmatex">\((E_k) \leftrightarrow (E_p)\)</span></span>，其中<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(p\)</span><span class="heti-spacing"> </span></span>是最小的满足<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(p &gt; k\)</span><span class="heti-spacing"> </span></span>且<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(a_{pk}^{(k)} \ne 0\)</span><span class="heti-spacing"> </span></span>的整数。但为了减小舍入误差，即使主元并不等于<span class="heti-skip"><span class="heti-spacing"> </span>0<span class="heti-spacing"> </span></span>的时候也要做行交换。</p>
<p>如果<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(a_{kk}^{(k)}\)</span><span class="heti-spacing"> </span></span>相比<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(a_{jk}^{(k)}\)</span><span class="heti-spacing"> </span></span>较小的话，那么乘数<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(m_{jk} = \dfrac{a_{jk}^{(k)}}{a_{kk}^{(k)}}\)</span><span class="heti-spacing"> </span></span>会大于<span><span class="heti-spacing"> </span>1</span>，导致误差的积累。并且在回代的时候，<span><span class="arithmatex">\(x_k\)</span><span class="heti-spacing"> </span></span>的值因为分母<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(a_{kk}^{(k)}\)</span><span class="heti-spacing"> </span></span>的值过小，其计算误差也会被放大。</p>
<p>所以，我们需要选取合适的主元以减小误差。下面给出一些选取主元的策略。</p>
<p><strong>置换矩阵</strong> ：找到合适的主元后，一般我们会做一个行交换。在后面涉及到<a href="#matrix-factorization">矩阵分解</a>的时候<heti-adjacent class="heti-adjacent-quarter">，</heti-adjacent>“行交换”这一操作就可以用一个<strong>置换矩阵</strong><span>(permutation matrix) <span class="arithmatex">\(P\)</span><span class="heti-spacing"> </span></span>来表示。它的元素基于<strong>单位矩阵</strong>(identity matrix) <span class="arithmatex">\(I\)</span>，在此基础上对里面的元素做行交换，便可表示对应的行交换操作。</p>
<p>比如<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(P_{12} = \begin{bmatrix}0 &amp; 1 &amp; 0 \\ 1 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 1\end{bmatrix}\)</span><span class="heti-spacing"> </span></span>表示交换第<span class="heti-skip"><span class="heti-spacing"> </span>1<span class="heti-spacing"> </span></span>行和第<span class="heti-skip"><span class="heti-spacing"> </span>2<span class="heti-spacing"> </span></span>行。如果<span><span class="heti-spacing"> </span><span class="arithmatex">\(\boldsymbol{x} = \begin{bmatrix}x_1 \\ x_2 \\ x_3\end{bmatrix}\)</span></span>，那么<span><span class="heti-spacing"> </span><span class="arithmatex">\(P_{12} \boldsymbol{x} = \begin{bmatrix}x_2 \\ x_1 \\ x_3\end{bmatrix}\)</span></span>。</p>
<h3 id="partial-pivoting">Partial Pivoting<a class="headerlink" href="#partial-pivoting" title="Permanent link">⚓︎</a></h3>
<p><strong>部分主元法</strong>(partial pivoting)（或称为最大列主元法<span><span class="heti-spacing"> </span>(maximal column pivoting)</span><heti-adjacent class="heti-adjacent-half">）</heti-adjacent>：找到最小的<span><span class="heti-spacing"> </span><span class="arithmatex">\(p\)</span></span>，使得<span><span class="heti-spacing"> </span><span class="arithmatex">\(|a_{pk}^{(k)}| = \max\limits_{k \le i \le n} |a_{ik}^{(k)}|\)</span></span>，然后交换第<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(p\)</span><span class="heti-spacing"> </span></span>行和第<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(k\)</span><span class="heti-spacing"> </span></span>行。</p>
<p><strong>代码实现</strong></p>
<p>求解<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n \times n\)</span><span class="heti-spacing"> </span></span>线性方程组：</p>
<div class="arithmatex">\[
\begin{align}
E_1: &amp; a_{11} x_1 + a_{12} x_2 + \dots + a_{1n} x_n = a_{1, n+1} \notag \\
E_2: &amp; a_{21} x_1 + a_{22} x_2 + \dots + a_{2n} x_n = a_{2, n+1} \notag \\
\vdots \quad &amp;  \quad \vdots \quad \quad \quad\ \vdots \quad \quad \quad \quad \quad \quad \vdots \quad \quad \quad \vdots \notag \\
E_n: &amp; a_{n1} x_1 + a_{n2} x_2 + \dots + a_{nn} x_n = a_{n, n+1} \notag \\
\end{align}
\]</div>
<ul>
<li>输入：未知量和方程的数量<span><span class="heti-spacing"> </span><span class="arithmatex">\(n\)</span></span>；增广矩阵<span><span class="heti-spacing"> </span><span class="arithmatex">\(A = (a_{ij})\)</span></span>，其中<span><span class="heti-spacing"> </span><span class="arithmatex">\(1 \le i \le n, 1 \le j \le n+1\)</span></span></li>
<li>输出：解<span><span class="heti-spacing"> </span><span class="arithmatex">\(x_1, x_2, \dots, x_n\)</span></span>，或者线性方程组没有唯一解的信息</li>
</ul>
<div class="language-cpp highlight"><pre><span></span><code><span id="__span-5-1"><a href="#__codelineno-5-1" id="__codelineno-5-1" name="__codelineno-5-1"></a><span class="n">Step</span><span class="w"> </span><span class="mi">1</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">set</span><span class="w"> </span><span class="n">NROW</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w">    </span><span class="c1">// initialize row pointer</span>
</span><span id="__span-5-2"><a href="#__codelineno-5-2" id="__codelineno-5-2" name="__codelineno-5-2"></a><span class="n">Step</span><span class="w"> </span><span class="mi">2</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="n">Steps</span><span class="w"> </span><span class="mi">3-6</span><span class="o">:</span><span class="w">    </span><span class="c1">// elimination process</span>
</span><span id="__span-5-3"><a href="#__codelineno-5-3" id="__codelineno-5-3" name="__codelineno-5-3"></a><span class="w">    </span><span class="n">Step</span><span class="w"> </span><span class="mi">3</span><span class="w">  </span><span class="n">Let</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">smallest</span><span class="w"> </span><span class="n">integer</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="k">and</span>
</span><span id="__span-5-4"><a href="#__codelineno-5-4" id="__codelineno-5-4" name="__codelineno-5-4"></a><span class="w">            </span><span class="o">|</span><span class="n">a</span><span class="p">(</span><span class="n">NROW</span><span class="p">(</span><span class="n">p</span><span class="p">),</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="o">|</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max_</span><span class="p">{</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="p">}</span><span class="o">|</span><span class="n">a</span><span class="p">(</span><span class="n">NROW</span><span class="p">(</span><span class="n">j</span><span class="p">),</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="o">|</span><span class="p">;</span>
</span><span id="__span-5-5"><a href="#__codelineno-5-5" id="__codelineno-5-5" name="__codelineno-5-5"></a><span class="w">    </span><span class="n">Step</span><span class="w"> </span><span class="mi">4</span><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="n">a</span><span class="p">(</span><span class="n">NROW</span><span class="p">(</span><span class="n">p</span><span class="p">),</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">then</span><span class="w"> </span><span class="n">Output</span><span class="p">(</span><span class="err">'</span><span class="n">no</span><span class="w"> </span><span class="n">unique</span><span class="w"> </span><span class="n">solution</span><span class="w"> </span><span class="n">exists</span><span class="err">'</span><span class="p">);</span>
</span><span id="__span-5-6"><a href="#__codelineno-5-6" id="__codelineno-5-6" name="__codelineno-5-6"></a><span class="w">                </span><span class="n">STOP</span><span class="p">;</span>
</span><span id="__span-5-7"><a href="#__codelineno-5-7" id="__codelineno-5-7" name="__codelineno-5-7"></a><span class="w">    </span><span class="n">Step</span><span class="w"> </span><span class="mi">5</span><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="n">NROW</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">NROW</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="n">then</span><span class="w"> </span><span class="n">set</span><span class="w"> </span><span class="n">NCOPY</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NROW</span><span class="p">(</span><span class="n">i</span><span class="p">);</span><span class="w">    </span><span class="c1">// simulated row interchange</span>
</span><span id="__span-5-8"><a href="#__codelineno-5-8" id="__codelineno-5-8" name="__codelineno-5-8"></a><span class="w">                                          </span><span class="n">NROW</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NROW</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
</span><span id="__span-5-9"><a href="#__codelineno-5-9" id="__codelineno-5-9" name="__codelineno-5-9"></a><span class="w">                                          </span><span class="n">NROW</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NCOPY</span><span class="p">;</span>
</span><span id="__span-5-10"><a href="#__codelineno-5-10" id="__codelineno-5-10" name="__codelineno-5-10"></a><span class="w">    </span><span class="n">Step</span><span class="w"> </span><span class="mi">6</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="n">Steps</span><span class="w"> </span><span class="mi">7-8</span><span class="o">:</span>
</span><span id="__span-5-11"><a href="#__codelineno-5-11" id="__codelineno-5-11" name="__codelineno-5-11"></a><span class="w">        </span><span class="n">Step</span><span class="w"> </span><span class="mi">7</span><span class="w">  </span><span class="n">Set</span><span class="w"> </span><span class="n">m</span><span class="p">(</span><span class="n">NROW</span><span class="p">(</span><span class="n">j</span><span class="p">),</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">(</span><span class="n">NROW</span><span class="p">(</span><span class="n">j</span><span class="p">),</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">a</span><span class="p">(</span><span class="n">NROW</span><span class="p">(</span><span class="n">i</span><span class="p">),</span><span class="w"> </span><span class="n">i</span><span class="p">);</span>
</span><span id="__span-5-12"><a href="#__codelineno-5-12" id="__codelineno-5-12" name="__codelineno-5-12"></a><span class="w">        </span><span class="n">Step</span><span class="w"> </span><span class="mi">8</span><span class="w">  </span><span class="n">Perform</span><span class="w"> </span><span class="p">(</span><span class="n">E_NROW</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">m</span><span class="p">(</span><span class="n">NROW</span><span class="p">(</span><span class="n">j</span><span class="p">),</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">E_NROW</span><span class="p">(</span><span class="n">i</span><span class="p">))</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">E_NROW</span><span class="p">(</span><span class="n">j</span><span class="p">));</span>
</span><span id="__span-5-13"><a href="#__codelineno-5-13" id="__codelineno-5-13" name="__codelineno-5-13"></a><span class="w">    </span><span class="n">Step</span><span class="w"> </span><span class="mi">9</span><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="n">a</span><span class="p">(</span><span class="n">NROW</span><span class="p">(</span><span class="n">n</span><span class="p">),</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">then</span><span class="w"> </span><span class="n">Output</span><span class="p">(</span><span class="err">'</span><span class="n">no</span><span class="w"> </span><span class="n">unique</span><span class="w"> </span><span class="n">solution</span><span class="w"> </span><span class="n">exists</span><span class="err">'</span><span class="p">);</span>
</span><span id="__span-5-14"><a href="#__codelineno-5-14" id="__codelineno-5-14" name="__codelineno-5-14"></a><span class="w">                </span><span class="n">STOP</span><span class="p">;</span>
</span><span id="__span-5-15"><a href="#__codelineno-5-15" id="__codelineno-5-15" name="__codelineno-5-15"></a><span class="w">    </span><span class="c1">// start backward substitution</span>
</span><span id="__span-5-16"><a href="#__codelineno-5-16" id="__codelineno-5-16" name="__codelineno-5-16"></a><span class="w">    </span><span class="n">Step</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="n">Set</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">(</span><span class="n">NROW</span><span class="p">(</span><span class="n">n</span><span class="p">),</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">a</span><span class="p">(</span><span class="n">NROW</span><span class="p">(</span><span class="n">n</span><span class="p">),</span><span class="w"> </span><span class="n">n</span><span class="p">);</span>
</span><span id="__span-5-17"><a href="#__codelineno-5-17" id="__codelineno-5-17" name="__codelineno-5-17"></a><span class="w">    </span><span class="n">Step</span><span class="w"> </span><span class="mi">11</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="mi">1</span>
</span><span id="__span-5-18"><a href="#__codelineno-5-18" id="__codelineno-5-18" name="__codelineno-5-18"></a><span class="w">                </span><span class="n">set</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">(</span><span class="n">NROW</span><span class="p">(</span><span class="n">i</span><span class="p">),</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">sum</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">(</span><span class="n">NROW</span><span class="p">(</span><span class="n">i</span><span class="p">),</span><span class="w"> </span><span class="n">j</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">a</span><span class="p">(</span><span class="n">NROW</span><span class="p">(</span><span class="n">i</span><span class="p">),</span><span class="w"> </span><span class="n">i</span><span class="p">);</span>
</span><span id="__span-5-19"><a href="#__codelineno-5-19" id="__codelineno-5-19" name="__codelineno-5-19"></a><span class="w">    </span><span class="n">Step</span><span class="w"> </span><span class="mi">12</span><span class="w"> </span><span class="n">Output</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="n">n</span><span class="p">]);</span><span class="w">    </span><span class="c1">// procedure completed successfully</span>
</span><span id="__span-5-20"><a href="#__codelineno-5-20" id="__codelineno-5-20" name="__codelineno-5-20"></a><span class="w">            </span><span class="n">STOP</span><span class="p">;</span>
</span></code></pre></div>
<p><strong>例子</strong></p>
<p>题目：求解线性方程组<span><span class="heti-spacing"> </span><span class="arithmatex">\(\begin{cases}30.00 x_1 + 594100 x_2 = 591700 \\ 5.291 x_1 - 6.130 x_2 = 46.78\end{cases}\)</span></span>，舍入精度为<span class="heti-skip"><span class="heti-spacing"> </span>4<span class="heti-spacing"> </span></span>位。</p>
<p>分析：可以看到，虽然根据部分主元法，解方程时无需交换行，然而注意到第一个方程中同一行的元素量级相差巨大，而第二行元素的量级比较接近，所以会产生较大的误差（这也反映了部分主元法的缺陷<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>。</p>
<h3 id="scaled-partial-pivoting">Scaled Partial Pivoting<a class="headerlink" href="#scaled-partial-pivoting" title="Permanent link">⚓︎</a></h3>
<p><strong>缩放部分主元法</strong>(scaled partial pivoting)（或称为缩放列主元法<span><span class="heti-spacing"> </span>(scaled-column pivoting)</span><heti-adjacent class="heti-adjacent-half">）</heti-adjacent>：将一行中最大的元素放在主元的位置上。</p>
<ul>
<li>第<span class="heti-skip"><span class="heti-spacing"> </span>1<span class="heti-spacing"> </span></span>步：定义每一行的<strong>缩放因子</strong>(scale factor) <span class="arithmatex">\(s_i = \max\limits_{1 \le j \le n} |a_{ij}|\)</span>（即每行中<strong>绝对值最大</strong>的元素）</li>
<li>第<span class="heti-skip"><span class="heti-spacing"> </span>2<span class="heti-spacing"> </span></span>步<heti-adjacent class="heti-adjacent-half">：</heti-adjacent>（对于第<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(k\)</span><span class="heti-spacing"> </span></span>次高斯消元<heti-adjacent class="heti-adjacent-half">，</heti-adjacent>）找到最小的<span><span class="heti-spacing"> </span><span class="arithmatex">\(p \ge k\)</span></span>，使得<span><span class="heti-spacing"> </span><span class="arithmatex">\(\dfrac{|a_{pk}^{(k)}|}{s_p} = \max\limits_{k \le i \le n} \dfrac{|a_{ik}^{(k)}|}{s_i}\)</span></span>，然后交换第<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(p\)</span><span class="heti-spacing"> </span></span>行和第<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(k\)</span><span class="heti-spacing"> </span></span>行</li>
</ul>
<p><strong>注</strong> ：缩放因子<strong>只计算一次</strong>（在高斯消元前<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，以确保计算效率。</p>
<p><strong>代码实现</strong></p>
<p>和部分主元法的实现相比，区别在于前<span class="heti-skip"><span class="heti-spacing"> </span>3<span class="heti-spacing"> </span></span>步，后续步骤都是一样的，因此下面只列出前<span class="heti-skip"><span class="heti-spacing"> </span>3<span class="heti-spacing"> </span></span>步：</p>
<div class="language-cpp highlight"><pre><span></span><code><span id="__span-6-1"><a href="#__codelineno-6-1" id="__codelineno-6-1" name="__codelineno-6-1"></a><span class="n">Step</span><span class="w"> </span><span class="mi">1</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">set</span><span class="w"> </span><span class="n">s_i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max_</span><span class="p">{</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="p">}(</span><span class="o">|</span><span class="n">a_ij</span><span class="o">|</span><span class="p">);</span>
</span><span id="__span-6-2"><a href="#__codelineno-6-2" id="__codelineno-6-2" name="__codelineno-6-2"></a><span class="w">                          </span><span class="k">if</span><span class="w"> </span><span class="n">s_i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">then</span><span class="w"> </span><span class="n">Output</span><span class="p">(</span><span class="err">'</span><span class="n">no</span><span class="w"> </span><span class="n">unique</span><span class="w"> </span><span class="n">solution</span><span class="w"> </span><span class="n">exists</span><span class="err">'</span><span class="p">);</span>
</span><span id="__span-6-3"><a href="#__codelineno-6-3" id="__codelineno-6-3" name="__codelineno-6-3"></a><span class="w">                                          </span><span class="n">STOP</span><span class="p">;</span>
</span><span id="__span-6-4"><a href="#__codelineno-6-4" id="__codelineno-6-4" name="__codelineno-6-4"></a><span class="n">Step</span><span class="w"> </span><span class="mi">2</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="n">Steps</span><span class="w"> </span><span class="mi">3-6</span><span class="o">:</span><span class="w">    </span><span class="c1">// elimination process</span>
</span><span id="__span-6-5"><a href="#__codelineno-6-5" id="__codelineno-6-5" name="__codelineno-6-5"></a><span class="w">    </span><span class="n">Step</span><span class="w"> </span><span class="mi">3</span><span class="w">  </span><span class="n">Let</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">smallest</span><span class="w"> </span><span class="n">integer</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="k">and</span>
</span><span id="__span-6-6"><a href="#__codelineno-6-6" id="__codelineno-6-6" name="__codelineno-6-6"></a><span class="w">            </span><span class="o">|</span><span class="n">a</span><span class="p">(</span><span class="n">NROW</span><span class="p">(</span><span class="n">p</span><span class="p">),</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="o">|</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">s</span><span class="p">(</span><span class="n">NROW</span><span class="p">(</span><span class="n">p</span><span class="p">))</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max_</span><span class="p">{</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="p">}(</span><span class="o">|</span><span class="n">a</span><span class="p">(</span><span class="n">NROW</span><span class="p">(</span><span class="n">j</span><span class="p">),</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="o">|</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">s</span><span class="p">(</span><span class="n">NROW</span><span class="p">(</span><span class="n">j</span><span class="p">)));</span>
</span></code></pre></div>
<p><strong>缩放部分主元法的好处在哪里？</strong></p>
<p>一般的部分主元法考虑的是<strong>绝对大小</strong>（当前列绝对值最大的元素<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，而缩放部分主元法考虑的是<strong>相对大小</strong>（当前列中，元素绝对值与该行最大绝对值之比最大的元素<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>。虽然一般的部分主元法足以应对大多数情况，但从数值稳定性上看，后者能够在矩阵元素有较大量级差异的极端情形下能够减少误差的积累，从而表现出更好的稳定性（比如<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(1\)</span><span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(10^5\)</span><span class="heti-spacing"> </span></span>这么大的量级差异<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>。</p>
<h3 id="complete-pivoting">Complete Pivoting<a class="headerlink" href="#complete-pivoting" title="Permanent link">⚓︎</a></h3>
<p><strong>完全主元法</strong>(complete pivoting)（或称为最大主元法<span><span class="heti-spacing"> </span>(maximal pivoting)</span><heti-adjacent class="heti-adjacent-half">）</heti-adjacent>：搜索所有的元素<span><span class="heti-spacing"> </span><span class="arithmatex">\(a_{ij} (i, j = k, \dots, n)\)</span></span>，找出其中数值最大的元素。通过<strong>互换</strong><span>(interchange)<span class="heti-spacing"> </span></span>行和列，使得该元素来到主元的位置上。</p>
<h3 id="amount-of-computation_1">Amount of Computation<a class="headerlink" href="#amount-of-computation_1" title="Permanent link">⚓︎</a></h3>
<ul>
<li>部分主元法：需要<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(O(n^2)\)</span><span class="heti-spacing"> </span></span>次<strong>比较</strong></li>
<li>缩放部分主元法：需要<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(O(n^2)\)</span><span class="heti-spacing"> </span></span>次<strong>比较</strong>，以及<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(O(n^2)\)</span><span class="heti-spacing"> </span></span>次<strong>除法</strong>（初始计算）</li>
<li>完全主元法：需要<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(O(\dfrac{n^3}{3})\)</span><span class="heti-spacing"> </span></span>次<strong>比较</strong></li>
</ul>
<blockquote>
<p>所以，要想追求更好的稳定性，就要以更大的计算量为代价。</p>
</blockquote>
<p><strong>注</strong> ：如果新的缩放因子在行交换的时候才被确定，那么缩放部分主元法需要<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(O(\dfrac{n^3}{3})\)</span><span class="heti-spacing"> </span></span>次额外的<strong>比较</strong>，以及<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(O(n^2)\)</span><span class="heti-spacing"> </span></span>次<strong>除法</strong></p>
<h2 id="matrix-factorization">Matrix Factorization<a class="headerlink" href="#matrix-factorization" title="Permanent link">⚓︎</a></h2>
<p>高斯消元法是一种简单粗暴的方法，但效率不是很高。因此下面介绍一种基于高斯消元法实现的改进方法——<strong>矩阵分解</strong>(matrix factorization)。它的计算过程如下：</p>
<ul>
<li>
<p>第<span class="heti-skip"><span class="heti-spacing"> </span>1<span class="heti-spacing"> </span></span>步：</p>
</li>
<li>
<p><span class="arithmatex">\(m_{i1} = \dfrac{a_{i1}}{a_{11}} (a_{11} \ne 0)\)</span></p>
</li>
<li>
<p>令<span><span class="heti-spacing"> </span><span class="arithmatex">\(L_1 = \begin{bmatrix}1 &amp; &amp; &amp; \\ -m_{21} &amp; 1 &amp; &amp; \\ \vdots &amp; &amp; \ddots \\ -m_{n1} &amp; &amp; &amp;1\end{bmatrix}\)</span></span>（这就是<strong>第一高斯变换矩阵</strong>(first Gaussian transformation matrix)<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，那么<span><span class="heti-spacing"> </span><span class="arithmatex">\(L_1 [A^{(1)} \quad \boldsymbol{b}^{(1)}] = \begin{bmatrix}a_{11}^{(1)} &amp; \dots a_{1n}^{(1)} &amp; b_1^{(1)} \\ 0 &amp; A^{(2)} &amp; \boldsymbol{b}^{(2)}\end{bmatrix}\)</span></span></p>
</li>
<li>
<p>第<span class="heti-skip"><span class="heti-spacing"> </span>k<span class="heti-spacing"> </span></span>步：</p>
</li>
<li>
<p><strong>第<span class="heti-skip"><span class="heti-spacing"> </span>k<span class="heti-spacing"> </span></span>高斯变换矩阵</strong>(kth Gaussian transformation matrix)：<span class="arithmatex">\(L_k = \begin{bmatrix}1 &amp; &amp; &amp; &amp; \\ &amp; \ddots &amp; &amp; &amp; \\ &amp; &amp; 1 &amp; &amp; \\ &amp; &amp; -m_{k+1, k} &amp; &amp; \\ &amp; &amp; \vdots &amp;\ddots &amp; \\ &amp; &amp; -m_{n, k} &amp; &amp; 1\end{bmatrix}\)</span>（空的地方都是<span><span class="heti-spacing"> </span>0</span>）</p>
</li>
<li>
<p>第<span class="heti-skip"><span class="heti-spacing"> </span>n-1<span class="heti-spacing"> </span></span>步：</p>
</li>
</ul>
<p>$$
  L_{n-1}L_{n-2} \dots L_1 [A \quad \boldsymbol{b}] = \begin{bmatrix}a_{11}^{(1)} &amp; a_{12}^{(1)} &amp; \dots &amp; a_{1n}^{(1)} &amp; b_1^{(1)}\ &amp; a_{22}^{(2)} &amp; \dots &amp; a_{2n}^{(2)} &amp; b_2^{(2)} \ &amp; &amp; \dots &amp; \vdots &amp; \vdots\ &amp; &amp; &amp; a_{nn}^{(n)} &amp; b_n^{(n)}\end{bmatrix}
  $$</p>
<p><strong>定理</strong></p>
<p>若高斯消元法能够在不使用行互换的基础上求解线性方程组<span><span class="heti-spacing"> </span><span class="arithmatex">\(A \boldsymbol{x} = \boldsymbol{b}\)</span></span>，那么矩阵<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>可以被因式分解为一个下三角矩阵<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(L\)</span><span class="heti-spacing"> </span></span>和上三角矩阵<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(U\)</span><span class="heti-spacing"> </span></span>的乘积，即<span><span class="heti-spacing"> </span><span class="arithmatex">\(A = LU\)</span></span>。</p>
<p>其中：</p>
<div class="arithmatex">\[
U = \begin{bmatrix}a_{11}^{(1)} &amp; a_{12}^{(1)} &amp; \dots &amp; a_{1n}^{(1)} \\ 0 &amp; a_{22}^{(2)} &amp; \dots &amp; a_{2n}^{(2)} \\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ 0 &amp; \dots &amp; \dots &amp; a_{nn}^{(n)}\end{bmatrix} \quad L = \begin{bmatrix}1 &amp; 0 &amp; \dots &amp; 0 \\ m_{21} &amp; 1 &amp; \dots &amp; 0 \\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ m_{n1} &amp; \dots &amp; m_{n, n-1} &amp; 1\end{bmatrix} \quad m_{ji} = \dfrac{a_{ji}^{(i)}}{a_{ii}^{(i)}}
\]</div>
<p>如果矩阵<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(L\)</span><span class="heti-spacing"> </span></span>是<strong>单位的</strong>(unitary)（也就是说主对角线元素都是<span><span class="heti-spacing"> </span>1</span><heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，那么得到的矩阵分解是<strong>唯一的</strong>。</p>
<p><strong>注</strong> ：如果<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(U\)</span><span class="heti-spacing"> </span></span>也是<strong>单位的</strong>，那么这种分解就称为<a href="https://en.wikipedia.org/wiki/Crout_matrix_decomposition"><strong><span>Crout<span class="heti-spacing"> </span></span>分解</strong></a>。我们可通过对<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A^T\)</span><span class="heti-spacing"> </span></span>的<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(LU\)</span><span class="heti-spacing"> </span></span>分解来实现<span class="heti-skip"><span class="heti-spacing"> </span>Crout<span class="heti-spacing"> </span></span>分解。也就是说，找到<span><span class="heti-spacing"> </span><span class="arithmatex">\(A^T = LU\)</span></span>，那么<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A = U^T L^T\)</span><span class="heti-spacing"> </span></span>就是<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>的<span class="heti-skip"><span class="heti-spacing"> </span>Crout<span class="heti-spacing"> </span></span>分解。</p>
<p><strong><span><span class="arithmatex">\(LU\)</span><span class="heti-spacing"> </span></span>分解的代码实现</strong></p>
<p>将<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n \times n\)</span><span class="heti-spacing"> </span></span>的矩阵<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A = (a_{ij})\)</span><span class="heti-spacing"> </span></span>分解为下三角矩阵<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(L = (l_{ij})\)</span><span class="heti-spacing"> </span></span>和上三角矩阵<span><span class="heti-spacing"> </span><span class="arithmatex">\(U = (u_{ij})\)</span></span>，也就是说<span><span class="heti-spacing"> </span><span class="arithmatex">\(A = LU\)</span></span>，其中<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(L\)</span><span class="heti-spacing"> </span></span>或<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(U\)</span><span class="heti-spacing"> </span></span>的主对角线元素均为<span><span class="heti-spacing"> </span>1</span>。</p>
<ul>
<li>输入：维度<span><span class="heti-spacing"> </span><span class="arithmatex">\(n\)</span></span>；<span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>的元素<span><span class="heti-spacing"> </span><span class="arithmatex">\(a_{ij}, 1 \le i, j \le n\)</span></span>；<span><span class="arithmatex">\(L\)</span><span class="heti-spacing"> </span></span>的对角元素<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(l_{11} = \dots = l_{nn} = 1\)</span><span class="heti-spacing"> </span></span>或<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(U\)</span><span class="heti-spacing"> </span></span>的对角元素<span><span class="heti-spacing"> </span><span class="arithmatex">\(u_{11} = \dots = u_{nn} = 1\)</span></span></li>
<li>输出：<span><span class="arithmatex">\(L\)</span><span class="heti-spacing"> </span></span>的项<span><span class="heti-spacing"> </span><span class="arithmatex">\(l_{ij}, 1 \le j \le i, 1 \le i \le n\)</span></span>，以及<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(U\)</span><span class="heti-spacing"> </span></span>的项<span><span class="heti-spacing"> </span><span class="arithmatex">\(u_{ij}, i \le j \le n, 1 \le i \le n\)</span></span></li>
</ul>
<div class="language-cpp highlight"><pre><span></span><code><span id="__span-7-1"><a href="#__codelineno-7-1" id="__codelineno-7-1" name="__codelineno-7-1"></a><span class="n">Step</span><span class="w"> </span><span class="mi">1</span><span class="w">  </span><span class="n">Select</span><span class="w"> </span><span class="n">l_11</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="n">u_11</span><span class="w"> </span><span class="n">satisfying</span><span class="w"> </span><span class="n">l_11</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">u_11</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a_11</span><span class="p">;</span>
</span><span id="__span-7-2"><a href="#__codelineno-7-2" id="__codelineno-7-2" name="__codelineno-7-2"></a><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">l_11</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">u_11</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">then</span><span class="w"> </span><span class="n">Output</span><span class="p">(</span><span class="err">'</span><span class="n">Factorization</span><span class="w"> </span><span class="n">impossible</span><span class="err">'</span><span class="p">);</span>
</span><span id="__span-7-3"><a href="#__codelineno-7-3" id="__codelineno-7-3" name="__codelineno-7-3"></a><span class="w">            </span><span class="n">Stop</span><span class="p">;</span>
</span><span id="__span-7-4"><a href="#__codelineno-7-4" id="__codelineno-7-4" name="__codelineno-7-4"></a><span class="n">Step</span><span class="w"> </span><span class="mi">2</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">set</span><span class="w"> </span><span class="n">u_1j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a_1j</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">l_11</span><span class="p">;</span><span class="w">    </span><span class="c1">// first row of U</span>
</span><span id="__span-7-5"><a href="#__codelineno-7-5" id="__codelineno-7-5" name="__codelineno-7-5"></a><span class="w">                              </span><span class="n">l_j1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a_j1</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">u_11</span><span class="p">;</span><span class="w">    </span><span class="c1">// first column of L</span>
</span><span id="__span-7-6"><a href="#__codelineno-7-6" id="__codelineno-7-6" name="__codelineno-7-6"></a><span class="n">Step</span><span class="w"> </span><span class="mi">3</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="n">Steps</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="mi">5</span><span class="o">:</span>
</span><span id="__span-7-7"><a href="#__codelineno-7-7" id="__codelineno-7-7" name="__codelineno-7-7"></a><span class="w">    </span><span class="n">Step</span><span class="w"> </span><span class="mi">4</span><span class="w">  </span><span class="n">Select</span><span class="w"> </span><span class="n">l_ii</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="n">u_ii</span><span class="w"> </span><span class="n">safisfying</span><span class="w"> </span><span class="n">l_ii</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">u_ii</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a_ii</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">sum</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="n">l_ik</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">u_ki</span><span class="p">);</span>
</span><span id="__span-7-8"><a href="#__codelineno-7-8" id="__codelineno-7-8" name="__codelineno-7-8"></a><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">l_ii</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">u_ii</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">then</span><span class="w"> </span><span class="n">Output</span><span class="p">(</span><span class="err">'</span><span class="n">Factorization</span><span class="w"> </span><span class="n">impossible</span><span class="err">'</span><span class="p">);</span>
</span><span id="__span-7-9"><a href="#__codelineno-7-9" id="__codelineno-7-9" name="__codelineno-7-9"></a><span class="w">                </span><span class="n">Stop</span><span class="p">;</span>
</span><span id="__span-7-10"><a href="#__codelineno-7-10" id="__codelineno-7-10" name="__codelineno-7-10"></a><span class="w">    </span><span class="n">Step</span><span class="w"> </span><span class="mi">5</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">n</span><span class="o">:</span>
</span><span id="__span-7-11"><a href="#__codelineno-7-11" id="__codelineno-7-11" name="__codelineno-7-11"></a><span class="w">                </span><span class="n">set</span><span class="w"> </span><span class="n">u_ij</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">l_ii</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">a_ij</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">sum</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="n">l_ik</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">u_kj</span><span class="p">));</span><span class="w">    </span><span class="c1">// ith row of U</span>
</span><span id="__span-7-12"><a href="#__codelineno-7-12" id="__codelineno-7-12" name="__codelineno-7-12"></a><span class="w">                </span><span class="n">set</span><span class="w"> </span><span class="n">l_ji</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">u_ii</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">a_ji</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">sum</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="n">l_jk</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">u_ki</span><span class="p">));</span><span class="w">    </span><span class="c1">// ith column of L</span>
</span><span id="__span-7-13"><a href="#__codelineno-7-13" id="__codelineno-7-13" name="__codelineno-7-13"></a><span class="n">Step</span><span class="w"> </span><span class="mi">6</span><span class="w">  </span><span class="n">Select</span><span class="w"> </span><span class="n">l_nn</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="n">u_nn</span><span class="w"> </span><span class="n">satisfying</span><span class="w"> </span><span class="n">l_nn</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">u_nn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a_nn</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">sum</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="n">l_nk</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">u_kn</span><span class="p">);</span>
</span><span id="__span-7-14"><a href="#__codelineno-7-14" id="__codelineno-7-14" name="__codelineno-7-14"></a><span class="c1">// if l_nn * u_nn = 0, then A = LU but A is singular</span>
</span><span id="__span-7-15"><a href="#__codelineno-7-15" id="__codelineno-7-15" name="__codelineno-7-15"></a><span class="n">Step</span><span class="w"> </span><span class="mi">7</span><span class="w">  </span><span class="n">Output</span><span class="p">(</span><span class="n">l_ij</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span>
</span><span id="__span-7-16"><a href="#__codelineno-7-16" id="__codelineno-7-16" name="__codelineno-7-16"></a><span class="w">        </span><span class="n">Output</span><span class="p">(</span><span class="n">u_ij</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span>
</span><span id="__span-7-17"><a href="#__codelineno-7-17" id="__codelineno-7-17" name="__codelineno-7-17"></a><span class="w">        </span><span class="n">STOP</span><span class="p">;</span>
</span></code></pre></div>
<p>这样我们只得到了<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(L\)</span><span class="heti-spacing"> </span></span>和<span><span class="heti-spacing"> </span><span class="arithmatex">\(U\)</span></span>，还没有解出这个线性方程组（矩阵<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，所以还要继续往下转换。</p>
<p>因为<span><span class="heti-spacing"> </span><span class="arithmatex">\(A \boldsymbol{x} = LU \boldsymbol{x} = \boldsymbol{b}\)</span></span>，所以我们令<span><span class="heti-spacing"> </span><span class="arithmatex">\(\boldsymbol{y} = U\boldsymbol{x}\)</span></span>，</p>
<ul>
<li>先解<span><span class="heti-spacing"> </span><span class="arithmatex">\(L \boldsymbol{y} = \boldsymbol{b}\)</span></span><ul>
<li><span class="arithmatex">\(y_1 = \dfrac{b_1}{l_{11}}\)</span></li>
<li><span class="arithmatex">\(y_i = \dfrac{1}{l_{ii}} \Big[b_i - \sum\limits_{j=1}^{i-1} u_{ij} y_j\Big]\)</span></li>
</ul>
</li>
<li>再解<span><span class="heti-spacing"> </span><span class="arithmatex">\(U \boldsymbol{x} = \boldsymbol{y}\)</span></span><ul>
<li><span class="arithmatex">\(x_n = \dfrac{y_n}{u_{nn}}\)</span></li>
<li><span class="arithmatex">\(x_i = \dfrac{1}{u_{ii}} \Big[y_i - \sum\limits_{j=i+1}^n u_{ij} x_j\Big]\)</span></li>
</ul>
</li>
</ul>
<p><strong>高斯消元法<span class="heti-skip"><span class="heti-spacing"> </span>v.s. LU<span class="heti-spacing"> </span></span>分解（by Gemini 2.5 Flash）</strong></p>
<table>
<thead>
<tr>
<th style="text-align: left;">特性</th>
<th style="text-align: left;">一般高斯消元法（直接对<span><span class="heti-spacing"> </span><span class="arithmatex">\([A\|b]\)</span></span>）</th>
<th style="text-align: left;"><span>LU<span class="heti-spacing"> </span></span>分解</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>基本思想</strong></td>
<td style="text-align: left;">将<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\([A\|b]\)</span><span class="heti-spacing"> </span></span>转化为<span><span class="heti-spacing"> </span><span class="arithmatex">\([U'\|b']\)</span></span></td>
<td style="text-align: left;">将<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>分解为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(L\)</span><span class="heti-spacing"> </span></span>和<span><span class="heti-spacing"> </span><span class="arithmatex">\(U\)</span></span></td>
</tr>
<tr>
<td style="text-align: left;"><strong>求解<span><span class="heti-spacing"> </span><span class="arithmatex">\(Ax=b\)</span></span></strong></td>
<td style="text-align: left;">每次<span><span class="heti-spacing"> </span><span class="arithmatex">\(O(N^3)\)</span></span></td>
<td style="text-align: left;">分解<span><span class="heti-spacing"> </span><span class="arithmatex">\(O(N^3)\)</span></span>，每次求解<span><span class="heti-spacing"> </span><span class="arithmatex">\(O(N^2)\)</span></span></td>
</tr>
<tr>
<td style="text-align: left;"><strong>多右端向量</strong></td>
<td style="text-align: left;">每次<span><span class="heti-spacing"> </span><span class="arithmatex">\(O(N^3)\)</span></span></td>
<td style="text-align: left;"><strong>高效</strong>：分解一次<span><span class="heti-spacing"> </span><span class="arithmatex">\(O(N^3)\)</span></span>，后续每次<span><span class="heti-spacing"> </span><span class="arithmatex">\(O(N^2)\)</span></span></td>
</tr>
<tr>
<td style="text-align: left;"><strong>计算<span><span class="heti-spacing"> </span><span class="arithmatex">\(A^{-1}\)</span></span></strong></td>
<td style="text-align: left;"><span class="arithmatex">\(O(N^4)\)</span></td>
<td style="text-align: left;"><strong>高效</strong>：<span class="arithmatex">\(O(N^3)\)</span></td>
</tr>
<tr>
<td style="text-align: left;"><strong>计算<span><span class="heti-spacing"> </span><span class="arithmatex">\(\det(A)\)</span></span></strong></td>
<td style="text-align: left;">需记录消元过程</td>
<td style="text-align: left;"><strong>直接</strong>：对角线元素乘积</td>
</tr>
<tr>
<td style="text-align: left;"><strong>结构</strong></td>
<td style="text-align: left;">紧密耦合<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>和<span><span class="heti-spacing"> </span><span class="arithmatex">\(b\)</span></span></td>
<td style="text-align: left;"><strong>模块化</strong>：分解与求解分离</td>
</tr>
<tr>
<td style="text-align: left;"><strong>存储</strong></td>
<td style="text-align: left;">每次重新计算</td>
<td style="text-align: left;"><span><span class="arithmatex">\(L, U\)</span><span class="heti-spacing"> </span></span>可存储重用</td>
</tr>
<tr>
<td style="text-align: left;"><strong>数值稳定性</strong></td>
<td style="text-align: left;">依赖于主元选择</td>
<td style="text-align: left;">依赖于主元选择，通常与主元法结合</td>
</tr>
</tbody>
</table>
<h2 id="special-types-of-matrices">Special Types of Matrices<a class="headerlink" href="#special-types-of-matrices" title="Permanent link">⚓︎</a></h2>
<h3 id="strictly-diagonally-dominant-matrix">Strictly Diagonally Dominant Matrix<a class="headerlink" href="#strictly-diagonally-dominant-matrix" title="Permanent link">⚓︎</a></h3>
<p><strong>严格对角占优矩阵</strong><span>(strictly diagonally dominant matrix)<span class="heti-spacing"> </span></span>满足：</p>
<div class="arithmatex">\[
|a_{ii}| &gt; \sum\limits_{\substack{j = 1 \\ j \ne i}}^n |a_{ij}|
\]</div>
<p>即对角线元素的绝对值是其所在行内所有元素的绝对值中的最大者。</p>
<p><strong>定理</strong></p>
<ul>
<li>严格对角占优矩阵<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>是<strong>非奇异的</strong>(nonsigular)（即行列式不为<span><span class="heti-spacing"> </span>0</span>，且存在逆矩阵）</li>
<li>在这种矩阵上使用高斯消元法<strong>无需</strong>行或列的<strong>互换</strong></li>
<li>并且计算将相对于舍入误差的增长保持<strong>稳定</strong></li>
</ul>
<h3 id="choleskis-method-for-positive-definite-matrix">Choleski's Method for Positive Definite Matrix<a class="headerlink" href="#choleskis-method-for-positive-definite-matrix" title="Permanent link">⚓︎</a></h3>
<p><strong>定义</strong> ：对于一个矩阵<span><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span></span>，如果它是<strong>对称的</strong>，且<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\forall \boldsymbol{x} \ne \boldsymbol{0}, \boldsymbol{x}^T A \boldsymbol{x} &gt; 0\)</span><span class="heti-spacing"> </span></span>成立，那么称该矩阵是<strong>正定</strong><span>(positive definite)<span class="heti-spacing"> </span></span>矩阵。</p>
<p><strong>定理</strong></p>
<p>正定矩阵<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>的性质：</p>
<p><span>a. <span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>是非奇异的</p>
<p>b. <span class="arithmatex">\(a_{ii} &gt; 0, i = 1, 2, \dots n\)</span></p>
<p>c. <span class="arithmatex">\(\max_{1 \le k, j \le n} |a_{kj}| \le \max_{1 \le i \le n} |a_{ii}|\)</span></p>
<p>d. <span class="arithmatex">\((a_{ij})^2 &lt; a_{ii} a_{jj}, i \ne j\)</span></p>
<p><span>PPT<span class="heti-spacing"> </span></span>上还有这些性质：</p>
<ul>
<li><span><span class="arithmatex">\(A^{-1}\)</span><span class="heti-spacing"> </span></span>也是正定的</li>
<li><span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>的每个<strong>前导主子矩阵</strong><span>(leading principal submatrices) <span class="arithmatex">\(A_k\)</span><span class="heti-spacing"> </span></span>的行列式<span class="heti-skip"><span class="heti-spacing"> </span>(determinant)<span class="heti-spacing"> </span></span>都是正的</li>
</ul>
<blockquote>
<p><strong>前导主子矩阵</strong> ：矩阵<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>的前导主子矩阵为<span><span class="heti-spacing"> </span><span class="arithmatex">\(A_k = \begin{bmatrix}a_{11} &amp; a_{12} &amp; \dots &amp; a_{1k} \\ a_{21} &amp; a_{22} &amp; \dots &amp; a_{2k} \\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ a_{k1} &amp; a_{k2} &amp; \dots &amp; a_{kk} \end{bmatrix}, 1 \le k \le n\)</span></span></p>
</blockquote>
<hr/>
<p>我们将<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A = LU\)</span><span class="heti-spacing"> </span></span>中的<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(U\)</span><span class="heti-spacing"> </span></span>进一步拆分成对角矩阵<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(D\)</span><span class="heti-spacing"> </span></span>和单位上三角矩阵<span><span class="heti-spacing"> </span><span class="arithmatex">\(\widetilde{U}\)</span></span>：</p>
<div style="text-align: center">
<img src="images/C6/3.png" width="70%/"/>
</div>
<p>可以推导出：<span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>是对称矩阵（<span class="arithmatex">\(A = A^T \rightarrow LU = LD \widetilde{U} = \widetilde{U^T} DL^T\)</span>）<span class="arithmatex">\(\Rightarrow L = \widetilde{U}^T \Rightarrow A = LDL^T\)</span>。这样我们得到了另一种矩阵分解—— <span><span class="arithmatex">\(LDL^T\)</span><span class="heti-spacing"> </span></span>分解：</p>
<p><strong><span><span class="arithmatex">\(LDL^T\)</span><span class="heti-spacing"> </span></span>分解的代码实现</strong></p>
<p>将<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n \times n\)</span><span class="heti-spacing"> </span></span>的矩阵<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A = (a_{ij})\)</span><span class="heti-spacing"> </span></span>分解为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(LDL^T\)</span><span class="heti-spacing"> </span></span>的形式，其中<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(L\)</span><span class="heti-spacing"> </span></span>是下三角矩阵，对角线元素均为<span><span class="heti-spacing"> </span>1</span>；<span><span class="arithmatex">\(D\)</span><span class="heti-spacing"> </span></span>为对角矩阵，对角线上的元素均为正数。</p>
<ul>
<li>输入：维度<span><span class="heti-spacing"> </span><span class="arithmatex">\(n\)</span></span>；<span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>的元素<span><span class="heti-spacing"> </span><span class="arithmatex">\(a_{ij}, 1 \le i, j \le n\)</span></span></li>
<li>输出：<span><span class="arithmatex">\(L\)</span><span class="heti-spacing"> </span></span>的项<span><span class="heti-spacing"> </span><span class="arithmatex">\(l_{ij}, 1 \le j \le i, 1 \le i \le n\)</span></span>，以及<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(D\)</span><span class="heti-spacing"> </span></span>的项<span><span class="heti-spacing"> </span><span class="arithmatex">\(u_{i}, 1 \le i \le n\)</span></span></li>
</ul>
<div class="language-cpp highlight"><pre><span></span><code><span id="__span-8-1"><a href="#__codelineno-8-1" id="__codelineno-8-1" name="__codelineno-8-1"></a><span class="n">Step</span><span class="w"> </span><span class="mi">1</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="n">Steps</span><span class="w"> </span><span class="mi">2-4</span><span class="o">:</span>
</span><span id="__span-8-2"><a href="#__codelineno-8-2" id="__codelineno-8-2" name="__codelineno-8-2"></a><span class="w">    </span><span class="n">Step</span><span class="w"> </span><span class="mi">2</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">set</span><span class="w"> </span><span class="n">v_j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">l_ij</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">d_j</span><span class="p">;</span>
</span><span id="__span-8-3"><a href="#__codelineno-8-3" id="__codelineno-8-3" name="__codelineno-8-3"></a><span class="w">    </span><span class="n">Step</span><span class="w"> </span><span class="mi">3</span><span class="w">  </span><span class="n">Set</span><span class="w"> </span><span class="n">d_i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a_ii</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">sum</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="n">l_ij</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v_j</span><span class="p">);</span>
</span><span id="__span-8-4"><a href="#__codelineno-8-4" id="__codelineno-8-4" name="__codelineno-8-4"></a><span class="w">    </span><span class="n">Step</span><span class="w"> </span><span class="mi">4</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">set</span><span class="w"> </span><span class="n">l_ji</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">a_ji</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">sum</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="n">l_jk</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v_k</span><span class="p">))</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">d_i</span><span class="p">;</span>
</span></code></pre></div>
<hr/>
<p>令<span><span class="heti-spacing"> </span><span class="arithmatex">\(D^{\frac{1}{2}} = \begin{bmatrix}\sqrt{u_{11}} &amp; &amp; &amp; \\ &amp; \sqrt{u_{22}} &amp; &amp; \\ &amp; &amp; &amp; &amp; \\ &amp; &amp; &amp; \sqrt{u_{nn}}\end{bmatrix}\)</span></span>，<span><span class="arithmatex">\(\widetilde{L} = LD^{\frac{1}{2}}\)</span><span class="heti-spacing"> </span></span>仍然是一个上三角矩阵，因此<span><span class="heti-spacing"> </span><span class="arithmatex">\(A = \widetilde{L} \widetilde{L}^T\)</span></span></p>
<blockquote>
<p>因为前导主子矩阵都是正的，所以<span><span class="heti-spacing"> </span><span class="arithmatex">\(u_{ii} &gt; 0\)</span></span></p>
</blockquote>
<p>综上，若<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>是<strong>正定矩阵</strong>，那么：</p>
<ul>
<li>当<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(L\)</span><span class="heti-spacing"> </span></span>是一个对角线元素均为<span class="heti-skip"><span class="heti-spacing"> </span>1<span class="heti-spacing"> </span></span>的下三角矩阵，并且<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(D\)</span><span class="heti-spacing"> </span></span>是一个对角项均为正数的对角矩阵时，<span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>可被分解为<span><span class="heti-spacing"> </span><span class="arithmatex">\(LDL^T\)</span></span></li>
<li>当<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(L\)</span><span class="heti-spacing"> </span></span>是一个对角线上均为非零元素的下三角矩阵时，<span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>可被分解为<span><span class="heti-spacing"> </span><span class="arithmatex">\(LL^T\)</span></span></li>
</ul>
<p><strong>算法：<span>Choleski<span class="heti-spacing"> </span></span>法</strong></p>
<p>目标：将规模为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n \times n\)</span><span class="heti-spacing"> </span></span>的对称的正定矩阵<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>分解为<span><span class="heti-spacing"> </span><span class="arithmatex">\(LL^T\)</span></span>，其中<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(L\)</span><span class="heti-spacing"> </span></span>是下三角矩阵。</p>
<p>输入：<span><span class="arithmatex">\(n\)</span><span class="heti-spacing"> </span></span>维矩阵<span><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span></span>，其元素为<span><span class="heti-spacing"> </span><span class="arithmatex">\(a_{ij}, 1 \le i, j \le n\)</span></span></p>
<p>输出：矩阵<span><span class="heti-spacing"> </span><span class="arithmatex">\(L\)</span></span>，其元素为<span><span class="heti-spacing"> </span><span class="arithmatex">\(l_{ij}, 1 \le j \le i, 1 \le i \le n\)</span></span></p>
<div class="language-cpp highlight"><pre><span></span><code><span id="__span-9-1"><a href="#__codelineno-9-1" id="__codelineno-9-1" name="__codelineno-9-1"></a><span class="n">Step</span><span class="w"> </span><span class="mi">1</span><span class="w">  </span><span class="n">set</span><span class="w"> </span><span class="n">l_11</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sqrt</span><span class="p">(</span><span class="n">a_11</span><span class="p">);</span>
</span><span id="__span-9-2"><a href="#__codelineno-9-2" id="__codelineno-9-2" name="__codelineno-9-2"></a><span class="n">Step</span><span class="w"> </span><span class="mi">2</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">set</span><span class="w"> </span><span class="n">l_j1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a_j1</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">l_11</span><span class="p">;</span>
</span><span id="__span-9-3"><a href="#__codelineno-9-3" id="__codelineno-9-3" name="__codelineno-9-3"></a><span class="n">Step</span><span class="w"> </span><span class="mi">3</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="n">steps</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="mi">5</span>
</span><span id="__span-9-4"><a href="#__codelineno-9-4" id="__codelineno-9-4" name="__codelineno-9-4"></a><span class="w">    </span><span class="n">Step</span><span class="w"> </span><span class="mi">4</span><span class="w">  </span><span class="n">set</span><span class="w"> </span><span class="n">l_ii</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sqrt</span><span class="p">(</span><span class="n">a_ii</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">sum</span><span class="p">(</span><span class="n">pow</span><span class="p">(</span><span class="n">l_ik</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">),</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span>
</span><span id="__span-9-5"><a href="#__codelineno-9-5" id="__codelineno-9-5" name="__codelineno-9-5"></a><span class="w">    </span><span class="c1">// LDL^T is faster, but must be modified to solve Ax = b</span>
</span><span id="__span-9-6"><a href="#__codelineno-9-6" id="__codelineno-9-6" name="__codelineno-9-6"></a>
</span><span id="__span-9-7"><a href="#__codelineno-9-7" id="__codelineno-9-7" name="__codelineno-9-7"></a><span class="w">    </span><span class="n">Step</span><span class="w"> </span><span class="mi">5</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">set</span><span class="w"> </span><span class="n">l_ji</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">a_ji</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">sum</span><span class="p">(</span><span class="n">l_jk</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">l_ik</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">l_ii</span><span class="p">;</span>
</span><span id="__span-9-8"><a href="#__codelineno-9-8" id="__codelineno-9-8" name="__codelineno-9-8"></a><span class="n">Step</span><span class="w"> </span><span class="mi">6</span><span class="w">  </span><span class="n">set</span><span class="w"> </span><span class="n">l_nn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sqrt</span><span class="p">(</span><span class="n">a_nn</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">sum</span><span class="p">(</span><span class="n">pow</span><span class="p">(</span><span class="n">l_nk</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">),</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span>
</span><span id="__span-9-9"><a href="#__codelineno-9-9" id="__codelineno-9-9" name="__codelineno-9-9"></a><span class="n">Step</span><span class="w"> </span><span class="mi">7</span><span class="w">  </span><span class="n">output</span><span class="w"> </span><span class="p">(</span><span class="n">l_ij</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">n</span><span class="p">);</span>
</span><span id="__span-9-10"><a href="#__codelineno-9-10" id="__codelineno-9-10" name="__codelineno-9-10"></a><span class="n">Stop</span><span class="p">.</span>
</span></code></pre></div>
<p><strong><span>Choleski<span class="heti-spacing"> </span></span>法的优点（by Gemini 2.5 Flash）</strong></p>
<ul>
<li>数值稳定性高：<span>Choleski<span class="heti-spacing"> </span></span>法在数值上非常稳定，因为它不需要主元选择。由于矩阵是正定的，可以保证对角线元素<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(l_{ii}\)</span><span class="heti-spacing"> </span></span>的平方根总是正实数，并且不会出现除以零的情况。</li>
<li>计算效率高：相比于一般的<span class="heti-skip"><span class="heti-spacing"> </span>LU<span class="heti-spacing"> </span></span>分解（需要<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(2N^3/3\)</span><span class="heti-spacing"> </span></span>次浮点运算<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，<span>Choleski<span class="heti-spacing"> </span></span>法只需要大约<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(N^3/3\)</span><span class="heti-spacing"> </span></span>次浮点运算，因为它利用了矩阵的对称性，只需要计算<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(L\)</span><span class="heti-spacing"> </span></span>的下三角部分（或<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(U\)</span><span class="heti-spacing"> </span></span>的上三角部分<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>。这使得它在处理大型对称正定系统时非常高效。</li>
<li>存储效率高：由于<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(L\)</span><span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(L^T\)</span><span class="heti-spacing"> </span></span>之间存在关系，我们只需要存储<span><span class="heti-spacing"> </span><span class="arithmatex">\(L\)</span></span>（或<span><span class="heti-spacing"> </span><span class="arithmatex">\(U\)</span></span><heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，这节省了存储空间。</li>
<li>保证正定性：如果<span class="heti-skip"><span class="heti-spacing"> </span>Choleski<span class="heti-spacing"> </span></span>法成功完成（即所有<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(l_{ii}\)</span><span class="heti-spacing"> </span></span>都是正实数<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，则可以确认原始矩阵是正定的。反之，如果分解过程中遇到负数或零的平方根，则矩阵不是正定的。</li>
</ul>
<h3 id="crout-reduction-for-tridiagonal-linear-system">Crout Reduction for Tridiagonal Linear System<a class="headerlink" href="#crout-reduction-for-tridiagonal-linear-system" title="Permanent link">⚓︎</a></h3>
<p><strong>带状矩阵</strong> ：对于一个<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n \times n\)</span><span class="heti-spacing"> </span></span>的矩阵，如果有整数<span><span class="heti-spacing"> </span><span class="arithmatex">\(p, q\)</span></span>，满足<span><span class="heti-spacing"> </span><span class="arithmatex">\(1 &lt; p, q &lt; n\)</span></span>，当<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(i + p \le j\)</span><span class="heti-spacing"> </span></span>或<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(j + q \le i\)</span><span class="heti-spacing"> </span></span>时，有<span><span class="heti-spacing"> </span><span class="arithmatex">\(a_{ij} = 0\)</span></span>，那么称该矩阵为<strong>带状矩阵</strong>(band matrix)，其<strong>带宽</strong><span>(bandwidth)<span class="heti-spacing"> </span></span>为<span><span class="heti-spacing"> </span><span class="arithmatex">\(w = p + q - 1\)</span></span>。</p>
<p>当<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(p = q = 2\)</span><span class="heti-spacing"> </span></span>时，<span class="arithmatex">\(w = 3\)</span>，此时的矩阵称为<strong>三对角矩阵</strong>(tridiagonal matrix)，其形式如下：</p>
<div class="arithmatex">\[
A = \begin{bmatrix}a_{11} &amp; a_{12} &amp; 0 &amp; \dots &amp; \dots &amp; 0 \\ a_{21} &amp; a_{22} &amp; a_{23} &amp; \dots &amp; \dots &amp; \vdots \\ 0 &amp; a_{32} &amp; a_{33} &amp; \dots &amp; \dots &amp; \vdots \\ \vdots &amp; \ddots &amp; \ddots &amp; \ddots &amp; \ddots &amp; a_{n-1, n} \\ 0 &amp; \dots &amp; \dots &amp; 0 &amp; a_{n, n-1} &amp; a_{nn}\end{bmatrix}
\]</div>
<p>对于上述形式的线性方程组（<span class="arithmatex">\(A \boldsymbol{x} = \boldsymbol{f}\)</span><heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，我们采用一种特殊的<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(LU\)</span><span class="heti-spacing"> </span></span>分解，称为 <strong><span>Crout<span class="heti-spacing"> </span></span>分解</strong>。下面给出具体求解步骤：</p>
<ol>
<li>寻找矩阵<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>的<span class="heti-skip"><span class="heti-spacing"> </span>Crout<span class="heti-spacing"> </span></span>分解，<span><span class="arithmatex">\(L, U\)</span><span class="heti-spacing"> </span></span>分别为：</li>
</ol>
<p>$$
   L = \begin{bmatrix}l_{11} &amp; 0 &amp; \dots &amp; \dots &amp; 0 \ l_{21} &amp; l_{22} &amp; \ddots &amp; &amp; \vdots \ 0 &amp; \ddots &amp; \ddots &amp; \ddots &amp; 0 \ 0 &amp; \dots &amp; 0 &amp; l_{n, n-1} &amp; l_{nn}\end{bmatrix} \quad U = \begin{bmatrix}1 &amp; u_{12} &amp; 0 &amp; \dots &amp; 0 \ 0 &amp; 1 &amp; \ddots &amp; \ddots &amp; \vdots \ \vdots &amp; &amp; \ddots &amp; \ddots &amp; u_{n-1, n} \ 0 &amp; \dots &amp; \dots &amp; 0 &amp; 1\end{bmatrix}
   $$</p>
<ol>
<li>
<p>求解<span><span class="heti-spacing"> </span><span class="arithmatex">\(L\boldsymbol{y} = \boldsymbol{f} \Rightarrow y_1 = \dfrac{f_1}{l_{11}}, y_i = \dfrac{(f_i - l_{i, i-1} y_{i-1})}{l_{ii}} (i = 2, \dots, n)\)</span></span></p>
</li>
<li>
<p>求解<span><span class="heti-spacing"> </span><span class="arithmatex">\(U\boldsymbol{x} = \boldsymbol{y} \Rightarrow x_n = y_n, x_i = y_i - u_{i,i+1} x_{i+1}\)</span></span></p>
</li>
</ol>
<p><strong>定理</strong> ：如果<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>是三对角线矩阵，且是对角线占优的，并满足<span><span class="heti-spacing"> </span><span class="arithmatex">\(|b_1| &gt; |c_1| &gt; 0, |b_n| &gt; |a_n| &gt; 0, a_i \ne 0, c_i \ne 0\)</span></span>，那么<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>是非奇异的，对应的线性方程组有解。</p>
<p><strong>注</strong></p>
<ul>
<li>如果<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>是严格对角占优的，那么没有必要让所有的<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(a_i, b_i, c_i\)</span><span class="heti-spacing"> </span></span>都是非零的</li>
<li>该方法是稳定的，因为所有从计算过程中获得的值会被约束在原有元素的范围内</li>
<li>计算量为<span><span class="heti-spacing"> </span><span class="arithmatex">\(O(n)\)</span></span></li>
</ul>
<p><strong>代码实现</strong></p>
<p>求解<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n \times n\)</span><span class="heti-spacing"> </span></span>的线性方程组：</p>
<div class="arithmatex">\[
\begin{align}
E_1: a_{11} x_1 + a_{12} x_2 \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad &amp; = a_{1, n+1} \notag \\
E_2: a_{21} x_1 + a_{22} x_2 + a_{23} x_3 \quad \quad \quad \quad \quad \quad \quad \quad \quad \ \ &amp; = a_{2, n+1} \notag \\
\vdots \quad \quad \quad \quad \quad \quad \quad \quad \quad \vdots \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \ \ &amp; \ \ \vdots \notag \\
E_{n-1}: \quad a_{n-1, n-2} x_{n-2} + a_{n-1, n-1} x_{n-1} + a_{n-1, n} x_n &amp; = a_{n-1, n+1} \notag \\
E_{n}: \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \ a_{n, n-1} x_{n-1} + a_{n, n} x_n &amp; = a_{n, n+1} \notag \\
\end{align}
\]</div>
<p>假设这个线性方程组有唯一解。</p>
<ul>
<li>输入：维度<span><span class="heti-spacing"> </span><span class="arithmatex">\(n\)</span></span>；<span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>的元素</li>
<li>输出：解<span><span class="heti-spacing"> </span><span class="arithmatex">\(x_1, \dots, x_n\)</span></span></li>
</ul>
<div class="language-cpp highlight"><pre><span></span><code><span id="__span-10-1"><a href="#__codelineno-10-1" id="__codelineno-10-1" name="__codelineno-10-1"></a><span class="n">Step</span><span class="w"> </span><span class="mi">1</span><span class="w">  </span><span class="n">Set</span><span class="w"> </span><span class="n">l_11</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a_11</span><span class="p">;</span>
</span><span id="__span-10-2"><a href="#__codelineno-10-2" id="__codelineno-10-2" name="__codelineno-10-2"></a><span class="w">            </span><span class="n">u_12</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a_12</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">l_11</span><span class="p">;</span>
</span><span id="__span-10-3"><a href="#__codelineno-10-3" id="__codelineno-10-3" name="__codelineno-10-3"></a><span class="w">            </span><span class="n">z_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a_</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">}</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">l_11</span><span class="p">;</span>
</span><span id="__span-10-4"><a href="#__codelineno-10-4" id="__codelineno-10-4" name="__codelineno-10-4"></a><span class="n">Step</span><span class="w"> </span><span class="mi">2</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">n</span><span class="mi">-1</span><span class="w"> </span><span class="n">set</span><span class="w"> </span><span class="n">l_</span><span class="p">{</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="mi">-1</span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a_</span><span class="p">{</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="mi">-1</span><span class="p">};</span><span class="w">    </span><span class="c1">// ith row of L</span>
</span><span id="__span-10-5"><a href="#__codelineno-10-5" id="__codelineno-10-5" name="__codelineno-10-5"></a><span class="w">                                </span><span class="n">l_ii</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a_ii</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">l_</span><span class="p">{</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="mi">-1</span><span class="p">}</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">u_</span><span class="p">{</span><span class="n">i</span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">};</span>
</span><span id="__span-10-6"><a href="#__codelineno-10-6" id="__codelineno-10-6" name="__codelineno-10-6"></a><span class="w">                                </span><span class="n">u_</span><span class="p">{</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a_</span><span class="p">{</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">}</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">l_ii</span><span class="p">;</span><span class="w">    </span><span class="c1">// (i+1)th column of U</span>
</span><span id="__span-10-7"><a href="#__codelineno-10-7" id="__codelineno-10-7" name="__codelineno-10-7"></a><span class="w">                                </span><span class="n">z_i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">a_</span><span class="p">{</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">}</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">l_</span><span class="p">{</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="mi">-1</span><span class="p">}</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">z_</span><span class="p">{</span><span class="n">i</span><span class="mi">-1</span><span class="p">})</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">l_ii</span><span class="p">;</span>
</span><span id="__span-10-8"><a href="#__codelineno-10-8" id="__codelineno-10-8" name="__codelineno-10-8"></a><span class="n">Step</span><span class="w"> </span><span class="mi">3</span><span class="w">  </span><span class="n">Set</span><span class="w"> </span><span class="n">l_</span><span class="p">{</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="mi">-1</span><span class="p">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a_</span><span class="p">{</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="mi">-1</span><span class="p">};</span><span class="w">    </span><span class="c1">// nth row of L</span>
</span><span id="__span-10-9"><a href="#__codelineno-10-9" id="__codelineno-10-9" name="__codelineno-10-9"></a><span class="w">            </span><span class="n">l_nn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a_nn</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">l_</span><span class="p">{</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="mi">-1</span><span class="p">}</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">u_</span><span class="p">{</span><span class="n">n</span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">};</span>
</span><span id="__span-10-10"><a href="#__codelineno-10-10" id="__codelineno-10-10" name="__codelineno-10-10"></a><span class="w">            </span><span class="n">z_n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">a_</span><span class="p">{</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">}</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">l_</span><span class="p">{</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="mi">-1</span><span class="p">}</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">z_</span><span class="p">{</span><span class="n">n</span><span class="mi">-1</span><span class="p">})</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">l_nn</span><span class="p">;</span>
</span><span id="__span-10-11"><a href="#__codelineno-10-11" id="__codelineno-10-11" name="__codelineno-10-11"></a><span class="c1">// Step 4 and 5 solve Ux = z</span>
</span><span id="__span-10-12"><a href="#__codelineno-10-12" id="__codelineno-10-12" name="__codelineno-10-12"></a><span class="n">Step</span><span class="w"> </span><span class="mi">4</span><span class="w">  </span><span class="n">x_n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">z_n</span><span class="p">;</span>
</span><span id="__span-10-13"><a href="#__codelineno-10-13" id="__codelineno-10-13" name="__codelineno-10-13"></a><span class="n">Step</span><span class="w"> </span><span class="mi">5</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">set</span><span class="w"> </span><span class="n">x_i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">z_i</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">u_</span><span class="p">{</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">}</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x_</span><span class="p">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">};</span>
</span><span id="__span-10-14"><a href="#__codelineno-10-14" id="__codelineno-10-14" name="__codelineno-10-14"></a><span class="n">Step</span><span class="w"> </span><span class="mi">6</span><span class="w">  </span><span class="n">Output</span><span class="p">(</span><span class="n">x_1</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">x_n</span><span class="p">);</span>
</span><span id="__span-10-15"><a href="#__codelineno-10-15" id="__codelineno-10-15" name="__codelineno-10-15"></a><span class="w">        </span><span class="n">STOP</span><span class="p">;</span>
</span></code></pre></div>
<h1 id="chap-7-iterative-techniques-in-matrix-algebra">Chap 7: Iterative Techniques in Matrix Algebra<a class="headerlink" href="#chap-7-iterative-techniques-in-matrix-algebra" title="Permanent link">⚓︎</a></h1>
<p>目标：同第<span class="heti-skip"><span class="heti-spacing"> </span>6<span class="heti-spacing"> </span></span>章，还是求解<span><span class="heti-spacing"> </span><span class="arithmatex">\(A \boldsymbol{x} = \boldsymbol{b}\)</span></span>。</p>
<p><strong>思路</strong>：</p>
<p>类似求解<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f(x) = 0\)</span><span class="heti-spacing"> </span></span>用的不动点迭代：</p>
<ul>
<li>先将<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A \boldsymbol{x} = \boldsymbol{b}\)</span><span class="heti-spacing"> </span></span>转化为等价的<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\boldsymbol{x} = T\boldsymbol{x} + \boldsymbol{c}\)</span><span class="heti-spacing"> </span></span>的形式</li>
<li>然后从初始猜测值<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\boldsymbol{x}^{(0)}\)</span><span class="heti-spacing"> </span></span>开始<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\boldsymbol{x}^{(k+1)} = T\boldsymbol{x}^{(k)} + \boldsymbol{c}\)</span><span class="heti-spacing"> </span></span>的迭代，得到（收敛的）序列<span><span class="heti-spacing"> </span><span class="arithmatex">\(\{\boldsymbol{x}^{(k)}\}\)</span></span></li>
</ul>
<p>上述思路的优势在于：</p>
<ul>
<li>可以通过迭代次数来控制精度</li>
<li>迭代技术被实际运用于求解<strong>稀疏的</strong><span>(sparse)<span class="heti-spacing"> </span></span>线性方程组</li>
</ul>
<p>接下来我们需要分析：</p>
<ul>
<li>如何设计一个迭代方案</li>
<li>在何种条件下序列将会收敛</li>
<li>某个方法的收敛速度有多快</li>
<li>误差评估</li>
</ul>
<h2 id="norms-of-vectors-and-matrices">Norms of Vectors and Matrices<a class="headerlink" href="#norms-of-vectors-and-matrices" title="Permanent link">⚓︎</a></h2>
<h3 id="vector-norms">Vector Norms<a class="headerlink" href="#vector-norms" title="Permanent link">⚓︎</a></h3>
<p>在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(R^n\)</span><span class="heti-spacing"> </span></span>上的<strong>向量范数</strong><span>(vector norm)<span class="heti-spacing"> </span></span>是一个<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(R^n \rightarrow R\)</span><span class="heti-spacing"> </span></span>的函数<span><span class="heti-spacing"> </span><span class="arithmatex">\(\| \cdot \|\)</span></span>。<span class="arithmatex">\(\forall \boldsymbol{x}, \boldsymbol{y} \in R^n, \alpha \in C\)</span>，它满足以下性质：</p>
<ul>
<li><strong>正定</strong>：<span class="arithmatex">\(\| \boldsymbol{x} \| \ge 0;\ \| \boldsymbol{x} \| = 0 \Leftrightarrow \boldsymbol{x} = \boldsymbol{0}\)</span></li>
<li><strong>齐次</strong>(homogeneous)：<span class="arithmatex">\(\| \alpha \boldsymbol{x} \| = |\alpha| \cdot \| \boldsymbol{x} \|\)</span></li>
<li><strong>三角不等式</strong>：<span class="arithmatex">\(\| \boldsymbol{x} + \boldsymbol{y}\| \le \| \boldsymbol{x} \| + \| \boldsymbol{y} \|\)</span></li>
</ul>
<p><strong>例子</strong></p>
<p>题目：</p>
<div style="text-align: center">
<img src="images/C7/8.png" width="80%/"/>
</div>
<p>解答：</p>
<p>就证明这个范数满足上述三条性质就行了，很简单的！</p>
<p>一些常用的范数：</p>
<ul>
<li><span class="arithmatex">\(\| \boldsymbol{x} \|_1 = \sum\limits_{i=1}^n |x_i|\)</span></li>
<li><span class="arithmatex">\(\| \boldsymbol{x} \|_2 = \sqrt{\sum\limits_{i=1}^n |x_i|^2}\)</span>（<strong>欧几里得范数</strong>，即我们熟知的<strong>模长</strong>）</li>
<li><span class="arithmatex">\(\| \boldsymbol{x} \|_p = \Big( \sum\limits_{i=1}^n |x_i|^p \Big)^{\frac{1}{p}}\)</span>（<strong><span><span class="arithmatex">\(p\)</span><span class="heti-spacing"> </span></span>范数</strong>）</li>
<li><span class="arithmatex">\(\| \boldsymbol{x} \|_\infty = \max\limits_{1 \le i \le n} |x_i|\)</span>（<strong>无穷范数</strong>）</li>
</ul>
<p>注：<span class="arithmatex">\(\lim\limits_{p \rightarrow \infty} \| \boldsymbol{x} \|_p = \| \boldsymbol{x} \|_{\infty}\)</span></p>
<p><strong>一些定义和定理</strong></p>
<p>向量的收敛性：</p>
<p>定义<span><span class="heti-spacing"> </span>1</span>：若<span><span class="heti-spacing"> </span><span class="arithmatex">\(\forall \varepsilon &gt; 0\)</span></span>，<span class="arithmatex">\(\exists N(\varepsilon) \in N\)</span>，使得<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\|\boldsymbol{x}^{(k)} - \boldsymbol{x}\| &lt; \varepsilon\)</span><span class="heti-spacing"> </span></span>成立，那么在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(R^n\)</span><span class="heti-spacing"> </span></span>上的向量序列<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\{ \boldsymbol{x}^{(k)} \}_{k=1}^{\infty}\)</span><span class="heti-spacing"> </span></span>关于范数<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\| \cdot \|\)</span><span class="heti-spacing"> </span></span>收敛到<span><span class="heti-spacing"> </span><span class="arithmatex">\(\boldsymbol{x}\)</span></span>。</p>
<p>定理<span><span class="heti-spacing"> </span>1</span>：当且仅当<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\lim\limits_{k \rightarrow \infty} x_i^{(k)} = x_i\ (i = 1, 2, \dots, n)\)</span><span class="heti-spacing"> </span></span>时，那么在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(R^n\)</span><span class="heti-spacing"> </span></span>上的向量序列<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\{\boldsymbol{x}\}_{k=1}^{\infty}\)</span><span class="heti-spacing"> </span></span>关于范数<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\| \cdot \|_{\infty}\)</span><span class="heti-spacing"> </span></span>收敛到<span><span class="heti-spacing"> </span><span class="arithmatex">\(\boldsymbol{x}\)</span></span>。</p>
<p>范数的等价性：</p>
<p>定义<span><span class="heti-spacing"> </span>2</span>：若存在正常数<span><span class="heti-spacing"> </span><span class="arithmatex">\(C_1, C_2\)</span></span>，使得<span><span class="heti-spacing"> </span><span class="arithmatex">\(C_1 \|\boldsymbol{x}\|_B \le \|\boldsymbol{x}\|_A \le C_2 \| \boldsymbol{x} \|_B\)</span></span>，那么<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\| \cdot \|_A\)</span><span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\| \cdot \|_B\)</span><span class="heti-spacing"> </span></span>是等价的。</p>
<p>定理<span><span class="heti-spacing"> </span>2</span>：所有在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(R^n\)</span><span class="heti-spacing"> </span></span>上的向量范数都是等价的。</p>
<p>下面证明了<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\| \cdot \|_2\)</span><span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\| \cdot \|_\infty\)</span><span class="heti-spacing"> </span></span>的等价性：</p>
<div style="text-align: center">
<img src="images/C7/4.png" width="90%/"/>
</div>
<h3 id="matrix-norms">Matrix Norms<a class="headerlink" href="#matrix-norms" title="Permanent link">⚓︎</a></h3>
<p>对于所有规模为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n \times n\)</span><span class="heti-spacing"> </span></span>的矩阵，<strong>矩阵范数</strong><span>(matrix norms)<span class="heti-spacing"> </span></span>是一个实数值函数<span><span class="heti-spacing"> </span><span class="arithmatex">\(\| \cdot \|\)</span></span>。对于所有规模为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n \times n\)</span><span class="heti-spacing"> </span></span>的矩阵<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A, B\)</span><span class="heti-spacing"> </span></span>以及所有的<span><span class="heti-spacing"> </span><span class="arithmatex">\(\alpha \in C\)</span></span>，满足：</p>
<ul>
<li><strong>正定</strong>：<span class="arithmatex">\(\| A \| \ge 0;\ \| A \| = 0 \Leftrightarrow A = O\)</span></li>
<li><strong>齐次</strong>：<span class="arithmatex">\(\| \alpha A \| = |\alpha| \cdot \| A \|\)</span></li>
<li><strong>三角不等式</strong>：<span class="arithmatex">\(\| A + B \| \le \| A \| + \| B \|\)</span></li>
<li><img alt="🌟" class="twemoji" src="https://cdn.jsdelivr.net/gh/jdecked/twemoji@15.1.0/assets/svg/1f31f.svg" title=":star2:"/> <strong>一致性</strong>(consistency)：<span class="arithmatex">\(\| AB \| \le \| A \| \cdot \| B \|\)</span></li>
</ul>
<p>下面整理了一些常用的范数：</p>
<ul>
<li>
<p><strong>弗罗贝尼乌斯范数</strong>(Frobenius norm)：<span class="arithmatex">\(\| A \|_F = \sqrt{\sum\limits_{i=1}^n \sum\limits_{j=1}^n |a_{ij}|^2}\)</span></p>
</li>
<li>
<p><strong>自然范数</strong>(natural norm)</p>
</li>
<li>
<p><strong>算子范数</strong>(operator norm)（和向量范数<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\| \cdot \|\)</span><span class="heti-spacing"> </span></span>关联，所以也可称为 <strong><span><span class="arithmatex">\(p\)</span><span class="heti-spacing"> </span></span>范数</strong>）</p>
<div class="arithmatex">\[
\| A \|_p = \max\limits_{\boldsymbol{x} \ne \boldsymbol{0}} \dfrac{\| A \boldsymbol{x} \|_p}{\| \boldsymbol{x} \|_p} = \max\limits_{\| \boldsymbol{x} \|_p = 1} \| A\boldsymbol{x} \|_p
\]</div>
</li>
<li>
<p><strong>无穷范数</strong>：<span class="arithmatex">\(\| A \|_{\infty} = \max\limits_{1 \le i \le n} \sum\limits_{j=1}^n |a_{ij}|\)</span></p>
</li>
<li>
<p><strong><span>1-<span class="heti-spacing"> </span></span>范数</strong>：<span class="arithmatex">\(\| A \|_1 = \max\limits_{1 \le j \le n} \sum\limits_{i=1}^n |a_{ij}|\)</span></p>
</li>
<li>
<p><strong><span>2-<span class="heti-spacing"> </span></span>范数</strong>（又称<strong>谱范数</strong>(spectral norm)<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>：<span class="arithmatex">\(\| A \|_2 = \sqrt{\lambda_{\max} (A^T A)}\)</span></p>
</li>
</ul>
<p><strong>推论</strong></p>
<p>对于任意向量<span><span class="heti-spacing"> </span><span class="arithmatex">\(\boldsymbol{z} \ne 0\)</span></span>，矩阵<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>以及任意自然范数<span><span class="heti-spacing"> </span><span class="arithmatex">\(\| \cdot \|\)</span></span>，我们有：</p>
<div class="arithmatex">\[
\| A \boldsymbol{z} \| \le \| A \| \cdot \| \boldsymbol{z} \|
\]</div>
<p>成立。</p>
<p><strong>所以范数到底是什么？</strong></p>
<p><span>PPT<span class="heti-spacing"> </span></span>上没有讲清楚我们要学范数的原因（虽然可以根据上下文推测出它会被用于迭代求解线性方程组<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，所以看这些概念的时候难免会一头雾水。于是，我还是让老朋友<span class="heti-skip"><span class="heti-spacing"> </span>Gemini 2.5 Flash<span class="heti-spacing"> </span></span>帮我用相对通俗的语言简单说明范数的意义，进而理解学习范数的原因：</p>
<ul>
<li>是什么？——范数是广义上的“长度”或“大小”，是任何满足三条基本性质（非负、齐次、三角不等式）的函数。</li>
<li>有什么用？——它是一把万能的“尺子”，核心意义在于<strong>量化</strong>。<ul>
<li>它量化了<strong>距离</strong>，让我们可以在抽象空间中比较“远近”。</li>
<li>它量化了<strong>误差</strong>，成为机器学习和优化问题的基石。</li>
<li>它量化了<strong>模型复杂度</strong>（通过正则化<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，帮助我们构建更健壮的模型。</li>
</ul>
</li>
</ul>
<p>简而言之，没有范数，我们就无法衡量和比较，现代机器学习和许多科学计算领域的大厦都将无从谈起。</p>
<h2 id="eigenvalues-and-eigenvectors">Eigenvalues and Eigenvectors<a class="headerlink" href="#eigenvalues-and-eigenvectors" title="Permanent link">⚓︎</a></h2>
<p><strong>特征值和特征向量</strong></p>
<ul>
<li>如果<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>是一个方阵，那么<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>的<strong>特征多项式</strong><span>(characteristic polynomial)<span class="heti-spacing"> </span></span>为<span><span class="heti-spacing"> </span><span class="arithmatex">\(p(\lambda) = \det (A - \lambda I)\)</span></span></li>
<li>特征方程<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(p(\lambda) = 0\)</span><span class="heti-spacing"> </span></span>的解就是矩阵<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>的<strong>特征值</strong>(eigenvalues)</li>
<li>若存在特征值<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\lambda\)</span><span class="heti-spacing"> </span></span>和向量<span><span class="heti-spacing"> </span><span class="arithmatex">\(\boldsymbol{x} \ne \boldsymbol{0}\)</span></span>，满足<span><span class="heti-spacing"> </span><span class="arithmatex">\((A - \lambda I) \boldsymbol{x} = \boldsymbol{0}\)</span></span>，那么<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\boldsymbol{x}\)</span><span class="heti-spacing"> </span></span>就是<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>的<strong>特征向量</strong>(eigenvector)</li>
</ul>
<p>这么说感觉很抽象（<del>尤其是对笔者这种已经很久没有接触过线性代数题目的人</del><heti-adjacent class="heti-adjacent-half">）</heti-adjacent>。所以建议各位观看<a href="https://www.youtube.com/watch?v=PFDu9oVAE-g&amp;list=PLZHQObOWTQDPD3MizzM2xVFitgF8hE_ab&amp;index=14"><span class="heti-skip"><span class="heti-spacing"> </span>3b1b<span class="heti-spacing"> </span></span>的相关视频</a>，对特征值和特征向量有一个更为直观形象的认识。</p>
<p>矩阵<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>的<strong>谱半径</strong>(spectral radius) <span class="arithmatex">\(\rho(A) = \max{| \lambda |}\)</span>，其中<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\lambda\)</span><span class="heti-spacing"> </span></span>是<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>的特征值（复数范围，所以<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(|\lambda|\)</span><span class="heti-spacing"> </span></span>表示特征值的<strong>模长</strong><heti-adjacent class="heti-adjacent-half">）</heti-adjacent>。</p>
<div style="text-align: center">
<img src="images/C7/1.png" width="50%/"/>
</div>
<p><strong>定理</strong> ：如果<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>是一个<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n \times n\)</span><span class="heti-spacing"> </span></span>的矩阵，那么对于所有的自然范数<span><span class="heti-spacing"> </span><span class="arithmatex">\(\| \cdot \|\)</span></span>，有<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\rho(A) \le \| A \|\)</span><span class="heti-spacing"> </span></span>成立。</p>
<p>若<span><span class="heti-spacing"> </span><span class="arithmatex">\(\forall i, j = 1, 2, \dots, n\)</span></span>，有<span><span class="heti-spacing"> </span><span class="arithmatex">\(\lim\limits_{k \rightarrow \infty} (A^k)_{ij} = 0\)</span></span>，那么称规模为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n \times n\)</span><span class="heti-spacing"> </span></span>的矩阵<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>是<strong>收敛</strong>的。</p>
<h2 id="iterative-techniques-for-solving-linear-systems">Iterative Techniques for Solving Linear Systems<a class="headerlink" href="#iterative-techniques-for-solving-linear-systems" title="Permanent link">⚓︎</a></h2>
<p>当线性方程组维度不高的时候，很少会用到迭代方法，因为迭代方法达到足够精度所需的时间超过用高斯消元法计算的时间。不过在大型的线性方程组，迭代方法在存储和计算上的效率优势会变得更为明显。</p>
<p>下面介绍一些常见的求解线性方程组的迭代方法。</p>
<h3 id="jacobi-iterative-method">Jacobi Iterative Method<a class="headerlink" href="#jacobi-iterative-method" title="Permanent link">⚓︎</a></h3>
<p>对于线性方程组<span><span class="heti-spacing"> </span><span class="arithmatex">\(\begin{cases}a_{11}x_1 + a_{12}x_2 + \dots + a_{1n}x_n = b_1 \\ a_{21}x_1 + a_{22}x_2 + \dots + a_{2n}x_n = b_2 \\ \dots \\ a_{n1}x_1 + a_{n2}x_2 + \dots + a_{nn}x_n = b_n\end{cases}\)</span></span>，当<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(a_{ii} \ne 0\)</span><span class="heti-spacing"> </span></span>时，不难得到：</p>
<div class="arithmatex">\[
\begin{cases}
x_1 = \dfrac{1}{a_{11}}(-a_{12}x_2 - \dots - a_{1n}x_n + b_1) \\ x_2 = \dfrac{1}{a_{22}}(-a_{21}x_1 - \dots - a_{2n}x_n + b_1) \\ x_n = \dfrac{1}{a_{nn}}(-a_{n1}x_1 - \dots - a_{1n, n-1}x_{n-1} + b_n) 
\end{cases}
\]</div>
<p>用矩阵形式表示上述线形方程组，并转化为以下形式：</p>
<div style="text-align: center">
<img src="images/C7/2.png" width="20%/"/>
</div>
<p>那么：</p>
<div class="arithmatex">\[
\begin{align}
A\boldsymbol{x} = \boldsymbol{b} &amp; \Leftrightarrow (D - L - U)\boldsymbol{x} = \boldsymbol{b} \notag \\
&amp; \Leftrightarrow D\boldsymbol{x} = (L + U) \boldsymbol{x} + \boldsymbol{b} \notag \\
&amp; \Leftrightarrow \boldsymbol{x} = \underbrace{D^{-1} (L + U)}_{T_j} \boldsymbol{x} + \underbrace{D^{-1} \boldsymbol{b}}_{\boldsymbol{c_j}} \notag
\end{align}
\]</div>
<p>因此该迭代法的递推公式为：<span class="arithmatex">\(\boldsymbol{x}^{(k)} = T_j \boldsymbol{x}^{(k-1)} + \boldsymbol{c_j}\)</span>，其中<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_j\)</span><span class="heti-spacing"> </span></span>被称为<strong>雅可比迭代矩阵</strong>(Jacobi iterative matrix)。</p>
<blockquote>
<p>看起来矩阵表示更为简洁，但算的时候我们就可以直接用上面给出的线性方程组解来计算（下面给出的算法也正是这么做的<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>。</p>
</blockquote>
<p><strong>算法：雅可比迭代方法</strong></p>
<p>对于给定的初始近似解<span><span class="heti-spacing"> </span><span class="arithmatex">\(\boldsymbol{x}^{(0)}\)</span></span>，求解<span><span class="heti-spacing"> </span><span class="arithmatex">\(A\boldsymbol{x} = \boldsymbol{b}\)</span></span></p>
<ul>
<li>输入：方程和未知数的个数<span><span class="heti-spacing"> </span><span class="arithmatex">\(n\)</span></span>，矩阵元素<span><span class="heti-spacing"> </span><span class="arithmatex">\(a[][]\)</span></span>，常数项<span><span class="heti-spacing"> </span><span class="arithmatex">\(b[]\)</span></span>，初始近似解<span><span class="heti-spacing"> </span><span class="arithmatex">\(X0[]\)</span></span>，容忍值<span><span class="heti-spacing"> </span><span class="arithmatex">\(TOL\)</span></span>，最大迭代次数<span><span class="heti-spacing"> </span><span class="arithmatex">\(N_{max}\)</span></span></li>
<li>输出：近似解<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(X[]\)</span><span class="heti-spacing"> </span></span>或错误信息</li>
</ul>
<div class="language-c highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"><a href="#__codelineno-11-1"> 1</a></span>
<span class="normal"><a href="#__codelineno-11-2"> 2</a></span>
<span class="normal"><a href="#__codelineno-11-3"> 3</a></span>
<span class="normal"><a href="#__codelineno-11-4"> 4</a></span>
<span class="normal"><a href="#__codelineno-11-5"> 5</a></span>
<span class="normal"><a href="#__codelineno-11-6"> 6</a></span>
<span class="normal"><a href="#__codelineno-11-7"> 7</a></span>
<span class="normal"><a href="#__codelineno-11-8"> 8</a></span>
<span class="normal"><a href="#__codelineno-11-9"> 9</a></span>
<span class="normal"><a href="#__codelineno-11-10">10</a></span></pre></div></td><td class="code"><div><pre><span></span><code><span id="__span-11-1"><a id="__codelineno-11-1" name="__codelineno-11-1"></a><span class="n">Step</span><span class="w"> </span><span class="mi">1</span><span class="w">  </span><span class="n">Set</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
</span><span id="__span-11-2"><a id="__codelineno-11-2" name="__codelineno-11-2"></a><span class="n">Step</span><span class="w"> </span><span class="mi">2</span><span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">N_max</span><span class="p">)</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="n">step</span><span class="w"> </span><span class="mi">3-6</span>
</span><span id="__span-11-3"><a id="__codelineno-11-3" name="__codelineno-11-3"></a><span class="w">        </span><span class="n">Step</span><span class="w"> </span><span class="mi">3</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">n</span>
</span><span id="__span-11-4"><a id="__codelineno-11-4" name="__codelineno-11-4"></a><span class="hll"><span class="w">                    </span><span class="n">Set</span><span class="w"> </span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">sum</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="o">!=</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">]))</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">];</span><span class="w">  </span><span class="c1">// compute x^k</span>
</span></span><span id="__span-11-5"><a id="__codelineno-11-5" name="__codelineno-11-5"></a><span class="w">        </span><span class="n">Step</span><span class="w"> </span><span class="mi">4</span><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="n">norm</span><span class="p">(</span><span class="n">X</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">X0</span><span class="p">)</span><span class="n">_infty</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;=</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">X0</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">TOL</span><span class="w"> </span><span class="n">then</span><span class="w"> </span><span class="n">Output</span><span class="p">(</span><span class="n">X</span><span class="p">[]);</span>
</span><span id="__span-11-6"><a id="__codelineno-11-6" name="__codelineno-11-6"></a><span class="w">                </span><span class="n">STOP</span><span class="p">;</span><span class="w">    </span><span class="c1">// successful</span>
</span><span id="__span-11-7"><a id="__codelineno-11-7" name="__codelineno-11-7"></a><span class="hll"><span class="w">        </span><span class="n">Step</span><span class="w"> </span><span class="mi">5</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">n</span><span class="w">  </span><span class="n">Set</span><span class="w"> </span><span class="n">X0</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">X</span><span class="p">[];</span><span class="w">  </span><span class="c1">// update X0</span>
</span></span><span id="__span-11-8"><a id="__codelineno-11-8" name="__codelineno-11-8"></a><span class="w">        </span><span class="n">Step</span><span class="w"> </span><span class="mi">6</span><span class="w">  </span><span class="n">Set</span><span class="w"> </span><span class="n">k</span><span class="o">++</span><span class="p">;</span>
</span><span id="__span-11-9"><a id="__codelineno-11-9" name="__codelineno-11-9"></a><span class="n">Step</span><span class="w"> </span><span class="mi">7</span><span class="w">  </span><span class="n">Output</span><span class="w"> </span><span class="p">(</span><span class="n">Maximum</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">iterations</span><span class="w"> </span><span class="n">exceeded</span><span class="p">);</span>
</span><span id="__span-11-10"><a id="__codelineno-11-10" name="__codelineno-11-10"></a><span class="w">        </span><span class="n">STOP</span><span class="p">.</span><span class="w">    </span><span class="c1">// unsuccessful</span>
</span></code></pre></div></td></tr></table></div>
<p>考虑高亮行：</p>
<ul>
<li>第<span class="heti-skip"><span class="heti-spacing"> </span>4<span class="heti-spacing"> </span></span>行：<code>a[i][i]</code> 有可能为<span><span class="heti-spacing"> </span>0</span>，不过由于在计算过程中不会修改矩阵<span><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span></span>，因此我们可以在计算前为矩阵元素<strong>重新排序</strong>，以保证 <code>a[i][i] != 0</code>。如果无法通过重排避免这一问题，那么矩阵<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>就是<strong>奇异的</strong>。</li>
<li>第<span class="heti-skip"><span class="heti-spacing"> </span>7<span class="heti-spacing"> </span></span>行：<span><span class="arithmatex">\(X^{(k+1)}\)</span><span class="heti-spacing"> </span></span>必须等到<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(X^{(k)}\)</span><span class="heti-spacing"> </span></span>的项全部算出来，因此要用两个向量来存储结果。但这样就有些浪费空间了，因为我们最后只会用到一个向量。</li>
</ul>
<h3 id="gauss-seidel-iterative-method">Gauss-Seidel Iterative Method<a class="headerlink" href="#gauss-seidel-iterative-method" title="Permanent link">⚓︎</a></h3>
<p>观察线性方程组的解：</p>
<div class="arithmatex">\[
\begin{align}
x_2^{(k)} &amp; = \dfrac{1}{a_{22}}(\textcolor{red}{-a_{21}x_1^{(k)}} - a_{23}x_3^{(k-1)} - a_{24}x_4^{(k-1)} - \dots - a_{2n}x_n^{k-1} + b_2) \notag \\ 
x_3^{(k)} &amp; = \dfrac{1}{a_{33}}(\textcolor{red}{-a_{31}x_1^{(k)} - a_{32}x_2^{(k)}} - a_{34}x_4^{(k-1)} - \dots - a_{3n}x_n^{k-1} + b_3) \notag \\ 
\dots \notag \\ 
x_n^{(k)} &amp; = \dfrac{1}{a_{nn}}(\textcolor{red}{-a_{n1}x_1^{(k)} -a_{n2}x_2^{(k)} -a_{n3}x_3^{(k)} - \dots - a_{n, n-1}x_{n-1}^{k}} + b_n) \notag
\end{align}
\]</div>
<p>用矩阵形式表述为：</p>
<div class="arithmatex">\[
\begin{align}
&amp; \boldsymbol{x}^{(k)} = D^{-1} (L\boldsymbol{x}^{(k)} + U\boldsymbol{x}^{(k-1)}) + D^{-1} \boldsymbol{b} \notag \\
\Leftrightarrow &amp; (D - L)\boldsymbol{x}^{(k)} = U\boldsymbol{x}^{(k-1)} + \boldsymbol{b} \notag \\
\Leftrightarrow &amp; \boldsymbol{x}^{(k)} = \underbrace{(D - L)^{-1} U }_{T_g} \boldsymbol{x}^{(k-1)} + \underbrace{(D - L)^{-1}}_{\boldsymbol{c}_g} \boldsymbol{b} \notag
\end{align}
\]</div>
<p>因此该迭代法的递推公式为：<span class="arithmatex">\(\boldsymbol{x}^{(k)} = T_g \boldsymbol{x}^{(k-1)} + c_g \boldsymbol{b}\)</span>，其中<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_g\)</span><span class="heti-spacing"> </span></span>为<strong>高斯<span class="heti-skip"><span class="heti-spacing"> </span>-<span class="heti-spacing"> </span></span>塞德尔迭代矩阵</strong>(Gauss-Seidel iterative matrix)。</p>
<p><strong>算法：高斯<span class="heti-skip"><span class="heti-spacing"> </span>-<span class="heti-spacing"> </span></span>塞德尔迭代方法</strong></p>
<p>对于给定的初始近似解<span><span class="heti-spacing"> </span><span class="arithmatex">\(\boldsymbol{x}^{(0)}\)</span></span>，求解<span><span class="heti-spacing"> </span><span class="arithmatex">\(A\boldsymbol{x} = \boldsymbol{b}\)</span></span></p>
<ul>
<li>输入：方程和未知数的个数<span><span class="heti-spacing"> </span><span class="arithmatex">\(n\)</span></span>，矩阵元素<span><span class="heti-spacing"> </span><span class="arithmatex">\(a[][]\)</span></span>，常数项<span><span class="heti-spacing"> </span><span class="arithmatex">\(b[]\)</span></span>，初始近似解<span><span class="heti-spacing"> </span><span class="arithmatex">\(X0[]\)</span></span>，容忍值<span><span class="heti-spacing"> </span><span class="arithmatex">\(TOL\)</span></span>，最大迭代次数<span><span class="heti-spacing"> </span><span class="arithmatex">\(N_{max}\)</span></span></li>
<li>输出：近似解<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(X[]\)</span><span class="heti-spacing"> </span></span>或错误信息</li>
</ul>
<div class="language-c highlight"><pre><span></span><code><span id="__span-12-1"><a href="#__codelineno-12-1" id="__codelineno-12-1" name="__codelineno-12-1"></a><span class="n">Step</span><span class="w"> </span><span class="mi">1</span><span class="w">  </span><span class="n">Set</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
</span><span id="__span-12-2"><a href="#__codelineno-12-2" id="__codelineno-12-2" name="__codelineno-12-2"></a><span class="n">Step</span><span class="w"> </span><span class="mi">2</span><span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">N_max</span><span class="p">)</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="n">step</span><span class="w"> </span><span class="mi">3-6</span>
</span><span id="__span-12-3"><a href="#__codelineno-12-3" id="__codelineno-12-3" name="__codelineno-12-3"></a><span class="w">        </span><span class="n">Step</span><span class="w"> </span><span class="mi">3</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">n</span>
</span><span id="__span-12-4"><a href="#__codelineno-12-4" id="__codelineno-12-4" name="__codelineno-12-4"></a><span class="w">                    </span><span class="n">Set</span><span class="w"> </span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="o">-</span><span class="n">sum</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">sum</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">X0</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">];</span><span class="w">  </span><span class="c1">// compute x^k</span>
</span><span id="__span-12-5"><a href="#__codelineno-12-5" id="__codelineno-12-5" name="__codelineno-12-5"></a><span class="w">        </span><span class="n">Step</span><span class="w"> </span><span class="mi">4</span><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="n">norm</span><span class="p">(</span><span class="n">X</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">X0</span><span class="p">)</span><span class="n">_infty</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;=</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">X0</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">TOL</span><span class="w"> </span><span class="n">then</span><span class="w"> </span><span class="n">Output</span><span class="p">(</span><span class="n">X</span><span class="p">[]);</span>
</span><span id="__span-12-6"><a href="#__codelineno-12-6" id="__codelineno-12-6" name="__codelineno-12-6"></a><span class="w">                </span><span class="n">STOP</span><span class="p">;</span><span class="w">    </span><span class="c1">// successful</span>
</span><span id="__span-12-7"><a href="#__codelineno-12-7" id="__codelineno-12-7" name="__codelineno-12-7"></a><span class="w">        </span><span class="n">Step</span><span class="w"> </span><span class="mi">5</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">n</span><span class="w">  </span><span class="n">Set</span><span class="w"> </span><span class="n">X0</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">X</span><span class="p">[];</span><span class="w">  </span><span class="c1">// update X0</span>
</span><span id="__span-12-8"><a href="#__codelineno-12-8" id="__codelineno-12-8" name="__codelineno-12-8"></a><span class="w">        </span><span class="n">Step</span><span class="w"> </span><span class="mi">6</span><span class="w">  </span><span class="n">Set</span><span class="w"> </span><span class="n">k</span><span class="o">++</span><span class="p">;</span>
</span><span id="__span-12-9"><a href="#__codelineno-12-9" id="__codelineno-12-9" name="__codelineno-12-9"></a><span class="n">Step</span><span class="w"> </span><span class="mi">7</span><span class="w">  </span><span class="n">Output</span><span class="w"> </span><span class="p">(</span><span class="n">Maximum</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">iterations</span><span class="w"> </span><span class="n">exceeded</span><span class="p">);</span>
</span><span id="__span-12-10"><a href="#__codelineno-12-10" id="__codelineno-12-10" name="__codelineno-12-10"></a><span class="w">        </span><span class="n">STOP</span><span class="p">.</span><span class="w">    </span><span class="c1">// unsuccessful</span>
</span></code></pre></div>
<p><strong>注</strong> ：上述两种迭代方法<strong>不总是收敛的</strong>。并且存在雅可比迭代法失败，但高斯<span class="heti-skip"><span class="heti-spacing"> </span>-<span class="heti-spacing"> </span></span>塞德尔迭代法成功的情况，反之亦然。</p>
<p><strong>雅可比迭代法<span class="heti-skip"><span class="heti-spacing"> </span>v.s.<span class="heti-spacing"> </span></span>高斯<span class="heti-skip"><span class="heti-spacing"> </span>-<span class="heti-spacing"> </span></span>塞德尔迭代法（by Gemini 2.5 Flash）</strong></p>
<table>
<thead>
<tr>
<th style="text-align: left;">特性</th>
<th style="text-align: left;">雅可比迭代法<span><span class="heti-spacing"> </span>(Jacobi Iteration)</span></th>
<th style="text-align: left;">高斯<span class="heti-skip"><span class="heti-spacing"> </span>-<span class="heti-spacing"> </span></span>塞德尔迭代法<span><span class="heti-spacing"> </span>(Gauss-Seidel Iteration)</span></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>信息利用</strong></td>
<td style="text-align: left;">计算<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(x_i^{(k+1)}\)</span><span class="heti-spacing"> </span></span>时，完全使用<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(x^{(k)}\)</span><span class="heti-spacing"> </span></span>的所有分量。</td>
<td style="text-align: left;">计算<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(x_i^{(k+1)}\)</span><span class="heti-spacing"> </span></span>时，使用<span><span class="heti-spacing"> </span><span class="arithmatex">\(x_1^{(k+1)}, \dots, x_{i-1}^{(k+1)}\)</span></span>（最新值）和<span><span class="heti-spacing"> </span><span class="arithmatex">\(x_{i+1}^{(k)}, \dots, x_n^{(k)}\)</span></span>（旧值<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>。</td>
</tr>
<tr>
<td style="text-align: left;"><strong>收敛速度</strong></td>
<td style="text-align: left;">通常比高斯<span class="heti-skip"><span class="heti-spacing"> </span>-<span class="heti-spacing"> </span></span>塞德尔慢。</td>
<td style="text-align: left;">通常比雅可比快（如果收敛的话<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>。</td>
</tr>
<tr>
<td style="text-align: left;"><strong>收敛条件</strong></td>
<td style="text-align: left;">迭代矩阵<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(B_J = -D^{-1}(L+U)\)</span><span class="heti-spacing"> </span></span>的谱半径<span><span class="heti-spacing"> </span><span class="arithmatex">\(\rho(B_J) &lt; 1\)</span></span>。</td>
<td style="text-align: left;">迭代矩阵<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(B_{GS} = -(D+L)^{-1}U\)</span><span class="heti-spacing"> </span></span>的谱半径<span><span class="heti-spacing"> </span><span class="arithmatex">\(\rho(B_{GS}) &lt; 1\)</span></span>。</td>
</tr>
<tr>
<td style="text-align: left;"><strong>并行性</strong></td>
<td style="text-align: left;"><strong>易于并行化</strong>，因为每个分量的计算是独立的。</td>
<td style="text-align: left;"><strong>难以并行化</strong>，因为每个分量的计算依赖于前一个分量的最新值。</td>
</tr>
<tr>
<td style="text-align: left;"><strong>内存需求</strong></td>
<td style="text-align: left;">需要存储<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(x^{(k)}\)</span><span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(x^{(k+1)}\)</span><span class="heti-spacing"> </span></span>两套向量。</td>
<td style="text-align: left;">可以在原地更新，只需要存储一套向量（但实际实现可能仍用两套<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>。</td>
</tr>
<tr>
<td style="text-align: left;"><strong>实现复杂度</strong></td>
<td style="text-align: left;">相对简单。</td>
<td style="text-align: left;">略复杂，需要注意更新顺序。</td>
</tr>
<tr>
<td style="text-align: left;"><strong>适用矩阵</strong></td>
<td style="text-align: left;">对角占优矩阵（严格对角占优或不可约对角占优）保证收敛。</td>
<td style="text-align: left;">对角占优矩阵（严格对角占优或不可约对角占优）保证收敛。对于对称正定矩阵，高斯<span class="heti-skip"><span class="heti-spacing"> </span>-<span class="heti-spacing"> </span></span>塞德尔也保证收敛。</td>
</tr>
<tr>
<td style="text-align: left;"><strong>鲁棒性</strong></td>
<td style="text-align: left;">相对较差，有时会发散。</td>
<td style="text-align: left;">相对较好，通常比雅可比更稳定。</td>
</tr>
</tbody>
</table>
<h3 id="convergence-of-iterative-method">Convergence of Iterative Method<a class="headerlink" href="#convergence-of-iterative-method" title="Permanent link">⚓︎</a></h3>
<p>现在我们来考察迭代法<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\boldsymbol{x}^{(k)} = T\boldsymbol{x}^{(k-1)} + \boldsymbol{c}\)</span><span class="heti-spacing"> </span></span>的收敛性。</p>
<p><strong>定理</strong></p>
<p>以下语句是等价的：</p>
<ul>
<li><span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>是一个收敛矩阵</li>
<li>对于<u>某些</u>自然范数，<span class="arithmatex">\(\lim\limits_{n \rightarrow \infty} \| A^n \| = 0\)</span></li>
<li>对于<u>所有</u>自然范数，<span class="arithmatex">\(\lim\limits_{n \rightarrow \infty} \| A^n \| = 0\)</span></li>
<li><span class="arithmatex">\(\textcolor{red}{\rho(A) &lt; 1}\)</span>（比较常用）</li>
<li><span class="arithmatex">\(\forall \boldsymbol{x},\ \lim\limits_{n \rightarrow \infty} A^n \boldsymbol{x} = \boldsymbol{0}\)</span></li>
</ul>
<p><strong>一些补充说明（主要针对第<span class="heti-skip"><span class="heti-spacing"> </span>4<span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span>5<span class="heti-spacing"> </span></span>点）</strong></p>
<div class="arithmatex">\[
\textcolor{red}{\boldsymbol{e}^{(k)}} = \boldsymbol{x^{(k)}} - \boldsymbol{x^*} = (T\boldsymbol{x^{(k-1)}} + \boldsymbol{c}) - (T\boldsymbol{x^*} + \boldsymbol{c}) = T(\boldsymbol{x}^{(k-1)} - \boldsymbol{x^*}) = \textcolor{red}{T \boldsymbol{e^{(k-1)}}}
\]</div>
<p>根据上述递推式，可以得到<span><span class="heti-spacing"> </span><span class="arithmatex">\(\boldsymbol{e^{(k)}} = T^k \boldsymbol{e^{(0)}}\)</span></span>，因此 </p>
<div class="arithmatex">\[
\|\boldsymbol{e^{(k)}}\| \le \| T \| \cdot \| \boldsymbol{e^{(k-1)}} \| \le \dots \le \| T \|^k \cdot \| \boldsymbol{e^{(0)}} \|
\]</div>
<ul>
<li>充分条件：<span class="arithmatex">\(\|T\| &lt; 1\ \Rightarrow\ \|T\|^k \rightarrow 0\ \text{as}\ k \rightarrow \infty\)</span></li>
<li>必要条件：<span class="arithmatex">\(\boldsymbol{e^{(k)}} \rightarrow \boldsymbol{0}\ \text{as}\ k \rightarrow \infty\ \Rightarrow T^k \rightarrow O\)</span></li>
</ul>
<p><strong>定理</strong> ：<span class="arithmatex">\(\forall \boldsymbol{x^{(0)}} \in R^n\)</span>，由<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\boldsymbol{x}^{(k)} = T\boldsymbol{x}^{(k-1)} + \boldsymbol{c}\ (k \ge 1)\)</span><span class="heti-spacing"> </span></span>定义的序列<span><span class="heti-spacing"> </span><span class="arithmatex">\(\{ \boldsymbol{x^{(k)}} \}_{k=0}^\infty\)</span></span>，当且仅当<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\textcolor{red}{\rho(T) &lt; 1}\)</span><span class="heti-spacing"> </span></span>时，会收敛到<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\boldsymbol{x} = T\boldsymbol{x} + \boldsymbol{c}\)</span><span class="heti-spacing"> </span></span>的唯一解。</p>
<blockquote>
<p>可以把这个定理看作是<a href="2.html#fixed-point-iteration"><strong>不动点定理</strong></a>在矩阵中的应用。</p>
</blockquote>
<p><strong>定理</strong></p>
<p>对于任意满足<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\|T\| &lt; 1\)</span><span class="heti-spacing"> </span></span>的自然矩阵以及给定的向量<span><span class="heti-spacing"> </span><span class="arithmatex">\(\boldsymbol{c}\)</span></span>，那么<span><span class="heti-spacing"> </span><span class="arithmatex">\(\forall \boldsymbol{x^{(0)}} \in R^n\)</span></span>，由<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\boldsymbol{x}^{(k)} = T\boldsymbol{x}^{(k-1)} + \boldsymbol{c}\)</span><span class="heti-spacing"> </span></span>定义的序列<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\{ \boldsymbol{x^{(k)}} \}_{k=0}^\infty\)</span><span class="heti-spacing"> </span></span>会收敛到向量<span><span class="heti-spacing"> </span><span class="arithmatex">\(\boldsymbol{x} \in R^n\)</span></span>，并且由以下误差边界：</p>
<ul>
<li>
<p><span class="arithmatex">\(\| \boldsymbol{x} - \boldsymbol{x^{(k)}}\| \le \|T\|^k \| \boldsymbol{x} - \boldsymbol{x^{0}}\|\)</span></p>
<ul>
<li><span class="arithmatex">\(\| \boldsymbol{x} - \boldsymbol{x^{(k)}}\| \approx \rho(T)^k \| \boldsymbol{x} - \boldsymbol{x^{0}}\|\)</span>。因此，<strong>谱半径越小，迭代法的收敛速度越快</strong></li>
</ul>
</li>
<li>
<p><span class="arithmatex">\(\| \boldsymbol{x} - \boldsymbol{x^{(k)}}\| \le \dfrac{\|T\|^k}{1 - \|T\|} \| \boldsymbol{x^{(1)}} - \boldsymbol{x^{0}}\|\)</span></p>
</li>
</ul>
<blockquote>
<p>该定理同样对应“<a href="2.html#fixed-point-iteration">不动点定理</a>”一节中给出的那<span class="heti-skip"><span class="heti-spacing"> </span>2<span class="heti-spacing"> </span></span>个不等式推论</p>
</blockquote>
<p><strong>定理</strong> ：如果<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>是一个严格对角占优矩阵，那么对于任意选择的初始近似解<span><span class="heti-spacing"> </span><span class="arithmatex">\(\boldsymbol{x^{(0)}}\)</span></span>，无论使用雅可比方法还是高斯<span class="heti-skip"><span class="heti-spacing"> </span>-<span class="heti-spacing"> </span></span>塞德尔方法，都可以让序列<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\{ \boldsymbol{x^{(k)}} \}_{k=0}^\infty\)</span><span class="heti-spacing"> </span></span>收敛到<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\boldsymbol{x} = \boldsymbol{b}\)</span><span class="heti-spacing"> </span></span>的唯一解。</p>
<blockquote>
<p>只需证明<span><span class="heti-spacing"> </span><span class="arithmatex">\(\forall |\lambda| \ge 1\)</span></span>，有<span><span class="heti-spacing"> </span><span class="arithmatex">\(|\lambda I - T| \ne 0\)</span></span>。也就是说，<span><span class="arithmatex">\(\lambda\)</span><span class="heti-spacing"> </span></span>不能称为对应迭代矩阵<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T\)</span><span class="heti-spacing"> </span></span>的特征值。</p>
</blockquote>
<h3 id="relaxation-methods">Relaxation Methods<a class="headerlink" href="#relaxation-methods" title="Permanent link">⚓︎</a></h3>
<p><strong>残差向量</strong> ：假设<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\widetilde{\boldsymbol{x}} \in \mathbb{R}^n\)</span><span class="heti-spacing"> </span></span>是线性方程组<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A \boldsymbol{x} = \boldsymbol{b}\)</span><span class="heti-spacing"> </span></span>的近似解，那么关于该线性方程组的<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\widetilde{\boldsymbol{x}}\)</span><span class="heti-spacing"> </span></span>的<strong>残差向量</strong><span>(residual vector)<span class="heti-spacing"> </span></span>为<span><span class="heti-spacing"> </span><span class="arithmatex">\(\boldsymbol{r} = \boldsymbol{b} - A \widetilde{\boldsymbol{x}}\)</span></span></p>
<p>接下来我们从残差向量的角度审视高斯<span class="heti-skip"><span class="heti-spacing"> </span>-<span class="heti-spacing"> </span></span>塞德尔方法：</p>
<div class="arithmatex">\[
\begin{align}
x_i^{(k)} &amp; = \dfrac{1}{a_{ii}} \Big[ b_i - \sum\limits_{j=1}^{i-1} a_{ij} x_i^{(k)} - \sum\limits_{j=i+1}^n a_{ij} x_j^{(k-1)} \Big] \notag \\
&amp; = x_i^{(k-1)} + \dfrac{r_i^{(k)}}{a_{ii}} \quad \text{ where } r_i^{(k)} = b_i - \sum\limits_{j &lt; i} a_{ij} x_j^{(k)} - \sum\limits_{j \ge i} a_{ij} x_j^{(k-1)} \notag
\end{align}
\]</div>
<p>令<span><span class="heti-spacing"> </span><span class="arithmatex">\(x_i^{(k)} = x_i^{(k-1)} + \textcolor{red}{\omega} \dfrac{r_i^{(k)}}{a_{ii}}\)</span></span>。对于正数<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\omega\)</span><span class="heti-spacing"> </span></span>的某种选择，我们能够减少残差向量<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\boldsymbol{r}\)</span><span class="heti-spacing"> </span></span>的范数，并且得到更快的收敛。这样的方法称为<strong>松弛法</strong>(relaxation methods)。根据<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\omega\)</span><span class="heti-spacing"> </span></span>的大小，我们有以下几类松弛法：</p>
<ul>
<li><span class="arithmatex">\(0 &lt; \omega &lt; 1\)</span>：<strong>欠松弛法</strong>(under-relaxation methods)</li>
<li><span class="arithmatex">\(\omega = 1\)</span>：<strong>高斯<span class="heti-skip"><span class="heti-spacing"> </span>-<span class="heti-spacing"> </span></span>塞德尔方法</strong></li>
<li><span class="arithmatex">\(\omega &gt; 1\)</span>：<strong>逐次超松弛法</strong>(successive over-relaxation methods, <strong>SOR</strong>)</li>
<li>通常能加速收敛，这就是“超松弛”的由来——它“超前”地调整了更新方向，使得迭代步长更大，更快地逼近真实解</li>
</ul>
<p>用矩阵形式可以表述为：</p>
<div class="arithmatex">\[
\begin{align}
x_i^{(k)} &amp; = x_i^{(k-1)} + \omega \dfrac{r_i^{(k)}}{a_{ii}} = (1 - \omega)x_i^{(k-1)} + \dfrac{\omega}{a_{ii}} \Big[ -\sum\limits_{j&lt;i} a_{ij} x_j^{(k)} - \sum\limits_{j&gt;i} a_{ij} x_j^{k-1} + b_i \Big] \notag \\
&amp; \Rightarrow\ \boldsymbol{x^{(k)}} = (1 - \omega) \boldsymbol{x^{(k-1)}} + \omega D^{-1} [L \boldsymbol{x^{(k)}} + U \boldsymbol{x^{(k-1)}} + \boldsymbol{b}] \notag \\
&amp; \Rightarrow\ \underbrace{(D - \omega L)^{-1} [(1 - \omega) D + \omega U]}_{T_{\omega}} \boldsymbol{x}^{(k-1)} + \underbrace{(D - \omega L)^{-1} \omega}_{\boldsymbol{c_\omega}} \boldsymbol{b} \notag
\end{align}
\]</div>
<p>也就是说，<span>SOR<span class="heti-spacing"> </span></span>迭代法的递推公式为：<span class="arithmatex">\(\boldsymbol{x}^{(k)} = T_\omega \boldsymbol{x}^{(k-1)} + \boldsymbol{c}_\omega \boldsymbol{b}\)</span>。</p>
<p>显然，矩阵<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_\omega\)</span><span class="heti-spacing"> </span></span>的表示过于复杂，因而很难准确得到它的谱半径。但好在我们还可以走以下“捷径”，有助于我们选择合适的<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\omega\)</span><span class="heti-spacing"> </span></span>值。</p>
<p><strong>一些定理</strong></p>
<p>定理<span><span class="heti-spacing"> </span>1</span>：<strong><span>Kahan<span class="heti-spacing"> </span></span>定理</strong> ：若<span><span class="heti-spacing"> </span><span class="arithmatex">\(a_{ii} \ne 0\ (i = 1, 2, \dots, n)\)</span></span>，那么<span><span class="heti-spacing"> </span><span class="arithmatex">\(\rho(T_\omega) \ge |\omega - 1|\)</span></span>，这也就意味着<span class="heti-skip"><span class="heti-spacing"> </span>SOR<span class="heti-spacing"> </span></span>方法仅在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(0 &lt; \omega &lt; 2\)</span><span class="heti-spacing"> </span></span>时收敛。</p>
<p>定理<span><span class="heti-spacing"> </span>2</span>：<strong><span>Ostrowski-Reich<span class="heti-spacing"> </span></span>定理</strong> ：若<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>是<strong>正定</strong>矩阵且<span><span class="heti-spacing"> </span><span class="arithmatex">\(0 &lt; \omega &lt; 2\)</span></span>，那么<span class="heti-skip"><span class="heti-spacing"> </span>SOR<span class="heti-spacing"> </span></span>方法对于任意初始近似解均能收敛。</p>
<p>定理<span><span class="heti-spacing"> </span>3</span>：如果<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>是<strong>正定</strong>的<strong>三对角线</strong>矩阵，那么<span><span class="heti-spacing"> </span><span class="arithmatex">\(\rho(T_g) = |\rho(T_j)|^2 &lt; 1\)</span></span>，且<span class="heti-skip"><span class="heti-spacing"> </span>SOR<span class="heti-spacing"> </span></span>方法中<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\omega\)</span><span class="heti-spacing"> </span></span>的最优选择是<span><span class="heti-spacing"> </span><span class="arithmatex">\(\omega = \dfrac{2}{1 + \sqrt{1 - |[\rho(T_j)]^2|}}\)</span></span>，此时<span><span class="heti-spacing"> </span><span class="arithmatex">\(\rho(T_\omega) = \omega - 1\)</span></span>。</p>
<p><strong>讨论</strong></p>
<p>题目：给定<span><span class="heti-spacing"> </span><span class="arithmatex">\(A = \begin{bmatrix}2 &amp; 1 \\ 1 &amp; 2\end{bmatrix}, \boldsymbol{b} = \begin{bmatrix}1 \\ 2\end{bmatrix}\)</span></span>，以及迭代法<span><span class="heti-spacing"> </span><span class="arithmatex">\(\boldsymbol{x^{(k)}} = \boldsymbol{x^{(k-1)}} + \omega (A\boldsymbol{x^{(k-1)}} - \boldsymbol{b})\)</span></span>，那么：</p>
<ul>
<li>当<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\omega\)</span><span class="heti-spacing"> </span></span>取什么值时，该方法会收敛？</li>
<li>当<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\omega\)</span><span class="heti-spacing"> </span></span>取什么值时，该方法的收敛速度最快？</li>
</ul>
<p>解答：</p>
<p>考虑<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T = I + \omega A\)</span><span class="heti-spacing"> </span></span>的特征值，解得<span><span class="heti-spacing"> </span><span class="arithmatex">\(\lambda_1 = 1 + \omega, \lambda_2 = 1 + 3 \omega\)</span></span></p>
<ul>
<li>要使该方法收敛，需满足<span><span class="heti-spacing"> </span><span class="arithmatex">\(\rho(T) &lt; 1 \quad \Rightarrow -\dfrac{2}{3} &lt; \omega &lt; 0\)</span></span></li>
<li>现在考虑<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\rho(T) = \max\{|1 + \omega|, |1 + 3\omega|\}\)</span><span class="heti-spacing"> </span></span>在何时取最小值（即收敛速度最快的时候）——我们可以画图研究：</li>
</ul>
<div style="text-align: center">
<img src="images/C7/3.png" width="40%/"/>
</div>
<p>发现当<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\omega = -\dfrac{1}{2}\)</span><span class="heti-spacing"> </span></span>时取值最小。</p>
<p><strong>算法：<span>SOR<span class="heti-spacing"> </span></span>迭代法</strong></p>
<p>对于给定的初始近似解<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\boldsymbol{x}^{(0)}\)</span><span class="heti-spacing"> </span></span>和参数<span><span class="heti-spacing"> </span><span class="arithmatex">\(\omega\)</span></span>，求解<span><span class="heti-spacing"> </span><span class="arithmatex">\(A\boldsymbol{x} = \boldsymbol{b}\)</span></span></p>
<ul>
<li>输入：方程和未知数的个数<span><span class="heti-spacing"> </span><span class="arithmatex">\(n\)</span></span>，矩阵元素<span><span class="heti-spacing"> </span><span class="arithmatex">\(a[][]\)</span></span>，常数项<span><span class="heti-spacing"> </span><span class="arithmatex">\(b[]\)</span></span>，初始近似解<span><span class="heti-spacing"> </span><span class="arithmatex">\(X0[]\)</span></span>，参数<span><span class="heti-spacing"> </span><span class="arithmatex">\(\omega\)</span></span>，容忍值<span><span class="heti-spacing"> </span><span class="arithmatex">\(TOL\)</span></span>，最大迭代次数<span><span class="heti-spacing"> </span><span class="arithmatex">\(N_{max}\)</span></span></li>
<li>输出：近似解<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(X[]\)</span><span class="heti-spacing"> </span></span>或错误信息</li>
</ul>
<div class="language-c highlight"><pre><span></span><code><span id="__span-13-1"><a href="#__codelineno-13-1" id="__codelineno-13-1" name="__codelineno-13-1"></a><span class="n">Step</span><span class="w"> </span><span class="mi">1</span><span class="w">  </span><span class="n">Set</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
</span><span id="__span-13-2"><a href="#__codelineno-13-2" id="__codelineno-13-2" name="__codelineno-13-2"></a><span class="n">Step</span><span class="w"> </span><span class="mi">2</span><span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">N_max</span><span class="p">)</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="n">step</span><span class="w"> </span><span class="mi">3-6</span>
</span><span id="__span-13-3"><a href="#__codelineno-13-3" id="__codelineno-13-3" name="__codelineno-13-3"></a><span class="w">        </span><span class="n">Step</span><span class="w"> </span><span class="mi">3</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">n</span>
</span><span id="__span-13-4"><a href="#__codelineno-13-4" id="__codelineno-13-4" name="__codelineno-13-4"></a><span class="w">                    </span><span class="n">Set</span><span class="w"> </span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">omega</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">X0</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">omega</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="o">-</span><span class="n">sum</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">sum</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">X0</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="w">  </span><span class="c1">// compute x^k</span>
</span><span id="__span-13-5"><a href="#__codelineno-13-5" id="__codelineno-13-5" name="__codelineno-13-5"></a><span class="w">        </span><span class="n">Step</span><span class="w"> </span><span class="mi">4</span><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="n">norm</span><span class="p">(</span><span class="n">X</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">X0</span><span class="p">)</span><span class="n">_infty</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">max</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;=</span><span class="n">i</span><span class="o">&lt;=</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">X0</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">TOL</span><span class="w"> </span><span class="n">then</span><span class="w"> </span><span class="n">Output</span><span class="p">(</span><span class="n">X</span><span class="p">[]);</span>
</span><span id="__span-13-6"><a href="#__codelineno-13-6" id="__codelineno-13-6" name="__codelineno-13-6"></a><span class="w">                </span><span class="n">STOP</span><span class="p">;</span><span class="w">    </span><span class="c1">// successful</span>
</span><span id="__span-13-7"><a href="#__codelineno-13-7" id="__codelineno-13-7" name="__codelineno-13-7"></a><span class="w">        </span><span class="n">Step</span><span class="w"> </span><span class="mi">5</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">n</span><span class="w">  </span><span class="n">Set</span><span class="w"> </span><span class="n">X0</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">X</span><span class="p">[];</span><span class="w">  </span><span class="c1">// update X0</span>
</span><span id="__span-13-8"><a href="#__codelineno-13-8" id="__codelineno-13-8" name="__codelineno-13-8"></a><span class="w">        </span><span class="n">Step</span><span class="w"> </span><span class="mi">6</span><span class="w">  </span><span class="n">Set</span><span class="w"> </span><span class="n">k</span><span class="o">++</span><span class="p">;</span>
</span><span id="__span-13-9"><a href="#__codelineno-13-9" id="__codelineno-13-9" name="__codelineno-13-9"></a><span class="n">Step</span><span class="w"> </span><span class="mi">7</span><span class="w">  </span><span class="n">Output</span><span class="w"> </span><span class="p">(</span><span class="n">Maximum</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">iterations</span><span class="w"> </span><span class="n">exceeded</span><span class="p">);</span>
</span><span id="__span-13-10"><a href="#__codelineno-13-10" id="__codelineno-13-10" name="__codelineno-13-10"></a><span class="w">        </span><span class="n">STOP</span><span class="p">.</span><span class="w">    </span><span class="c1">// unsuccessful</span>
</span></code></pre></div>
<h2 id="error-bounds-and-iterative-refinement">Error Bounds and Iterative Refinement<a class="headerlink" href="#error-bounds-and-iterative-refinement" title="Permanent link">⚓︎</a></h2>
<p>目标：研究<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\boldsymbol{b}\)</span><span class="heti-spacing"> </span></span>的误差会如何影响<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A \boldsymbol{x} = \boldsymbol{b}\)</span><span class="heti-spacing"> </span></span>的解<span><span class="heti-spacing"> </span><span class="arithmatex">\(\boldsymbol{x}\)</span></span>？</p>
<p>假设<u><span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>是准确的，<span><span class="arithmatex">\(\boldsymbol{b}\)</span><span class="heti-spacing"> </span></span>有误差<span><span class="heti-spacing"> </span><span class="arithmatex">\(\delta \boldsymbol{b}\)</span></span></u>，那么带有误差的解可以写成<span><span class="heti-spacing"> </span><span class="arithmatex">\(\boldsymbol{x} + \delta \boldsymbol{x}\)</span></span>。可以得到：</p>
<div class="arithmatex">\[
A (\boldsymbol{x} + \delta \boldsymbol{x}) = \boldsymbol{b} + \delta \boldsymbol{b} \Rightarrow \dfrac{\| \delta \boldsymbol{x} \|}{\| \boldsymbol{x} \|} \le \| A \| \cdot \| A^{-1} \| \cdot \dfrac{\| \delta \boldsymbol{b} \|}{\| \boldsymbol{b} \|}
\]</div>
<p>其中<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\| A \| \cdot \| A^{-1} \|\)</span><span class="heti-spacing"> </span></span>被称为<strong>相对放大因子</strong>(relative amplification factor)。</p>
<p><strong>定理</strong></p>
<p>如果矩阵<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(B\)</span><span class="heti-spacing"> </span></span>在某些自然范数上满足<span><span class="heti-spacing"> </span><span class="arithmatex">\(\| B \| &lt; 1\)</span></span>，那么：</p>
<ul>
<li><span><span class="arithmatex">\(I \pm B\)</span><span class="heti-spacing"> </span></span>是非奇异的</li>
<li><span class="arithmatex">\(\| (I \pm B)^{-1} \| \le \dfrac{1}{1 - \| B \|}\)</span></li>
</ul>
<hr/>
<p>假如<u><span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\boldsymbol{b}\)</span><span class="heti-spacing"> </span></span>是准确的，<span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>有误差<span><span class="heti-spacing"> </span><span class="arithmatex">\(\delta A\)</span></span></u>，那么带有误差的解可以写成<span><span class="heti-spacing"> </span><span class="arithmatex">\(\boldsymbol{x} + \delta \boldsymbol{x}\)</span></span>。可以得到：</p>
<div class="arithmatex">\[
\begin{align}
&amp; (A + \delta A) (\boldsymbol{x} + \delta \boldsymbol{x}) = \boldsymbol{b} \notag \\
\Rightarrow &amp; \dfrac{\| \delta \boldsymbol{x} \|}{\| \boldsymbol{x} \|} \le \dfrac{\| A^{-1} \| \cdot \| \delta A \|}{1 - \| A^{-1} \| \cdot \| \delta A \|} = \dfrac{\| A^{-1} \| \cdot \| A \| \cdot \frac{\| \delta A \|}{\| A \|}}{1 - \| A^{-1} \| \cdot \| A \| \cdot \frac{\| \delta A \|}{\| A \|}} \notag
\end{align}
\]</div>
<p>其中<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\| A \| \cdot \| A^{-1} \|\)</span><span class="heti-spacing"> </span></span>是误差放大的关键因子，被称为<strong>条件数</strong>(condition number)，记作<span><span class="heti-spacing"> </span><span class="arithmatex">\(K(A)\)</span></span>。</p>
<ul>
<li>如果<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(K(A)\)</span><span class="heti-spacing"> </span></span>接近<span><span class="heti-spacing"> </span>1</span>，那么矩阵<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>是<strong>良态的</strong>(well-conditioned)</li>
<li>如果<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(K(A)\)</span><span class="heti-spacing"> </span></span>比远大于<span><span class="heti-spacing"> </span>1</span>，那么矩阵<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>是<strong>病态的</strong>(ill-conditioned)</li>
</ul>
<p><strong>定理</strong></p>
<p>假设<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>是非奇异的，且<span><span class="heti-spacing"> </span><span class="arithmatex">\(\| \delta A \| &lt; \dfrac{1}{\| A^{-1} \|}\)</span></span>。那么<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\((A + \delta A) (\boldsymbol{x} + \delta \boldsymbol{x}) = \boldsymbol{b} + \delta \boldsymbol{b}\)</span><span class="heti-spacing"> </span></span>的解<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\boldsymbol{x} + \delta \boldsymbol{x}\)</span><span class="heti-spacing"> </span></span>近似于<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A \boldsymbol{x} = \boldsymbol{b}\)</span><span class="heti-spacing"> </span></span>的解<span><span class="heti-spacing"> </span><span class="arithmatex">\(\boldsymbol{x}\)</span></span><heti-adjacent class="heti-adjacent-half">，</heti-adjacent>（相对）误差为：</p>
<div class="arithmatex">\[
\dfrac{\| \delta \boldsymbol{x} \|}{\| \boldsymbol{x} \|} \le \dfrac{K(A)}{1 - K(A) \frac{\| \delta A\|}{\| A \|}} \Big(\dfrac{\| \delta A \|}{\| A \|} + \dfrac{\| \delta \boldsymbol{b} \|}{\| \boldsymbol{b} \|} \Big)
\]</div>
<p><strong>注</strong></p>
<blockquote>
<p>条件数<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(K(A)_i\)</span><span class="heti-spacing"> </span></span>的下标<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(i\)</span><span class="heti-spacing"> </span></span>表示所使用的<a href="#matrix-norms">矩阵范数</a>的类型（比如<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(i=2\)</span><span class="heti-spacing"> </span></span>表示的就是<span class="heti-skip"><span class="heti-spacing"> </span>2-<span class="heti-spacing"> </span></span>范数）</p>
</blockquote>
<ul>
<li>如果<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>是<strong>对称的</strong>，那么<span><span class="heti-spacing"> </span><span class="arithmatex">\(K(A)_2 = \dfrac{\max |\lambda|}{\min |\lambda|}\)</span></span></li>
<li>对于所有自然范数<span><span class="heti-spacing"> </span><span class="arithmatex">\(\| \cdot \|_p\)</span></span>，<span class="arithmatex">\(K(A)_p \ge 1\)</span></li>
<li><span class="arithmatex">\(\forall\ \alpha \in R, K(\alpha A) = K(A)\)</span></li>
<li>如果<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>是正交的（即<span><span class="heti-spacing"> </span><span class="arithmatex">\(A^{-1} = A^T\)</span></span><heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，那么<span><span class="heti-spacing"> </span><span class="arithmatex">\(K(A)_2 = 1\)</span></span></li>
<li>对于所有正交矩阵<span><span class="heti-spacing"> </span><span class="arithmatex">\(R\)</span></span>，<span class="arithmatex">\(K(RA)_2 = K(AR)_2 = K(A)_2\)</span></li>
</ul>
<p><strong>讨论</strong></p>
<p>问题：对于给定的<span><span class="heti-spacing"> </span><span class="arithmatex">\(A = \begin{bmatrix}1 &amp; 0.99 \\ 0.99 &amp; 0.98\end{bmatrix}, \boldsymbol{b} = \begin{bmatrix}1.99 \\ 1.97\end{bmatrix}\)</span></span></p>
<ol>
<li>计算<span><span class="heti-spacing"> </span><span class="arithmatex">\(K(A)_2\)</span></span></li>
<li>给<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\boldsymbol{b}\)</span><span class="heti-spacing"> </span></span>一个很小的扰动<span><span class="heti-spacing"> </span><span class="arithmatex">\(\delta \boldsymbol{b} = \begin{bmatrix}-0.97 \times 10^{-4} \\ 0.106 \times 10^{-3}\end{bmatrix}\)</span></span>，原方程的解会有什么变化？</li>
</ol>
<p>解答：直接从<a href="https://note.jiepeng.tech/CS/NA/Chapter_07/#_9">前辈笔记</a>上<span class="heti-skip"><span class="heti-spacing"> </span>copy<span class="heti-spacing"> </span></span>下来的：</p>
<div style="text-align: center">
<img src="images/C7/5.png" width="60%/"/>
</div>
<div style="text-align: center">
<img src="images/C7/6.png" width="80%/"/>
</div>
<h3 id="iterative-refinement">Iterative Refinement<a class="headerlink" href="#iterative-refinement" title="Permanent link">⚓︎</a></h3>
<p><strong>定理</strong> ：假设<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\boldsymbol{x}^*\)</span><span class="heti-spacing"> </span></span>是<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A \boldsymbol{x} = \boldsymbol{b}\)</span><span class="heti-spacing"> </span></span>的近似解，<span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>是一个非奇异矩阵，<span><span class="arithmatex">\(\boldsymbol{r} = \boldsymbol{b} - A\boldsymbol{x}\)</span><span class="heti-spacing"> </span></span>是<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\boldsymbol{x}^*\)</span><span class="heti-spacing"> </span></span>的残差向量。那么对于任意自然范数，<span class="arithmatex">\(\| \boldsymbol{x} - \boldsymbol{x}^* \| \le \| \boldsymbol{r} \| \cdot \| A^{-1} \|\)</span>。且如果<span><span class="heti-spacing"> </span><span class="arithmatex">\(\boldsymbol{x} \ne \boldsymbol{0}, \boldsymbol{b} \ne \boldsymbol{0}\)</span></span>，那么：</p>
<div class="arithmatex">\[
\dfrac{\| \boldsymbol{x} - \boldsymbol{x}^* \|}{\| \boldsymbol{x} \|} \le K(A) \dfrac{\| \boldsymbol{r} \|}{\| \boldsymbol{b} \|}
\]</div>
<p><strong>迭代优化</strong><span>(iterative refinement)<span class="heti-spacing"> </span></span>的步骤为：</p>
<ol>
<li><span><span class="arithmatex">\(A \boldsymbol{x} = \boldsymbol{b} \Rightarrow\)</span><span class="heti-spacing"> </span></span>近似解<span><span class="heti-spacing"> </span><span class="arithmatex">\(\boldsymbol{x}_1\)</span></span></li>
<li><span class="arithmatex">\(\boldsymbol{r}_1 = \boldsymbol{b} - A \boldsymbol{x}_1\)</span></li>
<li><span class="arithmatex">\(A \boldsymbol{d}_1 = \boldsymbol{r}_1 \Rightarrow \boldsymbol{d}_1\)</span></li>
<li>如果<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\boldsymbol{d}_1\)</span><span class="heti-spacing"> </span></span>是精确的，那么<span><span class="heti-spacing"> </span><span class="arithmatex">\(\boldsymbol{x}_2 = \boldsymbol{x}_1 + A^{-1} (\boldsymbol{b} - A\boldsymbol{x}_1) = A^{-1} \boldsymbol{b}\)</span></span>，<span><span class="arithmatex">\(\boldsymbol{x}_2\)</span><span class="heti-spacing"> </span></span>也是精确的。</li>
<li><span class="arithmatex">\(\boldsymbol{x}_2 = \boldsymbol{x}_1 + \boldsymbol{d}_1\)</span></li>
</ol>
<p>之后重复<span class="heti-skip"><span class="heti-spacing"> </span>2-4<span class="heti-spacing"> </span></span>步。</p>
<p><strong>算法：迭代优化</strong></p>
<div style="text-align: center">
<img src="images/C7/7.png" width="90%/"/>
</div>
<h1 id="chap-9-approximating-eigenvalues">Chap 9: Approximating Eigenvalues<a class="headerlink" href="#chap-9-approximating-eigenvalues" title="Permanent link">⚓︎</a></h1>
<h2 id="the-power-method">The Power Method<a class="headerlink" href="#the-power-method" title="Permanent link">⚓︎</a></h2>
<p><strong>幂法</strong><span>(power method)<span class="heti-spacing"> </span></span>是一种用于计算矩阵的<strong>主特征值</strong>(dominant eigenvalue)（即矩阵中模长最大的特征值，也就是<strong>谱半径</strong> <span class="arithmatex">\(\rho(\lambda)\)</span>）以及对应的特征向量的技术。先来看最一般的幂法：</p>
<h3 id="the-original-method">The Original Method<a class="headerlink" href="#the-original-method" title="Permanent link">⚓︎</a></h3>
<p>假设<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>是一个<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n \times n\)</span><span class="heti-spacing"> </span></span>的矩阵，满足<span><span class="heti-spacing"> </span><span class="arithmatex">\(|\textcolor{red}{\lambda_1}| \textcolor{red}{&gt;} |\lambda_2| \ge \dots \ge |\lambda_n| \ge 0\)</span></span>，且这些特征值对应<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n\)</span><span class="heti-spacing"> </span></span>个线性独立的特征向量。</p>
<p>思路：从任意<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\boldsymbol{x^{(0)}} \ne \boldsymbol{0}\)</span><span class="heti-spacing"> </span></span>以及<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\((\boldsymbol{x^{0}}, \boldsymbol{v_1})\)</span><span class="heti-spacing"> </span></span>出发</p>
<div class="arithmatex">\[
\begin{align}
\boldsymbol{x^{(0)}} &amp; = \sum\limits_{j=1}^n \beta_j \boldsymbol{v_j}, \beta_1 \ne 0 \notag \\
\boldsymbol{x^{(1)}} &amp; = A\boldsymbol{x^{(0)}} = \sum\limits_{j=1}^n \beta_j \lambda_j \boldsymbol{v_j} \notag \\
\boldsymbol{x^{(2)}} &amp; = A\boldsymbol{x^{(1)}} = \sum\limits_{j=1}^n \beta_j \lambda_j^2 \boldsymbol{v_j} \notag \\
&amp; \quad \quad \quad \dots \notag \\
\boldsymbol{x^{(k)}} &amp; = A \boldsymbol{x^{(k-1)}} = \sum\limits_{j=1}^n \beta_j \lambda_j^k \boldsymbol{v_j} \notag \\
&amp; = \lambda_1^k \sum\limits_{j=1}^n \Big(\dfrac{\lambda_j}{\lambda_1}\Big)^k \boldsymbol{v_j} \notag
\end{align}
\]</div>
<p>当<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(k\)</span><span class="heti-spacing"> </span></span>足够大时，我们有：</p>
<div class="arithmatex">\[
\boldsymbol{x^{(k)}} \approx \lambda_1^k \beta_1 \boldsymbol{v_1}, \boldsymbol{x^{(k-1)}} \approx \lambda_1^{k-1} \beta_1 \boldsymbol{v_1} \Rightarrow \dfrac{(\boldsymbol{x^{(k)}})_i}{(\boldsymbol{x^{(k-1)}})_i} \approx \lambda_i
\]</div>
<h3 id="normalization">Normalization<a class="headerlink" href="#normalization" title="Permanent link">⚓︎</a></h3>
<p><strong>归一化</strong><span>(normalization)<span class="heti-spacing"> </span></span>的目的是确保在每一步满足<span><span class="heti-spacing"> </span><span class="arithmatex">\(\| \boldsymbol{x} \|_{\infty} = 1\)</span></span>，以确保稳定性。</p>
<p>令<span><span class="heti-spacing"> </span><span class="arithmatex">\(\| \boldsymbol{x^{(k)}} \|_{\infty} = |\boldsymbol{x_{p_k}^{(k)}}|\)</span></span>，那么<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\boldsymbol{u^{(k-1)}} = \dfrac{\boldsymbol{x^{(k-1)}}}{\boldsymbol{x^{(k-1)}_{p_{k-1}}}}\)</span><span class="heti-spacing"> </span></span>且<span><span class="heti-spacing"> </span><span class="arithmatex">\(\boldsymbol{x^{(k)}} = A \boldsymbol{u^{(k-1)}}\)</span></span>。因而得到：</p>
<div class="arithmatex">\[
\boldsymbol{u^{(k)}} = \dfrac{\boldsymbol{x^{(k)}}}{|\boldsymbol{x^{(k)}_{p_k}}|} \rightarrow \boldsymbol{v_1} \quad \text{and} \quad \lambda_1 \approx \dfrac{\boldsymbol{x_i^{(k)}}}{u_i^{(k-1)}} = \boldsymbol{x^{(k)}_{p_{k-1}}}
\]</div>
<p><strong>算法：幂法</strong></p>
<p>从非零初始向量开始，近似求解规模为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n \times n\)</span><span class="heti-spacing"> </span></span>的矩阵<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>的主特征值及其特征向量。</p>
<ul>
<li>输入：维度<span><span class="heti-spacing"> </span><span class="arithmatex">\(n\)</span></span>，矩阵<span><span class="heti-spacing"> </span><span class="arithmatex">\(a[][]\)</span></span>，初始向量<span><span class="heti-spacing"> </span><span class="arithmatex">\(x0[]\)</span></span>，容忍值<span><span class="heti-spacing"> </span><span class="arithmatex">\(TOL\)</span></span>，最大迭代次数<span><span class="heti-spacing"> </span><span class="arithmatex">\(N_{max}\)</span></span></li>
<li>输出：近似特征值<span><span class="heti-spacing"> </span><span class="arithmatex">\(\lambda\)</span></span>，近似（规范化的）特征向量</li>
</ul>
<div class="language-c highlight"><pre><span></span><code><span id="__span-14-1"><a href="#__codelineno-14-1" id="__codelineno-14-1" name="__codelineno-14-1"></a><span class="n">Step</span><span class="w"> </span><span class="mi">1</span><span class="w">  </span><span class="n">Set</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
</span><span id="__span-14-2"><a href="#__codelineno-14-2" id="__codelineno-14-2" name="__codelineno-14-2"></a><span class="n">Step</span><span class="w"> </span><span class="mi">2</span><span class="w">  </span><span class="n">Find</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="n">such</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="p">[</span><span class="n">x0</span><span class="p">[</span><span class="n">index</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">norm_infty</span><span class="p">(</span><span class="n">x0</span><span class="p">);</span>
</span><span id="__span-14-3"><a href="#__codelineno-14-3" id="__codelineno-14-3" name="__codelineno-14-3"></a><span class="n">Step</span><span class="w"> </span><span class="mi">3</span><span class="w">  </span><span class="n">Set</span><span class="w"> </span><span class="n">x0</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x0</span><span class="p">[]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">x0</span><span class="p">[</span><span class="n">index</span><span class="p">];</span><span class="w">    </span><span class="c1">// normalize x0</span>
</span><span id="__span-14-4"><a href="#__codelineno-14-4" id="__codelineno-14-4" name="__codelineno-14-4"></a><span class="n">Step</span><span class="w"> </span><span class="mi">4</span><span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">N_max</span><span class="p">)</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="n">steps</span><span class="w"> </span><span class="mi">5-11</span>
</span><span id="__span-14-5"><a href="#__codelineno-14-5" id="__codelineno-14-5" name="__codelineno-14-5"></a><span class="w">        </span><span class="n">Step</span><span class="w"> </span><span class="mi">5</span><span class="w">  </span><span class="n">x</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x0</span><span class="p">[];</span>
</span><span id="__span-14-6"><a href="#__codelineno-14-6" id="__codelineno-14-6" name="__codelineno-14-6"></a><span class="w">        </span><span class="n">Step</span><span class="w"> </span><span class="mi">6</span><span class="w">  </span><span class="n">lambda</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
</span><span id="__span-14-7"><a href="#__codelineno-14-7" id="__codelineno-14-7" name="__codelineno-14-7"></a><span class="w">        </span><span class="n">Step</span><span class="w"> </span><span class="mi">7</span><span class="w">  </span><span class="n">Find</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="n">such</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="n">index</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">norm_infty</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span><span id="__span-14-8"><a href="#__codelineno-14-8" id="__codelineno-14-8" name="__codelineno-14-8"></a><span class="w">        </span><span class="n">Step</span><span class="w"> </span><span class="mi">8</span><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">then</span>
</span><span id="__span-14-9"><a href="#__codelineno-14-9" id="__codelineno-14-9" name="__codelineno-14-9"></a><span class="w">                    </span><span class="n">Output</span><span class="p">(</span><span class="s">"A has the eigenvalue 0"</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
</span><span id="__span-14-10"><a href="#__codelineno-14-10" id="__codelineno-14-10" name="__codelineno-14-10"></a><span class="w">                    </span><span class="n">STOP</span><span class="p">.</span>
</span><span id="__span-14-11"><a href="#__codelineno-14-11" id="__codelineno-14-11" name="__codelineno-14-11"></a><span class="w">                </span><span class="c1">// the matrix is singular and user should try a new x0</span>
</span><span id="__span-14-12"><a href="#__codelineno-14-12" id="__codelineno-14-12" name="__codelineno-14-12"></a><span class="w">        </span><span class="n">Step</span><span class="w"> </span><span class="mi">9</span><span class="w">  </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">norm_infty</span><span class="p">(</span><span class="n">x0</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span>
</span><span id="__span-14-13"><a href="#__codelineno-14-13" id="__codelineno-14-13" name="__codelineno-14-13"></a><span class="w">                </span><span class="n">x0</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">[]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="w">      </span><span class="c1">// computer u^k</span>
</span><span id="__span-14-14"><a href="#__codelineno-14-14" id="__codelineno-14-14" name="__codelineno-14-14"></a><span class="w">        </span><span class="n">Step</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">TOL</span><span class="p">)</span><span class="w"> </span><span class="n">then</span>
</span><span id="__span-14-15"><a href="#__codelineno-14-15" id="__codelineno-14-15" name="__codelineno-14-15"></a><span class="w">                    </span><span class="n">Output</span><span class="p">(</span><span class="n">lambda</span><span class="p">,</span><span class="w"> </span><span class="n">x0</span><span class="p">[]);</span>
</span><span id="__span-14-16"><a href="#__codelineno-14-16" id="__codelineno-14-16" name="__codelineno-14-16"></a><span class="w">                    </span><span class="n">STOP</span><span class="p">.</span>
</span><span id="__span-14-17"><a href="#__codelineno-14-17" id="__codelineno-14-17" name="__codelineno-14-17"></a><span class="w">        </span><span class="n">Step</span><span class="w"> </span><span class="mi">11</span><span class="w"> </span><span class="n">Set</span><span class="w"> </span><span class="n">k</span><span class="o">++</span><span class="p">;</span>
</span><span id="__span-14-18"><a href="#__codelineno-14-18" id="__codelineno-14-18" name="__codelineno-14-18"></a><span class="n">Step</span><span class="w"> </span><span class="mi">12</span><span class="w"> </span><span class="n">Output</span><span class="p">(</span><span class="n">Maximum</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">iterations</span><span class="w"> </span><span class="n">exceeded</span><span class="p">);</span>
</span><span id="__span-14-19"><a href="#__codelineno-14-19" id="__codelineno-14-19" name="__codelineno-14-19"></a><span class="w">        </span><span class="n">STOP</span><span class="p">.</span><span class="w">    </span><span class="c1">// unsucessful</span>
</span></code></pre></div>
<p><strong>注</strong></p>
<ul>
<li>
<p>该方法在有<strong>多重特征值</strong>（即存在<span><span class="heti-spacing"> </span><span class="arithmatex">\(\lambda_1 = \lambda_2 = \dots = \lambda_r\)</span></span>）的情况下也能生效，因为：</p>
<div class="arithmatex">\[
\boldsymbol{x^{(k)}} = \lambda_1^k \Big[ \sum\limits_{j=1}^r \beta_j \boldsymbol{v_j} + \sum\limits_{j=r+1}^n \beta_j \Big(\dfrac{\lambda_j}{\lambda_1}\Big)^k \boldsymbol{v_j} \Big] \approx \lambda_1^k \Big( \sum\limits_{j=1}^r \beta_j \boldsymbol{v_j} \Big)
\]</div>
</li>
<li>
<p>若存在类似<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\lambda_1 = -\lambda_2\)</span><span class="heti-spacing"> </span></span>的情况，那么该方法就会失效。</p>
</li>
<li>因为我们无法确保对于任意初始近似向量<span><span class="heti-spacing"> </span><span class="arithmatex">\(\boldsymbol{x^{(0)}}\)</span></span>，<span class="arithmatex">\(\beta_1 \ne 0\)</span>，所以在这种情况下的迭代结果可能就不是<span><span class="heti-spacing"> </span><span class="arithmatex">\(\boldsymbol{v_1}\)</span></span>，而时第一个满足<span><span class="heti-spacing"> </span><span class="arithmatex">\((\boldsymbol{x^{(0)}}, \boldsymbol{v_m}) \ne 0\)</span></span>，关联的特征值为<span><span class="heti-spacing"> </span><span class="arithmatex">\(\lambda_m\)</span></span>。</li>
<li><a href="2.html#aitkens--method"><span>Aitken <span class="arithmatex">\(\Delta^2\)</span><span class="heti-spacing"> </span></span>法</a>也能用在这里加快收敛速度。</li>
</ul>
<h3 id="rate-of-convergence">Rate of Convergence<a class="headerlink" href="#rate-of-convergence" title="Permanent link">⚓︎</a></h3>
<p>在前面的计算中，我们已经得到：</p>
<p><span class="arithmatex">\(\boldsymbol{x^{(k)}} = A\boldsymbol{x^{(k-1)}} = \lambda_1^k \sum\limits_{j=1}^n \Big(\dfrac{\lambda_j}{\lambda_1}\Big)^k \boldsymbol{v_j}\)</span></p>
<p>现在，我们的目标是使<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\Big| \dfrac{\lambda_2}{\lambda_1} \Big|\)</span><span class="heti-spacing"> </span></span>的值尽可能小，以加快收敛速度。</p>
<p>假设<span><span class="heti-spacing"> </span><span class="arithmatex">\(\lambda_1 &gt; \lambda_2 \ge \dots \lambda_n\)</span></span>，且<span><span class="heti-spacing"> </span><span class="arithmatex">\(|\lambda_2| &gt; |\lambda_n|\)</span></span>。</p>
<div style="text-align: center">
<img src="images/C9/1.png" width="70%/"/>
</div>
<p>思路：令<span><span class="heti-spacing"> </span><span class="arithmatex">\(B = A - pI\)</span></span>，那么<span><span class="heti-spacing"> </span><span class="arithmatex">\(|\lambda I - A| = |\lambda I - (B + pI)| = |(\lambda - p) I - B|\)</span></span>，这样可以得到<span><span class="heti-spacing"> </span><span class="arithmatex">\(\lambda_A - p = \lambda_B\)</span></span>。因为<span><span class="heti-spacing"> </span><span class="arithmatex">\(\dfrac{\lambda_2 - p}{\lambda_1 - p} &lt; \dfrac{|\lambda_2|}{|\lambda_1|}\)</span></span>，寻找<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(B\)</span><span class="heti-spacing"> </span></span>的特征值的迭代收敛速度快于关于<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>的迭代。</p>
<h3 id="inverse-power-method">Inverse Power Method<a class="headerlink" href="#inverse-power-method" title="Permanent link">⚓︎</a></h3>
<p><strong>反幂法</strong><span>(inverse power method)<span class="heti-spacing"> </span></span>是幂法的一种改进方法，相比幂法能够更快地收敛。下面给出具体计算过程：</p>
<p>如果<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>有特征值<span><span class="heti-spacing"> </span><span class="arithmatex">\(|\lambda_1| \ge |\lambda_2| \ge \dots \textcolor{red}{&gt; |\lambda_n|}\)</span></span>，那么对于<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A^{-1}\)</span><span class="heti-spacing"> </span></span>满足：</p>
<div class="arithmatex">\[
\textcolor{red}{\Big|\dfrac{1}{\lambda_n}\Big| &gt; } \Big|\dfrac{1}{\lambda_{n-1}}\Big| \ge \dots \ge \Big| \dfrac{1}{\lambda_1} \Big|
\]</div>
<p>并且这些特征值对应于相同的特征向量。</p>
<p><span><span class="arithmatex">\(A^{-1}\)</span><span class="heti-spacing"> </span></span>的主特征值<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\Leftrightarrow\)</span> <span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>的特征值中的最小值</p>
<p>要想迭代计算<span><span class="heti-spacing"> </span><span class="arithmatex">\(\boldsymbol{x^{(k+1)}} = A^{-1} \boldsymbol{x^{(k)}}\)</span></span>，就得在每次迭代步骤中求解线性方程组<span><span class="heti-spacing"> </span><span class="arithmatex">\(A \boldsymbol{x^{(k+1)}} = \boldsymbol{x^{(k)}}\)</span></span>，其中<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>需要被分解<span><span class="heti-spacing"> </span>(factorized)</span>。</p>
<p>思路：如果我们知道<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>的一个特征值<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\lambda_i\)</span><span class="heti-spacing"> </span></span>最接近一个指定值<span><span class="heti-spacing"> </span><span class="arithmatex">\(p\)</span></span>，那么对于任意的<span><span class="heti-spacing"> </span><span class="arithmatex">\(j \ne i\)</span></span>，我们有<span><span class="heti-spacing"> </span><span class="arithmatex">\(|\lambda_i - p| &lt;&lt; |\lambda_j - p|\)</span></span>。并且，如果存在<span><span class="heti-spacing"> </span><span class="arithmatex">\((A - pI)^{-1}\)</span></span>，那么逆幂法能以更快的收敛速度寻找到<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\((A - pI)^{-1}\)</span><span class="heti-spacing"> </span></span>的主特征值<span><span class="heti-spacing"> </span><span class="arithmatex">\(\dfrac{1}{\lambda_i - p}\)</span></span>。</p>
<p><strong>例题</strong></p>
<p>题目：</p>
<div style="text-align: center">
<img src="images/C9/2.png" width="80%/"/>
</div>
<p>解答：A、<span>B<span class="heti-spacing"> </span></span>为幂法，C、<span>D<span class="heti-spacing"> </span></span>为逆幂法；且<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\lambda_2\)</span><span class="heti-spacing"> </span></span>更接近真值，所以<span class="heti-skip"><span class="heti-spacing"> </span>D<span class="heti-spacing"> </span></span>的收敛速度最快。</p>
<p><strong>算法：反幂法</strong></p>
<p>从非零初始向量开始，近似求解规模为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n \times n\)</span><span class="heti-spacing"> </span></span>的矩阵<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>的主特征值及其特征向量。</p>
<ul>
<li>输入：维度<span><span class="heti-spacing"> </span><span class="arithmatex">\(n\)</span></span>，矩阵<span><span class="heti-spacing"> </span><span class="arithmatex">\(a[][]\)</span></span>，初始向量<span><span class="heti-spacing"> </span><span class="arithmatex">\(x0[]\)</span></span>，容忍值<span><span class="heti-spacing"> </span><span class="arithmatex">\(TOL\)</span></span>，最大迭代次数<span><span class="heti-spacing"> </span><span class="arithmatex">\(N_{max}\)</span></span></li>
<li>输出：近似特征值<span><span class="heti-spacing"> </span><span class="arithmatex">\(\lambda\)</span></span>，近似（规范化的）特征向量</li>
</ul>
<div class="language-c highlight"><pre><span></span><code><span id="__span-15-1"><a href="#__codelineno-15-1" id="__codelineno-15-1" name="__codelineno-15-1"></a><span class="n">Step</span><span class="w"> </span><span class="mi">1</span><span class="w">  </span><span class="n">Set</span><span class="w"> </span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">[]</span><span class="o">^</span><span class="n">T</span><span class="w"> </span><span class="err">·</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="err">·</span><span class="w"> </span><span class="n">x</span><span class="p">[])</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="o">^</span><span class="n">T</span><span class="w"> </span><span class="err">·</span><span class="w"> </span><span class="n">x</span><span class="p">[]);</span>
</span><span id="__span-15-2"><a href="#__codelineno-15-2" id="__codelineno-15-2" name="__codelineno-15-2"></a><span class="n">Step</span><span class="w"> </span><span class="mi">2</span><span class="w">  </span><span class="n">Set</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
</span><span id="__span-15-3"><a href="#__codelineno-15-3" id="__codelineno-15-3" name="__codelineno-15-3"></a><span class="n">Step</span><span class="w"> </span><span class="mi">3</span><span class="w">  </span><span class="n">Find</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">smallest</span><span class="w"> </span><span class="n">integer</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="o">|</span><span class="n">x_p</span><span class="o">|</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">norm_infty</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span><span id="__span-15-4"><a href="#__codelineno-15-4" id="__codelineno-15-4" name="__codelineno-15-4"></a><span class="n">Step</span><span class="w"> </span><span class="mi">4</span><span class="w">  </span><span class="n">Set</span><span class="w"> </span><span class="n">x</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">[]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">x_p</span>
</span><span id="__span-15-5"><a href="#__codelineno-15-5" id="__codelineno-15-5" name="__codelineno-15-5"></a><span class="n">Step</span><span class="w"> </span><span class="mi">5</span><span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">N_max</span><span class="p">)</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="n">steps</span><span class="w"> </span><span class="mi">6-12</span>
</span><span id="__span-15-6"><a href="#__codelineno-15-6" id="__codelineno-15-6" name="__codelineno-15-6"></a><span class="w">        </span><span class="n">Step</span><span class="w"> </span><span class="mi">6</span><span class="w">  </span><span class="n">Solve</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">linear</span><span class="w"> </span><span class="n">system</span><span class="w"> </span><span class="p">(</span><span class="n">A</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">qI</span><span class="p">)</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
</span><span id="__span-15-7"><a href="#__codelineno-15-7" id="__codelineno-15-7" name="__codelineno-15-7"></a><span class="w">        </span><span class="n">Step</span><span class="w"> </span><span class="mi">7</span><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">system</span><span class="w"> </span><span class="n">does</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">have</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">unique</span><span class="w"> </span><span class="n">solution</span><span class="p">,</span><span class="w"> </span><span class="n">then</span>
</span><span id="__span-15-8"><a href="#__codelineno-15-8" id="__codelineno-15-8" name="__codelineno-15-8"></a><span class="w">                    </span><span class="n">Output</span><span class="p">(</span><span class="s">"q is an eigenvalue"</span><span class="p">,</span><span class="w"> </span><span class="n">q</span><span class="p">);</span>
</span><span id="__span-15-9"><a href="#__codelineno-15-9" id="__codelineno-15-9" name="__codelineno-15-9"></a><span class="w">                    </span><span class="n">STOP</span><span class="p">.</span>
</span><span id="__span-15-10"><a href="#__codelineno-15-10" id="__codelineno-15-10" name="__codelineno-15-10"></a><span class="w">        </span><span class="n">Step</span><span class="w"> </span><span class="mi">8</span><span class="w">  </span><span class="n">set</span><span class="w"> </span><span class="n">lambda</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y_p</span><span class="p">;</span>
</span><span id="__span-15-11"><a href="#__codelineno-15-11" id="__codelineno-15-11" name="__codelineno-15-11"></a><span class="w">        </span><span class="n">Step</span><span class="w"> </span><span class="mi">9</span><span class="w">  </span><span class="n">Find</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">smallest</span><span class="w"> </span><span class="n">integer</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">p</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="o">|</span><span class="n">y_p</span><span class="o">|</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">norm_infty</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
</span><span id="__span-15-12"><a href="#__codelineno-15-12" id="__codelineno-15-12" name="__codelineno-15-12"></a><span class="w">        </span><span class="n">Step</span><span class="w"> </span><span class="mi">10</span><span class="w">  </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">norm_infty</span><span class="p">(</span><span class="n">x</span><span class="p">[]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">y</span><span class="p">[]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">y_p</span><span class="p">);</span>
</span><span id="__span-15-13"><a href="#__codelineno-15-13" id="__codelineno-15-13" name="__codelineno-15-13"></a><span class="w">                 </span><span class="n">x</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="p">[]</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">y_p</span><span class="p">;</span>
</span><span id="__span-15-14"><a href="#__codelineno-15-14" id="__codelineno-15-14" name="__codelineno-15-14"></a><span class="w">        </span><span class="n">Step</span><span class="w"> </span><span class="mi">11</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">err</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">TOL</span><span class="p">)</span><span class="w"> </span><span class="n">then</span>
</span><span id="__span-15-15"><a href="#__codelineno-15-15" id="__codelineno-15-15" name="__codelineno-15-15"></a><span class="w">                    </span><span class="n">Output</span><span class="p">(</span><span class="n">lambda</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="p">[]);</span>
</span><span id="__span-15-16"><a href="#__codelineno-15-16" id="__codelineno-15-16" name="__codelineno-15-16"></a><span class="w">                    </span><span class="n">STOP</span><span class="p">.</span>
</span><span id="__span-15-17"><a href="#__codelineno-15-17" id="__codelineno-15-17" name="__codelineno-15-17"></a><span class="w">        </span><span class="n">Step</span><span class="w"> </span><span class="mi">12</span><span class="w"> </span><span class="n">Set</span><span class="w"> </span><span class="n">k</span><span class="o">++</span><span class="p">;</span>
</span><span id="__span-15-18"><a href="#__codelineno-15-18" id="__codelineno-15-18" name="__codelineno-15-18"></a><span class="n">Step</span><span class="w"> </span><span class="mi">13</span><span class="w"> </span><span class="n">Output</span><span class="p">(</span><span class="n">Maximum</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">iterations</span><span class="w"> </span><span class="n">exceeded</span><span class="p">);</span>
</span><span id="__span-15-19"><a href="#__codelineno-15-19" id="__codelineno-15-19" name="__codelineno-15-19"></a><span class="w">        </span><span class="n">STOP</span><span class="p">.</span>
</span></code></pre></div>
<h1 id="chap-3-interpolation-and-polynomial-approximation">Chap 3: Interpolation and Polynomial Approximation<a class="headerlink" href="#chap-3-interpolation-and-polynomial-approximation" title="Permanent link">⚓︎</a></h1>
<p>如果函数<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(y = f(x)\)</span><span class="heti-spacing"> </span></span>的计算过于复杂，或者甚至是未知的，一种近似求解的办法是：首先在一组点序列<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(x_0, \dots, x_n\)</span><span class="heti-spacing"> </span></span>上获取一组函数值<span><span class="heti-spacing"> </span><span class="arithmatex">\(y_0 = f(x_0), \dots, y_n = f(x_n)\)</span></span>，然后根据这些值构造一个相对简单的近似函数<span><span class="heti-spacing"> </span><span class="arithmatex">\(g(x) \approx f(x)\)</span></span>。</p>
<p>如果<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(g(x)\)</span><span class="heti-spacing"> </span></span>满足<span><span class="heti-spacing"> </span><span class="arithmatex">\(\forall\ i = 0, \dots, n, g(x_i) = f(x_i)\)</span></span>，我们称<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(g(x)\)</span><span class="heti-spacing"> </span></span>为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f(x)\)</span><span class="heti-spacing"> </span></span>的<strong>插值函数</strong>(interpolating function)。最常见的插值函数形式是<strong>代数多项式</strong>(algebraic polynomials)。</p>
<div style="text-align: center">
<img src="images/C3/4.png" width="80%/"/>
</div>
<h2 id="interpolation-and-the-lagrange-polynomial">Interpolation and the Lagrange Polynomial<a class="headerlink" href="#interpolation-and-the-lagrange-polynomial" title="Permanent link">⚓︎</a></h2>
<p>目标：找到<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n\)</span><span class="heti-spacing"> </span></span>阶多项式<span><span class="heti-spacing"> </span><span class="arithmatex">\(P_n(x) = a_0 + a_1 x + \dots + a_n x^n\)</span></span>，使得<span><span class="heti-spacing"> </span><span class="arithmatex">\(\forall\ i = 0, \dots, n, P_n(x_i) = y_i\)</span></span>。</p>
<blockquote>
<p>注：对任何<span><span class="heti-spacing"> </span><span class="arithmatex">\(i \ne j\)</span></span>，必须满足<span><span class="heti-spacing"> </span><span class="arithmatex">\(x_i \ne x_j\)</span></span></p>
</blockquote>
<p>当<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n = 1\)</span><span class="heti-spacing"> </span></span>时：给定<span><span class="heti-spacing"> </span><span class="arithmatex">\(x_0, x_1; y_0, y_1\)</span></span>。找到<span><span class="heti-spacing"> </span><span class="arithmatex">\(P_1(x) = a_0 + a_1 x\)</span></span>，使得<span><span class="heti-spacing"> </span><span class="arithmatex">\(P_1(x_0) = y_0, P_1(x_1) = y_1\)</span></span>。此时<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(P_1(x)\)</span><span class="heti-spacing"> </span></span>是一个经过给定两点<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\((x_0, y_0), (x_1, y_1)\)</span><span class="heti-spacing"> </span></span>的<strong>线函数</strong>(line function)，即：</p>
<div class="arithmatex">\[
\begin{align}
P_1(x) &amp; = y_0 + \dfrac{y_1 - y_0}{x_1 - x_0}(x - x_0) \notag \\
&amp; = \underbrace{\Big(\dfrac{x - x_1}{x_0 - x_1}\Big)}_{\textcolor{red}{L_{1, 0}}(x)} y_0 + \underbrace{\Big(\dfrac{x - x_0}{x_1 - x_0}\Big)}_{\textcolor{red}{L_{1, 1}}(x)} y_1 = \sum\limits_{i=0}^1 \textcolor{red}{L_{1, i}}(x)y_i \notag
\end{align}
\]</div>
<p>其中标红的项被称为<strong>拉格朗日基</strong>(Lagrange Basis)，它满足：<span class="arithmatex">\(L_{1, i}(x_j) = \delta_{ij} = \begin{cases}1 &amp; \text{if } i = j \\ 0 &amp; \text{if } i \ne j\end{cases}\)</span>（称为 <strong><span>Kronecker<span class="heti-spacing"> </span></span>符号</strong>）</p>
<hr/>
<p>当<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n \ge 1\)</span><span class="heti-spacing"> </span></span>时：我们要寻找<span><span class="heti-spacing"> </span><span class="arithmatex">\(L_{n, i}(x)\ (i = 0, \dots, n)\)</span></span>，使得<span><span class="heti-spacing"> </span><span class="arithmatex">\(L_{n, i} (x_j) = \delta_{ij}\)</span></span>。然后令<span><span class="heti-spacing"> </span><span class="arithmatex">\(P_n(x) = \sum\limits_{i=0}^n L_{n, i}(x) y_i\)</span></span>。因此<span><span class="heti-spacing"> </span><span class="arithmatex">\(P_n(x_i) = y_i\)</span></span>。</p>
<p>每个<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(L_{n, i}\)</span><span class="heti-spacing"> </span></span>都有<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n\)</span><span class="heti-spacing"> </span></span>个根<span><span class="heti-spacing"> </span><span class="arithmatex">\(x_0 \dots \widehat{x_i} \dots x_n\)</span></span>。可以得到：</p>
<div class="arithmatex">\[
L_{n, i}(x) = C_i (x - x_0) \dots (\widehat{x - x_i}) \dots (x - x_n) = C_i \prod\limits_{\substack{j \ne i \\ j = 0}}^n (x - x_j)
\]</div>
<p>当<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(L_{n, i}(x_i) = 1\)</span><span class="heti-spacing"> </span></span>时，<span class="arithmatex">\(C_i = \prod\limits_{j \ne i} \dfrac{1}{x_i - x_j}\)</span></p>
<div class="arithmatex">\[
L_{n, i}(x) = \prod\limits_{\substack{j \ne i \\ j = 0}}^n \dfrac{(x - x_j)}{(x_i - x_j)} \Rightarrow P_n(x) = \sum\limits_{i=0}^n L_{n, i}(x) y_i
\]</div>
<p>这里的<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(P_n(x)\)</span><span class="heti-spacing"> </span></span>就是<strong><span>n<span class="heti-spacing"> </span></span>阶拉格朗日插值多项式</strong>(n-th Lagrange interpolating polynomial)。</p>
<p><strong>Quiz</strong></p>
<p>题目</p>
<div style="text-align: center">
<img src="images/C3/5.png" width="90%/"/>
</div>
<p>答案：A</p>
<ul>
<li>首先，拉格朗日多项式一定是个连续函数<span><span class="heti-spacing"> </span>-&gt; C</span>❌</li>
<li>其次，从它的式子就可以看出，它不可能是直线（<span><span class="arithmatex">\(n=5\)</span><span class="heti-spacing"> </span></span>表明它是六次曲线）-&gt; B❌</li>
</ul>
<p><strong>定理</strong> ：如果<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(x_0, x_1, \dots, x_n\)</span><span class="heti-spacing"> </span></span>是<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n + 1\)</span><span class="heti-spacing"> </span></span>个不同的数，且用函数<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f\)</span><span class="heti-spacing"> </span></span>得到这<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n + 1\)</span><span class="heti-spacing"> </span></span>个数对应的函数值，那么最终得到的<span class="heti-skip"><span class="heti-spacing"> </span>n<span class="heti-spacing"> </span></span>阶多项式就是<strong>唯一的</strong>（和<a href="#interpolation-and-the-lagrange-polynomial">拉格朗日多项式</a>、<a href="#newtons-interpolation">牛顿插值法</a>等具体的构造方法无关<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>。</p>
<p><strong>注</strong> ：插值多项式不是唯一的，除非它的阶数被约束在不超过<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n\)</span><span class="heti-spacing"> </span></span>的范围内。</p>
<p>相应的反例就是<span><span class="heti-spacing"> </span><span class="arithmatex">\(P(x) = L_n(x) + p(x) \prod\limits_{i=0}^n (x - x_i)\)</span></span>，其中<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(p(x)\)</span><span class="heti-spacing"> </span></span>可以是任意阶数的多项式。</p>
<hr/>
<p>下面我们来分析<strong>余项</strong>(remainder)：假如<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(a \le x_0 &lt; x_1 &lt; \dots &lt; x_n \le b\)</span><span class="heti-spacing"> </span></span>且<span><span class="heti-spacing"> </span><span class="arithmatex">\(f \in C^{n+1} [a, b]\)</span></span>。考虑截断误差<span><span class="heti-spacing"> </span><span class="arithmatex">\(R_n(x) = f(x) - P_n(x)\)</span></span></p>
<p><strong>罗尔定理</strong></p>
<p>如果<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\varphi(x)\)</span><span class="heti-spacing"> </span></span>足够平滑，且<span><span class="heti-spacing"> </span><span class="arithmatex">\(\varphi(x_0) = \varphi(x_1) = 0\)</span></span>，那么<span><span class="heti-spacing"> </span><span class="arithmatex">\(\exists \xi \in (x_0, x_1)\)</span></span>，使得<span><span class="heti-spacing"> </span><span class="arithmatex">\(\varphi'(\xi) = 0\)</span></span>。</p>
<p>一般来说，如果<span><span class="heti-spacing"> </span><span class="arithmatex">\(\varphi(x_0) = \varphi(x_1) = \varphi(x_2) = 0\)</span></span>，那么<span><span class="heti-spacing"> </span><span class="arithmatex">\(\exists \xi_0 \in (x_0, x_1), \xi_1 \in (x_1, x_2)\)</span></span>，使得<span><span class="heti-spacing"> </span><span class="arithmatex">\(\varphi'(\xi_0) = \varphi'(\xi_1) = 0\)</span></span>，那么<span><span class="heti-spacing"> </span><span class="arithmatex">\(\exists \xi \in (\xi_0, \xi_1)\)</span></span>，使得<span><span class="heti-spacing"> </span><span class="arithmatex">\(\varphi''(\xi) = 0\)</span></span></p>
<p>同理，<span class="arithmatex">\(\varphi(x_0) = \dots = \varphi(x_n) = 0 \Rightarrow \exists \xi \in (a, b)\)</span>，使得<span><span class="heti-spacing"> </span><span class="arithmatex">\(\xi^{(n)}(\xi) = 0\)</span></span></p>
<hr/>
<p><span><span class="arithmatex">\(R_n(x)\)</span><span class="heti-spacing"> </span></span>至少有<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n + 1\)</span><span class="heti-spacing"> </span></span>个根<span><span class="heti-spacing"> </span><span class="arithmatex">\(\Rightarrow R_n(x) = K(x) \prod\limits_{i=0}^n (x - x_i)\)</span></span> </p>
<p>修正任何<span><span class="heti-spacing"> </span><span class="arithmatex">\(x \ne x_i\ (i = 0, \dots, n)\)</span></span>。定义为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(t \in [a, b]\)</span><span class="heti-spacing"> </span></span>定义函数<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(g\)</span><span class="heti-spacing"> </span></span>为：</p>
<div class="arithmatex">\[
g(t) = R_n(t) - K(x) \prod\limits_{i=0}^n (t - x_i)
\]</div>
<p><span><span class="arithmatex">\(g(x)\)</span><span class="heti-spacing"> </span></span>有<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n + 2\)</span><span class="heti-spacing"> </span></span>个不同的根<span><span class="heti-spacing"> </span><span class="arithmatex">\(x_0, \dots, x_n, x\ \Rightarrow g^{(n+1)}(\xi_x) = 0, \xi_x \in (a, b)\)</span></span></p>
<div class="arithmatex">\[
\begin{align}
&amp; f^{(n+1)}(\xi_x) - \cancel{P_n^{(n+1)}(\xi_x)} - K(x)(n+1)! = R_n^{(n+1)}(\xi_x) - K(x)(n+1)! \notag \\
&amp; \Rightarrow K(x) = \dfrac{f^{(n+1)}(\xi_x)}{(n+1)!} \notag
\end{align}
\]</div>
<p>因此<span><span class="heti-spacing"> </span><span class="arithmatex">\(R(x) = \dfrac{f^{(n+1)}(\xi_x)}{(n+1)!} \prod\limits_{i=0}^n (x - x_i)\)</span></span></p>
<p><strong>注</strong></p>
<ul>
<li>因为大多数情况下<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\xi_x\)</span><span class="heti-spacing"> </span></span>无法确定，因此我们会获取<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f^{(n+1)}\)</span><span class="heti-spacing"> </span></span>的上界。也就是说，得到一个估计值<span><span class="heti-spacing"> </span><span class="arithmatex">\(M_{n+1}\)</span></span>，满足<span><span class="heti-spacing"> </span><span class="arithmatex">\(\forall\ x \in (a, b),\ |f^{(n+1)}(x)| \le M_{n+1}\)</span></span>，并且取<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\dfrac{M_{n+1}}{(n+1)!} \prod\limits_{i=0}^n |x - x_i|\)</span><span class="heti-spacing"> </span></span>为总误差的上界。</li>
<li>对于任意阶数<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\le n\)</span><span class="heti-spacing"> </span></span>的多项式函数<span><span class="heti-spacing"> </span><span class="arithmatex">\(f\)</span></span>，插值多项式是精确的，因为<span><span class="heti-spacing"> </span><span class="arithmatex">\(f^{(n+1)}(x) \equiv 0\)</span></span>。</li>
</ul>
<p><strong>例子</strong></p>
<p>例<span><span class="heti-spacing"> </span>1</span></p>
<p>题目：假设为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f(x) = e^x\ (x \in [0, 1])\)</span><span class="heti-spacing"> </span></span>做一个表格，表格中的每一项精确到<span class="heti-skip"><span class="heti-spacing"> </span>8<span class="heti-spacing"> </span></span>位小数，并且步幅为<span><span class="heti-spacing"> </span><span class="arithmatex">\(h\)</span></span>。对于绝对误差不超过<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(10^{-6}\)</span><span class="heti-spacing"> </span></span>的线性插值，<span><span class="arithmatex">\(h\)</span><span class="heti-spacing"> </span></span>应该是多少？</p>
<p>解答：</p>
<p>假设<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\([0, 1]\)</span><span class="heti-spacing"> </span></span>被划分为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n\)</span><span class="heti-spacing"> </span></span>个等间距的子区间<span><span class="heti-spacing"> </span><span class="arithmatex">\([x_0, x_1], [x_1, x_2], \dots, [x_{n-1}, x_n]\)</span></span>，且<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(x\)</span><span class="heti-spacing"> </span></span>在区间<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\([x_k, x_{k+1}]\)</span><span class="heti-spacing"> </span></span>上。那么估计误差为：</p>
<div class="arithmatex">\[
\begin{align}
|f(x) - P_1(x)| &amp; = \Big|\dfrac{f^{(2)}(\xi)}{2!}(x - x_k)(x - x_{k+1})\Big| \notag \\
&amp; = \Big|\dfrac{e^\xi}{2}(x - kh)(x - (k+1)h)\Big| \le \dfrac{e}{2} \times \dfrac{h^2}{4} \notag
\end{align}
\]</div>
<p><span class="arithmatex">\(\dfrac{eh^2}{8} \le 10^{-6} \quad \Rightarrow \quad h \le 1.72 \times 10^{-3}\)</span></p>
<p>方便起见，我们就取<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n = 1000, h = 0.001\)</span><span class="heti-spacing"> </span></span>好了。</p>
<p>例<span><span class="heti-spacing"> </span>2</span></p>
<p>题目：给定<span><span class="heti-spacing"> </span><span class="arithmatex">\(\sin \dfrac{\pi}{6} = \dfrac{1}{2}, \sin \dfrac{\pi}{4} = \dfrac{1}{\sqrt{2}}, \sin \dfrac{\pi}{3} = \dfrac{\sqrt{3}}{2}\)</span></span>。使用关于<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\sin x\)</span><span class="heti-spacing"> </span></span>的线形和二次拉格朗日多项式，计算<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\sin 50 \degree\)</span><span class="heti-spacing"> </span></span>并评估误差<heti-adjacent class="heti-adjacent-half">。</heti-adjacent>（已知<span><span class="heti-spacing"> </span><span class="arithmatex">\(\sin 50 \degree = 0.7660444...\)</span></span>）</p>
<p>解答</p>
<ul>
<li>
<p>先使用<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(x_0, x_1\)</span><span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(x_1, x_2\)</span><span class="heti-spacing"> </span></span>计算线形插值。</p>
<ul>
<li>使用<span><span class="heti-spacing"> </span><span class="arithmatex">\(x_0 = \dfrac{\pi}{6}, x_1 = \dfrac{\pi}{4}\)</span></span><ul>
<li><span class="arithmatex">\(P_1(x) = \dfrac{x - \frac{\pi}{4}}{\frac{\pi}{6} - \frac{\pi}{4}} \times \dfrac{1}{2} + \dfrac{x - \frac{\pi}{6}}{\frac{\pi}{4} - \frac{\pi}{6}} \times \dfrac{1}{\sqrt{2}}\)</span></li>
<li><span class="arithmatex">\(50 \degree = \dfrac{5\pi}{18}\)</span></li>
<li><span class="arithmatex">\(\sin 50 \degree \approx P_1(\dfrac{5 \pi}{18}) \approx 0.77614\)</span></li>
<li><span class="arithmatex">\(f(x) = \sin x, f^{(2)} = - sin \xi_x, \xi_x \in (\dfrac{\pi}{6}), \dfrac{\pi}{3}\)</span>，且<span><span class="heti-spacing"> </span><span class="arithmatex">\(\dfrac{1}{2} &lt; \sin \xi_x &lt; \dfrac{\sqrt{3}}{2}\)</span></span></li>
<li><span class="arithmatex">\(R_1 (x) = \dfrac{f^{(2)(\xi_x)}}{2!}(x - \dfrac{\pi}{6})(x - \dfrac{\pi}{4})\)</span>，得到<span><span class="heti-spacing"> </span><span class="arithmatex">\(-0.01319 &lt; R_1(\dfrac{5\pi}{18}) &lt; -0.00762\)</span></span>，因此<strong>外推误差</strong> <span class="arithmatex">\(\approx -0.01001\)</span></li>
</ul>
</li>
<li>使用<span><span class="heti-spacing"> </span><span class="arithmatex">\(x_1 = \dfrac{\pi}{4}, x_2 = \dfrac{\pi}{3}\)</span></span><ul>
<li>计算得到<span><span class="heti-spacing"> </span><span class="arithmatex">\(\sin 50 \degree \approx 0.76008, 0.00538 &lt; \widetilde{R_1}(\dfrac{5\pi}{18}) &lt; 0.00660\)</span></span></li>
<li>因此插值误差<span><span class="heti-spacing"> </span><span class="arithmatex">\(\approx 0.00596\)</span></span></li>
</ul>
</li>
</ul>
<p><strong>外推<span class="heti-skip"><span class="heti-spacing"> </span>v.s.<span class="heti-spacing"> </span></span>插值</strong></p>
<ul>
<li><strong>外推</strong>(extrapolation)：在已知数据点范围之<strong>外</strong>，估计或预测未知数据点的值。</li>
<li><strong>插值</strong>(interpolation)：在已知数据点范围之<strong>内</strong>，估计或预测未知数据点的值。</li>
</ul>
<p>由于<span><span class="heti-spacing"> </span><span class="arithmatex">\(\dfrac{\pi}{6} &lt; \dfrac{\pi}{4} &lt; 50 \degree &lt; \dfrac{\pi}{3}\)</span></span>，因此使用<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(x_0, x_1\)</span><span class="heti-spacing"> </span></span>属于外推，而<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(x_1, x_2\)</span><span class="heti-spacing"> </span></span>属于插值。一般而言，<strong>插值效果优于外推</strong>。</p>
</li>
<li>
<p>再使用<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(x_0, x_1, x_2\)</span><span class="heti-spacing"> </span></span>计算二次插值。</p>
<ul>
<li><span class="arithmatex">\(P_2(x) = \frac{(x - \frac{\pi}{4})(x - \frac{\pi}{3})}{(\frac{\pi}{6} - \frac{\pi}{4})(\frac{\pi}{6} - \frac{\pi}{2})} \times \dfrac{1}{2} + \frac{(x - \frac{\pi}{6})(x - \frac{\pi}{3})}{(\frac{\pi}{4} - \frac{\pi}{6})(\frac{\pi}{4} - \frac{\pi}{3})} \times \dfrac{1}{\sqrt{2}} +  \frac{(x - \frac{\pi}{6})(x - \frac{\pi}{4})}{(\frac{\pi}{3} - \frac{\pi}{6})(\frac{\pi}{3} - \frac{\pi}{4})} \times \dfrac{\sqrt{3}}{2}\)</span></li>
<li><span class="arithmatex">\(\sin 50 \degree \approx P_2(\dfrac{5\pi}{18}) \approx 0.76543\)</span></li>
<li><span class="arithmatex">\(R_2(x) = \dfrac{- \cos \xi_x}{3!}(x - \dfrac{\pi}{6})(x - \dfrac{\pi}{4})(x - \dfrac{\pi}{3}),\ \dfrac{1}{2} &lt; \cos \xi_x &lt; \dfrac{\sqrt{3}}{2}\)</span></li>
<li><span class="arithmatex">\(0.00044 &lt; R_2(\dfrac{5 \pi}{18}) &lt; 0.00077\)</span>，所以二次插值的误差<span><span class="heti-spacing"> </span><span class="arithmatex">\(\approx 0.00061\)</span></span></li>
</ul>
</li>
</ul>
<p><strong>注</strong> ：看起来更高次的插值法通常会带来更好的结果，但并不总是如此。</p>
<h3 id="nevilles-method">Neville's Method<a class="headerlink" href="#nevilles-method" title="Permanent link">⚓︎</a></h3>
<p><strong>拉格朗日多项式的缺陷</strong> ：如果发现当前拉格朗日多项式的精度不够，那我们就会考虑更多的插值点。但这样的话我们就得从头开始计算拉格朗日基，前面的工作都浪费掉了。</p>
<p>而接下来介绍的<span class="heti-skip"><span class="heti-spacing"> </span>Neville<span class="heti-spacing"> </span></span>法就能利用之前算好的插值多项式继续计算，无需重复计算。</p>
<p><strong>定义</strong> ：令<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f\)</span><span class="heti-spacing"> </span></span>是关于<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(x_0, x_1, \dots, x_n\)</span><span class="heti-spacing"> </span></span>的函数，并假设<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(m_1, \dots, m_k\)</span><span class="heti-spacing"> </span></span>是<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(k\)</span><span class="heti-spacing"> </span></span>个不同的整数且满足<span><span class="heti-spacing"> </span><span class="arithmatex">\(\forall i, 0 \le m_i \le n\)</span></span>。拉格朗日多项式在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(k\)</span><span class="heti-spacing"> </span></span>个点<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(x_{m_1}, \dots, x_{m_k}\)</span><span class="heti-spacing"> </span></span>上与<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f(x)\)</span><span class="heti-spacing"> </span></span>具有相同值时，记作<span><span class="heti-spacing"> </span><span class="arithmatex">\(P_{m_1, \dots, m_k}(x)\)</span></span>。</p>
<p><strong>定理</strong> ：</p>
<p>令<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f\)</span><span class="heti-spacing"> </span></span>是关于<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(x_0, x_1, \dots, x_k\)</span><span class="heti-spacing"> </span></span>的函数，并令<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(x_i, x_j\)</span><span class="heti-spacing"> </span></span>为其中两个不相等的数，那么：</p>
<div class="arithmatex">\[
P(x) = \dfrac{(x - x_j)P_{0, 1, \dots, j-1, j+1, \dots, k}(x) - (x - x_i)P_{0, 1, \dots, i-1, i+1, \dots, k}(x)}{x_i - x_j}
\]</div>
<p>描述了在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(k+1\)</span><span class="heti-spacing"> </span></span>个点<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(x_0, x_1, \dots, x_k\)</span><span class="heti-spacing"> </span></span>上向<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f\)</span><span class="heti-spacing"> </span></span>插值的第<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(k\)</span><span class="heti-spacing"> </span></span>个拉格朗日多项式。</p>
<p>上述定理表明插值多项式可以<strong>递归</strong>生成。比如，它们可以以下表所示的方式，一行行地生成插值多项式：</p>
<div class="arithmatex">\[
\begin{matrix}
x_0 &amp; P_0 &amp; &amp; &amp; &amp; \\
x_1 &amp; P_1 &amp; P_{0, 1} &amp; &amp; &amp; \\
x_2 &amp; P_2 &amp; P_{1, 2} &amp; P_{0, 1, 2} &amp; &amp; \\
x_3 &amp; P_3 &amp; P_{2, 3} &amp; P_{1, 2, 3} &amp; P_{0, 1, 2, 3} \\
x_4 &amp; P_4 &amp; P_{3, 4} &amp; P_{2, 3, 4} &amp; P_{1, 2, 3, 4} &amp; P_{0, 1, 2, 3, 4}
\end{matrix}
\]</div>
<p>上述过程被称为 <strong><span>Neville<span class="heti-spacing"> </span></span>法</strong>。但<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(P\)</span><span class="heti-spacing"> </span></span>的记号显得过于笨重（一堆下标表示参与到多项式中的插值点<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>。观察发现，只需要两个下标就行了——我们用新的记号<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(Q_{i, j}(x)\ (0 \le j \le i)\)</span><span class="heti-spacing"> </span></span>来表示阶数为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(j\)</span><span class="heti-spacing"> </span></span>的，在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\((j+1)\)</span><span class="heti-spacing"> </span></span>个数<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(x_{i-j}, x_{i-j+1}, \dots, x_{i-1}, x_i\)</span><span class="heti-spacing"> </span></span>上的插值多项式，即：<span class="arithmatex">\(Q_{i, j} = P_{i-j, i-j+1, \dots, i-1, i}\)</span>。那么上面的表格就可以转化为：</p>
<div class="arithmatex">\[
\begin{matrix}
x_0 &amp; Q_{0, 0} &amp; &amp; &amp; &amp; \\
x_1 &amp; Q_{1, 0} &amp; Q_{1, 1} &amp; &amp; &amp; \\
x_2 &amp; Q_{2, 0} &amp; Q_{2, 1} &amp; Q_{2, 2} &amp; &amp; \\
x_3 &amp; Q_{3, 0} &amp; Q_{3, 1} &amp; Q_{3, 2} &amp; Q_{3, 3} \\
x_4 &amp; Q_{4, 0} &amp; Q_{4, 1} &amp; Q_{4, 2} &amp; Q_{4, 3} &amp; Q_{4, 4}
\end{matrix}
\]</div>
<p>而上面定理给出的递推公式可以转化为：</p>
<div class="arithmatex">\[
Q_{i, j}(x) = \dfrac{(x - x_{i - j})Q_{i, j-1}(x) - (x - x_i)Q_{i-1, j-1}(x)}{x_i - x_{i - j}}
\]</div>
<p>观察发现，求上面表格某一项的值时，我们会用到其左侧和左上角的两个项。</p>
<p><strong>算法：<span>Neville<span class="heti-spacing"> </span></span>迭代插值</strong></p>
<p>求解对于数<span><span class="heti-spacing"> </span><span class="arithmatex">\(x\)</span></span>，在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n+1\)</span><span class="heti-spacing"> </span></span>个不同的数<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(x_0, \dots, x_n\)</span><span class="heti-spacing"> </span></span>上的函数<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f\)</span><span class="heti-spacing"> </span></span>的插值多项式<span><span class="heti-spacing"> </span><span class="arithmatex">\(P\)</span></span>。</p>
<ul>
<li>输入：数<span><span class="heti-spacing"> </span><span class="arithmatex">\(x_0, x_1, \dots, x_n\)</span></span>；值<span><span class="heti-spacing"> </span><span class="arithmatex">\(f(x_0), f(x_1), \dots, f(x_n)\)</span></span>，分别作为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(Q\)</span><span class="heti-spacing"> </span></span>的第<span class="heti-skip"><span class="heti-spacing"> </span>1<span class="heti-spacing"> </span></span>列<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(Q_{0, 0}, Q_{1, 0}, \dots, Q_{n, 0}\)</span><span class="heti-spacing"> </span></span>上的值。</li>
<li>输出：表<span><span class="heti-spacing"> </span><span class="arithmatex">\(Q\)</span></span>，其中<span><span class="heti-spacing"> </span><span class="arithmatex">\(P(x) = Q_{n, n}\)</span></span></li>
</ul>
<div class="language-c highlight"><pre><span></span><code><span id="__span-16-1"><a href="#__codelineno-16-1" id="__codelineno-16-1" name="__codelineno-16-1"></a><span class="n">Step</span><span class="w"> </span><span class="mi">1</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">n</span><span class="o">:</span>
</span><span id="__span-16-2"><a href="#__codelineno-16-2" id="__codelineno-16-2" name="__codelineno-16-2"></a><span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">i</span><span class="o">:</span>
</span><span id="__span-16-3"><a href="#__codelineno-16-3" id="__codelineno-16-3" name="__codelineno-16-3"></a><span class="w">                </span><span class="n">set</span><span class="w"> </span><span class="n">Q</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">((</span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">j</span><span class="p">])</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">Q</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="mi">-1</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">Q</span><span class="p">[</span><span class="n">i</span><span class="mi">-1</span><span class="p">][</span><span class="n">j</span><span class="mi">-1</span><span class="p">])</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">j</span><span class="p">]);</span>
</span><span id="__span-16-4"><a href="#__codelineno-16-4" id="__codelineno-16-4" name="__codelineno-16-4"></a><span class="n">Step</span><span class="w"> </span><span class="mi">2</span><span class="w">  </span><span class="n">Output</span><span class="p">(</span><span class="n">Q</span><span class="p">);</span>
</span><span id="__span-16-5"><a href="#__codelineno-16-5" id="__codelineno-16-5" name="__codelineno-16-5"></a><span class="w">        </span><span class="n">STOP</span><span class="p">;</span>
</span></code></pre></div>
<h2 id="divided-difference">Divided Difference<a class="headerlink" href="#divided-difference" title="Permanent link">⚓︎</a></h2>
<blockquote>
<p>Divided differences is a recursive division process. Given a sequence of data points <span class="arithmatex">\((x_0,y_0),\dots,(x_n,y_n)\)</span>, the method calculates the coefficients of the interpolation polynomial of these points in the Newton form.  -- <a href="https://en.wikipedia.org/wiki/Divided_differences">Wikipedia</a></p>
</blockquote>
<ul>
<li>
<p><strong><span>1<span class="heti-spacing"> </span></span>阶差商</strong>：<span class="arithmatex">\(f[x_i, x_j] = \dfrac{f(x_i) - f(x_j)}{x_i - x_j} (i \ne j, x_i \ne x_j)\)</span></p>
</li>
<li>
<p><strong><span>2<span class="heti-spacing"> </span></span>阶差商</strong>：<span class="arithmatex">\(f[x_i, x_j, x_k] = \dfrac{f[x_i, x_j] - f[x_j, x_k]}{x_i - x_k} (i \ne k, x_i \ne x_k)\)</span></p>
</li>
<li>
<p><strong><span><span class="arithmatex">\(k+1\)</span><span class="heti-spacing"> </span></span>阶差商</strong>：</p>
</li>
</ul>
<p>$$
  \begin{align}
  f[x_0, \dots, x_{k+1}] &amp; = \dfrac{f[\textcolor{cornflowerblue}{x_0}, x_1, \dots, x_k] - f[x_1, \dots, x_k, \textcolor{cornflowerblue}{x_{k+1}}]}{\textcolor{cornflowerblue}{x_0 - x_{k+1}}} \notag \
  &amp; = \dfrac{f[x_0, \dots, x_{k-1}, \textcolor{cornflowerblue}{x_k}] - f[x_0, \dots, x_{k-1}, \textcolor{cornflowerblue}{x_{k+1}}]}{\textcolor{cornflowerblue}{x_k - x_{k+1}}} \notag
  \end{align}
  $$</p>
<p>事实上，<span class="arithmatex">\(f[x_0, \dots, x_k] = \sum\limits_{i=0}^k \dfrac{f(x_i)}{\omega_{k+1}' (x_i)}\)</span>，其中<span><span class="heti-spacing"> </span><span class="arithmatex">\(\omega_{k+1}(x) = \prod\limits_{i=0}^k (x - x_i), \omega_{k+1}'(x_i) = \prod\limits_{\substack{j = 0 \\ j \ne i}}^k (x_i - x_j)\)</span></span>。这个公式的要点在于：<span><span class="arithmatex">\(f[x_0, \dots, x_k]\)</span><span class="heti-spacing"> </span></span>的值和<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(x_0, \dots, x_k\)</span><span class="heti-spacing"> </span></span>的顺序无关。</p>
<h3 id="newtons-interpolation">Newton's Interpolation<a class="headerlink" href="#newtons-interpolation" title="Permanent link">⚓︎</a></h3>
<p>目标：得到<span><span class="heti-spacing"> </span><span class="arithmatex">\(N_n(x) = a_0 + a_1(x - x_0) + a_2(x - x_0)(x - x_1) + \dots + a_n(x - x_0) \dots (x - x_{n-1})\)</span></span></p>
<p>我们将<span class="heti-skip"><span class="heti-spacing"> </span>1<span class="heti-spacing"> </span></span>阶差商、<span>2<span class="heti-spacing"> </span></span>阶差商、...、<span><span class="arithmatex">\(k+1\)</span><span class="heti-spacing"> </span></span>阶差商展开，得到：</p>
<div class="arithmatex">\[
\begin{cases}
f(x) = f(x_0) + (x - x_0)f[x, x_0] &amp; (1)\\
f[x, x_0] = f[x_0, x_1] + (x - x_1)f[x, x_0, x_1] &amp; (2)\\
\dots\ \dots\ \dots\\
f[x, x_0, \dots, x_{n-1}] = f[x_0, \dots, x_n] + (x - x_n) f[x, x_0, \dots, x_n] &amp; (n-1)
\end{cases}
\]</div>
<p>计算<span><span class="heti-spacing"> </span><span class="arithmatex">\((1) + (x - x_0) \times (2) + \dots + (x - x_0) \dots (x - x_{n-1}) \times (n-1)\)</span></span>，得到：</p>
<div class="arithmatex">\[
\begin{align}
f(x) = &amp; \textcolor{red}{f(x_0) + f[x_0, x_1](x - x_0) + f[x_0, x_1, x_2](x - x_0)(x - x_1) + \dots} \notag \\
&amp; \textcolor{red}{+ f[x_0, \dots, x_n](x - x_0) \dots (x - x_{n-1})} \notag \\
&amp; \textcolor{green}{+ f[x, x_0, \dots, x_n](x - x_0) \dots (x - x_{n-1})(x - x_n)} \notag
\end{align}
\]</div>
<p>其中红色部分就是我们要求的<span><span class="heti-spacing"> </span><span class="arithmatex">\(N_n(x)\)</span></span> ，而绿色部分是<span><span class="heti-spacing"> </span><span class="arithmatex">\(R_n(x)\)</span></span>。所以，<span class="arithmatex">\(a_i = f[x_0, \dots, x_i]\)</span></p>
<p><strong>算法：牛顿插值差商公式</strong></p>
<p>求得对于数<span><span class="heti-spacing"> </span><span class="arithmatex">\(x\)</span></span>，在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n+1\)</span><span class="heti-spacing"> </span></span>个不同的数<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(x_0, \dots, x_n\)</span><span class="heti-spacing"> </span></span>上的函数<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f\)</span><span class="heti-spacing"> </span></span>的插值多项式<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(P\)</span><span class="heti-spacing"> </span></span>的差商系数。</p>
<ul>
<li>输入：数<span><span class="heti-spacing"> </span><span class="arithmatex">\(x_0, x_1, \dots, x_n\)</span></span>；值<span><span class="heti-spacing"> </span><span class="arithmatex">\(f(x_0), f(x_1), \dots, f(x_n)\)</span></span>，分别记作<span><span class="heti-spacing"> </span><span class="arithmatex">\(F_{0, 0}, F_{1, 0}, \dots, F_{n,0}\)</span></span>。</li>
<li>输出：数<span><span class="heti-spacing"> </span><span class="arithmatex">\(F_{0, 0}, F_{1, 1}, F_{n, n}\)</span></span>，其中<span><span class="heti-spacing"> </span><span class="arithmatex">\(P(x) = \sum\limits_{i=0}^n F_{i, i} \prod_{j=0}^{i-1} (x - x_j)\)</span></span></li>
</ul>
<div class="language-c highlight"><pre><span></span><code><span id="__span-17-1"><a href="#__codelineno-17-1" id="__codelineno-17-1" name="__codelineno-17-1"></a><span class="n">Step</span><span class="w"> </span><span class="mi">1</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">n</span><span class="o">:</span>
</span><span id="__span-17-2"><a href="#__codelineno-17-2" id="__codelineno-17-2" name="__codelineno-17-2"></a><span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">i</span><span class="o">:</span>
</span><span id="__span-17-3"><a href="#__codelineno-17-3" id="__codelineno-17-3" name="__codelineno-17-3"></a><span class="w">                </span><span class="n">set</span><span class="w"> </span><span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="mi">-1</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="mi">-1</span><span class="p">][</span><span class="n">j</span><span class="mi">-1</span><span class="p">])</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">j</span><span class="p">]);</span>
</span><span id="__span-17-4"><a href="#__codelineno-17-4" id="__codelineno-17-4" name="__codelineno-17-4"></a><span class="n">Step</span><span class="w"> </span><span class="mi">2</span><span class="w">  </span><span class="n">Output</span><span class="p">(</span><span class="n">F</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">F</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">F</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">n</span><span class="p">]);</span><span class="w">  </span><span class="c1">// F[i][i] is f[x[0], x[1], ..., x[i]]</span>
</span><span id="__span-17-5"><a href="#__codelineno-17-5" id="__codelineno-17-5" name="__codelineno-17-5"></a><span class="w">        </span><span class="n">STOP</span><span class="p">;</span>
</span></code></pre></div>
<p><strong>注</strong></p>
<ul>
<li>因为第<span class="heti-skip"><span class="heti-spacing"> </span>n<span class="heti-spacing"> </span></span>个插值多项式是唯一的，所以<span><span class="heti-spacing"> </span><span class="arithmatex">\(N_n(x) \equiv P_n(x)\)</span></span></li>
<li>
<p>它们必须有相同的截断误差，即：</p>
<div class="arithmatex">\[
\begin{align}
&amp; f[x, x_0, \dots, x_n] \omega_{k+1} (x) = \dfrac{f^{(n+1)}(\xi_x)}{(n+1)!} \omega_{k+1}(x) \notag \\
&amp; \Rightarrow f[x_0, \dots, x_k] = \dfrac{f^{(k)}(\xi)}{k!}, \xi \in (x_{\text{min}}, x_{\text{max}}) \notag
\end{align}
\]</div>
</li>
<li>
<p>牛顿插值法的求解过程和<span class="heti-skip"><span class="heti-spacing"> </span>Neville<span class="heti-spacing"> </span></span>法类似：</p>
<div class="arithmatex">\[
\begin{matrix}
f(x_0) &amp; &amp; &amp; &amp; &amp; \notag \\
f(x_1) &amp; f[x_0, x_1] &amp; &amp; &amp; &amp; \notag \\
f(x_2) &amp; f[x_1, x_2] &amp; f[x_0, x_1, x_2] &amp; &amp; &amp; \notag \\
\dots &amp; \dots &amp; \dots &amp; &amp; &amp; \notag \\
f(x_{n-1}) &amp; \dots &amp; \dots &amp; &amp; &amp; \notag \\
f(x_n) &amp; f[x_{n-1}, x_n] &amp; f[x_{n-2}, x_{n-1}, x_n] &amp; &amp; f[x_0, \dots, x_n] \notag \\
f(x_{n+1}) &amp; f[x_n, x_{n+1}] &amp; f[x_{n-1}, x_n x_{n+1}] &amp; \dots &amp; f[x_1, \dots, x_{n+1}] &amp; f[x_0, \dots, x_{n+1}] \notag 
\end{matrix}
\]</div>
</li>
</ul>
<h3 id="formulae-with-equal-spacing">Formulae with Equal Spacing<a class="headerlink" href="#formulae-with-equal-spacing" title="Permanent link">⚓︎</a></h3>
<p>如果这些点是等间距的，即<span><span class="heti-spacing"> </span><span class="arithmatex">\(x_i = x_0 + ih\ (i = 0, \dots, n)\)</span></span>，那么：</p>
<ul>
<li><strong>前向差</strong>(forward difference)：<span class="arithmatex">\(\Delta f_i = f_{i+1} - f_i, \Delta^k f_i = \Delta(\Delta^{k-1} f_i) = \Delta^{k-1} f_{i+1} - \Delta^{k-1} f_i\)</span></li>
<li><strong>后向差</strong>(backward difference)：：<span class="arithmatex">\(\nabla f_i = f_i - f_{i-1}, \nabla^k f_i = \nabla(\nabla^{k-1} f_i) = \nabla^{k-1} f_i - \nabla^{k-1} f_{i-1}\)</span></li>
<li><strong>中心差</strong>(centered difference)：<span class="arithmatex">\(\delta^k f_i = \delta^{k-1} f_{i+\frac{1}{2}} - \delta^{k-1} f_{i - \frac{1}{2}}\)</span>，其中<span><span class="heti-spacing"> </span><span class="arithmatex">\(f_{i \pm \frac{1}{2}} = f(x_i \pm \dfrac{h}{2})\)</span></span></li>
</ul>
<h3 id="some-important-properties">Some Important Properties<a class="headerlink" href="#some-important-properties" title="Permanent link">⚓︎</a></h3>
<ul>
<li>线性：<span class="arithmatex">\(\Delta(a \cdot f(x) + b \cdot g(x)) = a \Delta f + b \Delta g\)</span></li>
<li>如果<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f(x)\)</span><span class="heti-spacing"> </span></span>是一个<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(m\)</span><span class="heti-spacing"> </span></span>阶多项式，那么<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\Delta^k f(x)\ (0 \le k \le m)\)</span><span class="heti-spacing"> </span></span>是一个<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(m - k\)</span><span class="heti-spacing"> </span></span>阶多项式且<span><span class="heti-spacing"> </span><span class="arithmatex">\(\Delta^k f(x) = 0\ (k &gt; m)\)</span></span></li>
<li>差值还能从以下函数中得到：</li>
<li><span class="arithmatex">\(\Delta^n f_k = \sum\limits_{j=0}^n (-1)^j \left( \begin{array}{cccc}n \\ j\end{array}\right) f_{n+k-j}\)</span></li>
<li>
<p><span class="arithmatex">\(\nabla^n f_k = \sum\limits_{j=0}^n (-1)^{n-j} \left( \begin{array}{cccc}n \\ j\end{array}\right) f_{k+j-n}\)</span></p>
</li>
<li>
<p>反之亦然：<span class="arithmatex">\(f_{n+k} = \sum\limits_{j=0}^n \left( \begin{array}{cccc}n \\ j\end{array}\right) \Delta^j f_k\)</span></p>
</li>
<li><span class="arithmatex">\(f[x_0, \dots, x_k] = \dfrac{\Delta^k f_0}{k! h^k}, f[x_n, x_{n-1}, \dots, x_{n-k}] = \dfrac{\nabla^k f_n}{k!h^k}\)</span>。从<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(R_n\)</span><span class="heti-spacing"> </span></span>可以得到：<span class="arithmatex">\(f^{(k)}(\xi) = \dfrac{\Delta^k f_0}{h^k}\)</span></li>
</ul>
<p><strong>总结</strong></p>
<ul>
<li>
<p><strong>牛顿前向差公式</strong>(Newton forward-difference formula)：令<span><span class="heti-spacing"> </span><span class="arithmatex">\(x = x_0 + th\)</span></span>，那么 </p>
<div class="arithmatex">\[
\begin{align}
N_n(x) &amp; = N_n(x_0 + th) = \sum\limits_{k=0}^n \left( \begin{array}{cccc}t \\ k\end{array}\right) \Delta^k f(x_0), \notag \\
&amp; = f(x_0) + t \Delta f(x_0) + \dfrac{t(t-1)}{2!} \Delta^2 f(x_0) + \dots + \dfrac{t(t-1) \dots (t-n+1)}{n!} \Delta^n f(x_0) \notag \\
R_n(x) &amp; = \dfrac{f^{(n+1)} (\xi)}{(n+1)!} t(t-1) \dots (t-n)h^{n+1}, \xi \in (x_0, x_n) \notag
\end{align}
\]</div>
</li>
<li>
<p><strong>牛顿后向差公式</strong>(Newton backward-difference formula)：颠倒点的顺序，即计算<span><span class="heti-spacing"> </span><span class="arithmatex">\(N_n(x) = f(x_n) + f[x_n, x_{n-1}](x - x_n) + \dots + f[x_n, \dots, x_0](x - x_n) \dots (x - x_1)\)</span></span>。令<span><span class="heti-spacing"> </span><span class="arithmatex">\(x = x_n + th\)</span></span>，那么 </p>
<div class="arithmatex">\[
\begin{align}
N_n(x) &amp; = N_n(x_n + th) = \sum\limits_{k=0}^n \underbrace{(-1)^k \left( \begin{array}{cccc}-t \\ k\end{array}\right)}_{C_{t+k-1}^k} \nabla^k f(x_n) \notag \\
&amp; = f(x_n) + t \nabla f(x_n) + \dfrac{t(t+1)}{2!} \nabla^2 f(x_n) + \dots + \dfrac{t(t+1) \dots (t+n-1)}{n!} \nabla^n f(x_n) \notag
\end{align}
\]</div>
</li>
</ul>
<h2 id="hermite-interpolation">Hermite Interpolation<a class="headerlink" href="#hermite-interpolation" title="Permanent link">⚓︎</a></h2>
<p><strong>密切多项式</strong> ：令<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(x_0, x_1, \dots, x_n\)</span><span class="heti-spacing"> </span></span>为在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\([a, b]\)</span><span class="heti-spacing"> </span></span>上的<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n+1\)</span><span class="heti-spacing"> </span></span>个不同的数，<span><span class="arithmatex">\(m_i\)</span><span class="heti-spacing"> </span></span>是和<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(x_i\)</span><span class="heti-spacing"> </span></span>关联的非负整数（<span class="arithmatex">\(i = 0, \dots, n\)</span><heti-adjacent class="heti-adjacent-half">）</heti-adjacent>。假设<span><span class="heti-spacing"> </span><span class="arithmatex">\(f \in C^m[a, b]\)</span></span>，其中<span><span class="heti-spacing"> </span><span class="arithmatex">\(m = \max\limits_{0 \le i \le n}m_i\)</span></span>，那么用于近似<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f\)</span><span class="heti-spacing"> </span></span>的<strong>密切多项式</strong><span>(osculating polynomial)<span class="heti-spacing"> </span></span>为满足以下条件的阶数最小的多项式<span><span class="heti-spacing"> </span><span class="arithmatex">\(P(x)\)</span></span>：</p>
<div class="arithmatex">\[
\dfrac{d^k P(x_i)}{dx^k} = \dfrac{d^k f(x_i)}{dx^k},\ \text{for each } i = 0, \dots, n \text{ and } k = 0, \dots, m
\]</div>
<blockquote>
<p>相比前面提到的插值多项式，密切多项式还要求<strong><span>k<span class="heti-spacing"> </span></span>阶导数相等</strong>，因而得到了更准确、更光滑的插值曲线。</p>
</blockquote>
<p>目标：找到一个<strong>密切多项式</strong> <span class="arithmatex">\(P(x)\)</span>，使得<span><span class="heti-spacing"> </span><span class="arithmatex">\(\forall i = 0, 1, \dots, n, P(x_i) = f(x_i), P'(x_i) = f'(x_i), \dots, P^{(m_i)}(x_i) = f^{(m_i)}(x_i)\)</span></span>。</p>
<p><strong>注</strong></p>
<ul>
<li>给定<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(N\)</span><span class="heti-spacing"> </span></span>个条件（即有<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(N\)</span><span class="heti-spacing"> </span></span>个方程<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，<span><span class="arithmatex">\(N - 1\)</span><span class="heti-spacing"> </span></span>阶多项式就能确定下来</li>
<li>
<p>与<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f\)</span><span class="heti-spacing"> </span></span>以及所有在<strong>一个点</strong> <span><span class="arithmatex">\(x_0\)</span><span class="heti-spacing"> </span></span>上的<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\le m_0\)</span><span class="heti-spacing"> </span></span>阶的导数吻合的密切多项式就是一个<strong>泰勒多项式</strong>：</p>
<div class="arithmatex">\[
P(x) = f(x_0) + f'(x_0)(x - x_0) + \dots + \dfrac{f^{(m_0)}(x_0)}{m_0!}(x - x_0)^{m_0}
\]</div>
<p>且余项<span><span class="heti-spacing"> </span><span class="arithmatex">\(R(x) = f(x) - \varphi(x) = \dfrac{f^{(m_0 + 1)}(\xi)}{(m_0 + 1)!}(x - x_0)^{(m_0 + 1)}\)</span></span></p>
</li>
<li>
<p>当<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\forall i = 0, 1, \dots, n,\ m_i = 1\)</span><span class="heti-spacing"> </span></span>时，此时的多项式为<strong>埃尔米特多项式</strong>(Hermite polynomials)</p>
</li>
</ul>
<p>一般情况下，给定<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(x_0, \dots, x_n; y_0, \dots, y_n\)</span><span class="heti-spacing"> </span></span>以及<span><span class="heti-spacing"> </span><span class="arithmatex">\(y_0', \dots, y_n'\)</span></span>，埃尔米特多项式<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(H_{2n+1}(x)\)</span><span class="heti-spacing"> </span></span>满足对于所有的<span><span class="heti-spacing"> </span><span class="arithmatex">\(i\)</span></span>，<span><span class="arithmatex">\(H_{2n+1}(x_i) = y_i\)</span><span class="heti-spacing"> </span></span>且<span><span class="heti-spacing"> </span><span class="arithmatex">\(H_{2n+1}'(x_i) = y_i'\)</span></span></p>
<p><strong>用待定系数法求解埃尔米特多项式</strong></p>
<p>令<span><span class="heti-spacing"> </span><span class="arithmatex">\(H_{2n+1}(x) = \sum\limits_{i=0}^n y_i h_i(x) + \sum\limits_{i=0}^n y_i' \widehat{h_i}(x)\)</span></span>，其中<span><span class="heti-spacing"> </span><span class="arithmatex">\(h_i(x_j) = \delta_{ij}, h_i'(x_j) = 0, \widehat{h_i}(x_j) = 0, \widehat{h_i}'(x_j) = \delta_{ij}\)</span></span></p>
<ul>
<li><span class="arithmatex">\(h_i(x)\)</span>：对应<strong>函数值</strong> <span class="arithmatex">\(y_i\)</span><ul>
<li><span><span class="arithmatex">\(x_0, \dots, \widehat{x_i}, \dots, x_n\)</span><span class="heti-spacing"> </span></span>是重数为<span class="heti-skip"><span class="heti-spacing"> </span>2<span class="heti-spacing"> </span></span>的根<span><span class="heti-spacing"> </span><span class="arithmatex">\(\Rightarrow\ h_i(x) = (A_i x + B_i) L_{n, i}^2(x)\)</span></span></li>
<li><span><span class="arithmatex">\(A_i, B_i\)</span><span class="heti-spacing"> </span></span>能通过<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(h_i(x_i) = 1, h_i'(x_i) = 0\)</span><span class="heti-spacing"> </span></span>求解</li>
<li><span class="arithmatex">\(h_i(x) = [1 - 2L_{n, i}'(x_i)(x - x_i)L_{n, i}^2(x)]\)</span></li>
</ul>
</li>
<li><span class="arithmatex">\(\widehat{h_i}(x)\)</span>：对应<strong>导数值</strong> <span class="arithmatex">\(y_i'\)</span><ul>
<li>除了<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(x_i\)</span><span class="heti-spacing"> </span></span>外，所有的根<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(x_0, \dots, x_n\)</span><span class="heti-spacing"> </span></span>的重数均为<span><span class="heti-spacing"> </span>2</span>，得到：</li>
<li><span class="arithmatex">\(\begin{cases}\widehat{h_i}(x) = C_i(x - x_i) L_{n, i}^2(x) \\ \widehat{h_i}'(x_i) = 1 \Rightarrow C_i = 1\end{cases} \quad \Rightarrow \quad \widehat{h_i}(x) = (x - x_i) L_{n, i}^2(x)\)</span></li>
</ul>
</li>
</ul>
<p>如果<span><span class="heti-spacing"> </span><span class="arithmatex">\(a = x_0 &lt; x_1 &lt; \dots &lt; x_n = b, f \in C^{2n}[a, b]\)</span></span>，那么<span><span class="heti-spacing"> </span><span class="arithmatex">\(R_n(x) = \dfrac{f^{(2n+2)}(\xi_x)}{(2n+2)!}\Big[\prod\limits_{i=0}^n (x - x_i) \Big]^2\)</span></span> </p>
<p><strong>思考</strong></p>
<p>题目：给定<span><span class="heti-spacing"> </span><span class="arithmatex">\(x_i = i + 1, i = 0, 1, 2, 3, 4, 5\)</span></span>，哪一个是<span><span class="heti-spacing"> </span><span class="arithmatex">\(\widehat{h_2}(x)\)</span></span>？</p>
<div style="text-align: center">
<img src="images/C3/6.png" width="80%/"/>
</div>
<p>答案：</p>
<div style="text-align: center">
<img src="images/C3/7.png" width="80%/"/>
</div>
<p><strong>例子</strong></p>
<p>例<span><span class="heti-spacing"> </span>1</span></p>
<p>题目：假设<span><span class="heti-spacing"> </span><span class="arithmatex">\(x_0 \ne x_1 \ne x_2\)</span></span>。给定<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f(x_0), f(x_1), f(x_2)\)</span><span class="heti-spacing"> </span></span>和<span><span class="heti-spacing"> </span><span class="arithmatex">\(f'(x_1)\)</span></span>，寻找多项式<span><span class="heti-spacing"> </span><span class="arithmatex">\(P(x)\)</span></span>，满足<span><span class="heti-spacing"> </span><span class="arithmatex">\(P(x_i) = f(x_i),\ i = 0, 1, 2\)</span></span>，且<span><span class="heti-spacing"> </span><span class="arithmatex">\(P'(x_1) = f'(x_1)\)</span></span>。并分析误差。</p>
<p>解答</p>
<p>首先，<span><span class="arithmatex">\(P(x)\)</span><span class="heti-spacing"> </span></span>的阶必须<span><span class="heti-spacing"> </span><span class="arithmatex">\(\le 3\)</span></span>（本题给出<span class="heti-skip"><span class="heti-spacing"> </span>4<span class="heti-spacing"> </span></span>个条件（<span>3<span class="heti-spacing"> </span></span>个函数值<span class="heti-skip"><span class="heti-spacing"> </span>+ 1<span class="heti-spacing"> </span></span>个导数值<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，根据前面“注”的第一条，最多能确定<span class="heti-skip"><span class="heti-spacing"> </span>3<span class="heti-spacing"> </span></span>阶多项式<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>。</p>
<p>与拉格朗日多项式类似，我们假设埃尔米特多项式的形式为：<span class="arithmatex">\(P_3(x) = \sum\limits_{i=0}^2 f(x_i) h_i(x) + f'(x_1) \widehat{h_1}(x)\)</span>。接着根据已知条件，用待定系数法可以得到：</p>
<div class="arithmatex">\[h_i(x_j) = \delta_{ij}, h_i'(x_1) = 0, \widehat{h_1}(x_i) = 0, \widehat{h_1}'(x_1) = 1\]</div>
<ul>
<li><span class="arithmatex">\(h_0(x)\)</span>：有根<span><span class="heti-spacing"> </span><span class="arithmatex">\(x_1, x_2\)</span></span>，且<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(h_0'(x_1) = 0 \quad \Rightarrow \quad x_1\)</span><span class="heti-spacing"> </span></span>是一个重根<ul>
<li><span class="arithmatex">\(\begin{cases}h_0(x) = C_0(x - x_1)^2(x - x_2) \\ h_0(x_0) = 1 \Rightarrow C_0\end{cases} \quad \Rightarrow \quad h_0(x) = \dfrac{(x - x_1)^2(x - x_2)}{(x_0 - x_1)^2(x_0 - x_2)}\)</span></li>
</ul>
</li>
<li><span class="arithmatex">\(h_2(x)\)</span>：与<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(h_0(x)\)</span><span class="heti-spacing"> </span></span>类似</li>
<li><span class="arithmatex">\(h_1(x)\)</span>：有根<span><span class="heti-spacing"> </span><span class="arithmatex">\(x_0, x_2 \Rightarrow h_1(x) = (Ax + B)(x - x_0)(x - x_2)\)</span></span>。<span><span class="arithmatex">\(A, B\)</span><span class="heti-spacing"> </span></span>可通过<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(h_1(x_1) = 0\)</span><span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(h_1'(x_1) = 0\)</span><span class="heti-spacing"> </span></span>求解</li>
<li><span class="arithmatex">\(\widehat{h_1}(x)\)</span>：有根<span><span class="heti-spacing"> </span><span class="arithmatex">\(x_0, x_1, x_2 \Rightarrow \widehat{h_1}(x) = C_1(x - x_0)(x - x_1)(x - x_2)\)</span></span>。<span><span class="arithmatex">\(h_1(x_1) = 1 \Rightarrow C_1\)</span><span class="heti-spacing"> </span></span>能被求解</li>
</ul>
<p>其误差分析类似拉格朗日误差分析：</p>
<div class="arithmatex">\[
\begin{align}
R_3(x) &amp; = f(x) - P_3(x) \notag \\
&amp; = K(x)(x - x_0)(x - x_1)^2(x - x_2) \notag \\
&amp; \Rightarrow K(x) = \dfrac{f^{(4)}(\xi_x)}{4!} \notag
\end{align}
\]</div>
<p>例<span><span class="heti-spacing"> </span>2</span></p>
<p>题目：</p>
<div style="text-align: center">
<img src="images/C3/16.png" width="80%/"/>
</div>
<p>解答：</p>
<p>根据已知条件，可以得到：</p>
<div class="arithmatex">\[
h_0(x) = \begin{cases}h_0(1) = 1 \\ h_0'(1) = 0 \\ h_0(2) = 0 \end{cases} \quad \widehat{h_0}(x) = \begin{cases}\widehat{h_0}(1) = 0 \\ \widehat{h_0'}(1) = 1 \\ \widehat{h_0}(2) = 0 \end{cases} \quad h_1(x) = \begin{cases}h_1(1) = 0 \\ h_1'(1) = 0 \\ h_1(2) = 1 \end{cases}
\]</div>
<p>下面按照从易到难的顺序求解这<span class="heti-skip"><span class="heti-spacing"> </span>3<span class="heti-spacing"> </span></span>个未知量：</p>
<ul>
<li>求解<span><span class="heti-spacing"> </span><span class="arithmatex">\(h_1(x)\)</span></span><ul>
<li>由条件知，<span><span class="arithmatex">\(x = 1\)</span><span class="heti-spacing"> </span></span>是二重根</li>
<li>那么可以令<span><span class="heti-spacing"> </span><span class="arithmatex">\(h_1(x) = C(x - 1)^2\)</span></span></li>
<li>再利用剩下那个条件，代进去计算，解得<span><span class="heti-spacing"> </span><span class="arithmatex">\(C = 1\)</span></span></li>
<li>所以<span><span class="heti-spacing"> </span><span class="arithmatex">\(h_1(x) = (x - 1)^2\)</span></span></li>
</ul>
</li>
<li>求解<span><span class="heti-spacing"> </span><span class="arithmatex">\(\widehat{h_0}(x)\)</span></span><ul>
<li>由条件知，<span><span class="arithmatex">\(x = 1, x = 2\)</span><span class="heti-spacing"> </span></span>均为该函数的根</li>
<li>那么可以令<span><span class="heti-spacing"> </span><span class="arithmatex">\(\widehat{h_0}(x) = C(x - 1)(x - 2)\)</span></span></li>
<li>利用剩下的导数条件（需要先对<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\widehat{h_0}(x)\)</span><span class="heti-spacing"> </span></span>求导<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，解得<span><span class="heti-spacing"> </span><span class="arithmatex">\(C = -1\)</span></span></li>
<li>所以<span><span class="heti-spacing"> </span><span class="arithmatex">\(\widehat{h_0}(x) = -(x - 1)(x - 2)\)</span></span></li>
</ul>
</li>
<li>求解<span><span class="heti-spacing"> </span><span class="arithmatex">\(h_0(x)\)</span></span><ul>
<li>由于根据已知条件只能确定<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(x = 2\)</span><span class="heti-spacing"> </span></span>是其中一根，另一根未知，所以只好假设<span><span class="heti-spacing"> </span><span class="arithmatex">\(h_0(x) = ax^2 + bx + c\)</span></span></li>
<li>将三个条件代进去，得到三元一次方程，解得<span><span class="heti-spacing"> </span><span class="arithmatex">\(a = -1, b = 2, c = 0\)</span></span></li>
<li>所以<span><span class="heti-spacing"> </span><span class="arithmatex">\(h_0(x) = -x^2 + 2x = x(2 - x)\)</span></span></li>
</ul>
</li>
</ul>
<p><strong>定理</strong>：</p>
<p>如果<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f \in C^1[a, b]\)</span><span class="heti-spacing"> </span></span>且<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(x_0, \dots, x_n \in [a, b]\)</span><span class="heti-spacing"> </span></span>是不同的数，那么在函数<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f\)</span><span class="heti-spacing"> </span></span>及其导数<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f'\)</span><span class="heti-spacing"> </span></span>一致的最小次数唯一多项式即为次数不超过<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(2n+1\)</span><span class="heti-spacing"> </span></span>的埃尔米特多项式：</p>
<div class="arithmatex">\[
H_{2n+1}(x) = \sum\limits_{j=0}^n f(x_j) H_{n,j}(x) + \sum\limits_{j=0}^n f'(x_j) \widehat{H}_{n,j}(x)
\]</div>
<p>其中<span><span class="heti-spacing"> </span><span class="arithmatex">\(H_{n,j} = [1 - 2(x - x_j) L'_{n,j}(x_j)]L_{n,j}^2(x)\)</span></span>，<span class="arithmatex">\(\widehat{H}_{n,j}(x) = (x - x_j) L^2_{n,j}(x)\)</span>。在这里，<span><span class="arithmatex">\(L_{n,j}(x)\)</span><span class="heti-spacing"> </span></span>指代的是<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n\)</span><span class="heti-spacing"> </span></span>阶多项式中第<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(j\)</span><span class="heti-spacing"> </span></span>个拉格朗日系数。</p>
<p>另外，若<span><span class="heti-spacing"> </span><span class="arithmatex">\(f \in C^{2n-2}[a, b]\)</span></span>，那么</p>
<div class="arithmatex">\[
f(x) = H_{2n+1}(x) + \dfrac{(x - x_0)^2 \dots (x - x_n)^2}{(2n+2)!}f^{(2n+2)}(\xi)
\]</div>
<p><span><span class="arithmatex">\(\xi\)</span><span class="heti-spacing"> </span></span>为某个满足<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(a &lt; \xi &lt; b\)</span><span class="heti-spacing"> </span></span>的数。</p>
<p><strong>算法：埃尔米特插值</strong></p>
<p>求得在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n+1\)</span><span class="heti-spacing"> </span></span>个不同的数<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(x_0, \dots, x_n\)</span><span class="heti-spacing"> </span></span>上的函数<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f\)</span><span class="heti-spacing"> </span></span>的埃尔米特插值多项式<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(H(x)\)</span><span class="heti-spacing"> </span></span>的系数。</p>
<ul>
<li>输入：数<span><span class="heti-spacing"> </span><span class="arithmatex">\(x_0, x_1, \dots, x_n\)</span></span>；值<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f(x_0), f(x_1), \dots, f(x_n)\)</span><span class="heti-spacing"> </span></span>以及<span><span class="heti-spacing"> </span><span class="arithmatex">\(f'(x_0), \dots, f'(x_n)\)</span></span></li>
<li>
<p>输出：数<span><span class="heti-spacing"> </span><span class="arithmatex">\(Q_{0,0}, Q_{1, 1}, \dots, Q_{2n+1, 2n+1}\)</span></span>，其中 </p>
<div class="arithmatex">\[
\begin{align}
H(x) = &amp; Q_{0,0} + Q_{1,1}(x - x_0) + Q_{2,2}(x - x_0)^2 + Q_{3,3}(x - x_0)^2(x - x_1) \notag \\
&amp; + Q_{4,4}(x - x_0)^2(x - x_1)^2 + \dots \notag \\
&amp; + Q_{2n+1, 2n+1}(x - x_0)^2(x - x_1)^2 \dots (x - x_{n-1})^2(x - x_n) \notag
\end{align}
\]</div>
</li>
</ul>
<div class="language-c highlight"><pre><span></span><code><span id="__span-18-1"><a href="#__codelineno-18-1" id="__codelineno-18-1" name="__codelineno-18-1"></a><span class="n">Step</span><span class="w"> </span><span class="mi">1</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="n">Step</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="mi">3</span><span class="o">:</span>
</span><span id="__span-18-2"><a href="#__codelineno-18-2" id="__codelineno-18-2" name="__codelineno-18-2"></a><span class="w">    </span><span class="n">Step</span><span class="w"> </span><span class="mi">2</span><span class="w">  </span><span class="n">Set</span><span class="w"> </span><span class="n">z</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span id="__span-18-3"><a href="#__codelineno-18-3" id="__codelineno-18-3" name="__codelineno-18-3"></a><span class="w">                </span><span class="n">z</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
</span><span id="__span-18-4"><a href="#__codelineno-18-4" id="__codelineno-18-4" name="__codelineno-18-4"></a><span class="w">                </span><span class="n">Q</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span><span id="__span-18-5"><a href="#__codelineno-18-5" id="__codelineno-18-5" name="__codelineno-18-5"></a><span class="w">                </span><span class="n">Q</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span><span id="__span-18-6"><a href="#__codelineno-18-6" id="__codelineno-18-6" name="__codelineno-18-6"></a><span class="w">                </span><span class="n">Q</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="err">`</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span><span id="__span-18-7"><a href="#__codelineno-18-7" id="__codelineno-18-7" name="__codelineno-18-7"></a><span class="w">    </span><span class="n">Step</span><span class="w"> </span><span class="mi">3</span><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">then</span><span class="w"> </span><span class="n">set</span><span class="w"> </span><span class="n">Q</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">Q</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">Q</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="mi">-1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">z</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="mi">-1</span><span class="p">]);</span>
</span><span id="__span-18-8"><a href="#__codelineno-18-8" id="__codelineno-18-8" name="__codelineno-18-8"></a><span class="n">Step</span><span class="w"> </span><span class="mi">4</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="o">:</span>
</span><span id="__span-18-9"><a href="#__codelineno-18-9" id="__codelineno-18-9" name="__codelineno-18-9"></a><span class="w">            </span><span class="k">for</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="n">set</span><span class="w"> </span><span class="n">Q</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">Q</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="mi">-1</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">Q</span><span class="p">[</span><span class="n">i</span><span class="mi">-1</span><span class="p">][</span><span class="n">j</span><span class="mi">-1</span><span class="p">])</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">z</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">j</span><span class="p">]);</span>
</span><span id="__span-18-10"><a href="#__codelineno-18-10" id="__codelineno-18-10" name="__codelineno-18-10"></a><span class="n">Step</span><span class="w"> </span><span class="mi">5</span><span class="w">  </span><span class="n">Output</span><span class="p">(</span><span class="n">Q</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">Q</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">Q</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">]);</span>
</span><span id="__span-18-11"><a href="#__codelineno-18-11" id="__codelineno-18-11" name="__codelineno-18-11"></a><span class="w">        </span><span class="n">STOP</span><span class="p">.</span>
</span></code></pre></div>
<h2 id="cubic-spline-interpolation">Cubic Spline Interpolation<a class="headerlink" href="#cubic-spline-interpolation" title="Permanent link">⚓︎</a></h2>
<p><strong>例子</strong></p>
<p>考虑关于函数<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f(x) = \dfrac{1}{1 + x^2}\)</span><span class="heti-spacing"> </span></span>在点<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(x_i = -5 + \dfrac{10}{n}i \in [-5, 5] \ (i = 0, \dots, n)\)</span><span class="heti-spacing"> </span></span>的拉格朗日多项式<span><span class="heti-spacing"> </span><span class="arithmatex">\(P_n(x)\)</span></span></p>
<div style="text-align: center">
<img src="images/C3/8.png" width="60%/"/>
</div>
<p>可以看到，我们无法用多项式（这些彩色曲线）较为准确地近似函数（黑色曲线<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>。正如前面所说，增加多项式的阶数不能保证更好的近似结果，因为高阶多项式更容易发生<strong>振荡</strong>(oscillation)，反而会加大误差（即<a href="https://en.wikipedia.org/wiki/Runge%27s_phenomenon"><strong>龙格现象</strong></a>(Runge's phenomenon)<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>。</p>
<p><strong>一些尝试</strong></p>
<p><strong>按段线性插值</strong>(piecewise linear interpolation)</p>
<p>思路：在每个子区间<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\([x_i, x_{i+1}]\)</span><span class="heti-spacing"> </span></span>上，通过线性多项式近似表示<span><span class="heti-spacing"> </span><span class="arithmatex">\(f(x)\)</span></span>，即：</p>
<div class="arithmatex">\[
f(x) \approx P_1(x) = \dfrac{x - x_{i+1}}{x_i - x_{i+1}}y_i + \dfrac{x - x_i}{x_{i+1} - x_i} y_{i+1} \text{ for } x \in [x_i, x_{i+1}]
\]</div>
<p>令<span><span class="heti-spacing"> </span><span class="arithmatex">\(h = \max |x_{i+1} - x_i|\)</span></span>，那么<span><span class="heti-spacing"> </span><span class="arithmatex">\(P_1^h(x) \xrightarrow{\text{uniform}} f(x), h \rightarrow 0\)</span></span></p>
<p><strong>缺点：不够平滑</strong></p>
<hr/>
<p><strong>埃尔米特按段多项式</strong>(Hermite Piecewise Polynomials)</p>
<p>思路：给定<span><span class="heti-spacing"> </span><span class="arithmatex">\(x_0, \dots, x_n;\ y_0, \dots, y_n;\ y_0', \dots, y_n'\)</span></span>，在区间<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\([x_i, x_{i+1}]\)</span><span class="heti-spacing"> </span></span>的两个端点上构造一个关于<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(y, y'\)</span><span class="heti-spacing"> </span></span>的<span class="heti-skip"><span class="heti-spacing"> </span>3<span class="heti-spacing"> </span></span>阶埃尔米特多项式</p>
<p><strong>缺点：计算导数不太容易</strong></p>
<hr/>
<p>这里介绍一种更好的方法：<strong>三次样条插值</strong>(cubic spline interpolation)。</p>
<p><strong>定义</strong></p>
<p>给定一个定义在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\([a, b]\)</span><span class="heti-spacing"> </span></span>上的函数<span><span class="heti-spacing"> </span><span class="arithmatex">\(f\)</span></span>，以及一组节点<span><span class="heti-spacing"> </span><span class="arithmatex">\(a = x_0 &lt; x_1 \dots &lt; x_n = b\)</span></span>，关于<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f\)</span><span class="heti-spacing"> </span></span>的<strong>三次样条插值器</strong><span>(cubic spline interpolant) <span class="arithmatex">\(S\)</span><span class="heti-spacing"> </span></span>是一个满足下面条件的函数：</p>
<ul>
<li><span><span class="arithmatex">\(S(x)\)</span><span class="heti-spacing"> </span></span>是一个分段函数，在每个子区间<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\([x_i, x_{i+1}]\)</span><span class="heti-spacing"> </span></span>上是一个三次多项式<span><span class="heti-spacing"> </span><span class="arithmatex">\(S_i(x)\)</span></span>（<span class="arithmatex">\(i = 0, 1, \dots, n - 1\)</span>）</li>
<li><span class="arithmatex">\(S(x_i) = f(x_i),\ i = 0, 1, \dots, n\)</span></li>
<li><span class="arithmatex">\(S_{i+1}(x_{i+1}) = S_i(x_{i+1}),\ i = 0, 1, \dots, n - 2\)</span></li>
<li><span class="arithmatex">\(S_{i+1}'(x_{i+1}) = S_i'(x_{i+1}),\ i = 0, 1, \dots, n - 2\)</span></li>
<li><span class="arithmatex">\(S_{i+1}''(x_{i+1}) = S_i''(x_{i+1}),\ i = 0, 1, \dots, n - 2\)</span></li>
</ul>
<blockquote>
<p>后面三个条件确保了三次样条插值的<strong>光滑性</strong>。</p>
</blockquote>
<div style="text-align: center">
<img src="images/C3/1.png" width="80%/"/>
</div>
<h3 id="method-of-bending-moment">Method of Bending Moment<a class="headerlink" href="#method-of-bending-moment" title="Permanent link">⚓︎</a></h3>
<p>令<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(h_j = x_j - x_{j-1}\)</span><span class="heti-spacing"> </span></span>且 对于<span><span class="heti-spacing"> </span><span class="arithmatex">\(x \in [x_{j-1}, x_j],\ S(x) = S_j(x)\)</span></span>（<span><span class="arithmatex">\(S_j(x)\)</span><span class="heti-spacing"> </span></span>是<span class="heti-skip"><span class="heti-spacing"> </span>3<span class="heti-spacing"> </span></span>阶多项式<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，那么<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(S_j''(x)\)</span><span class="heti-spacing"> </span></span>是一个<span class="heti-skip"><span class="heti-spacing"> </span>1<span class="heti-spacing"> </span></span>阶多项式，并能通过<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f\)</span><span class="heti-spacing"> </span></span>上的<span class="heti-skip"><span class="heti-spacing"> </span>2<span class="heti-spacing"> </span></span>个节点值确定下来。</p>
<p>假设<span><span class="heti-spacing"> </span><span class="arithmatex">\(S_j''(x_{j-1}) = M_{j-1}, S_j''(x_j) = M_j\)</span></span>（<strong>弯矩</strong>(bending moment)<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，那么<span><span class="heti-spacing"> </span><span class="arithmatex">\(\forall x \in [x_{j-1}, x_j]\)</span></span>，<span class="arithmatex">\(S_j''(x) = M_{j-1} \dfrac{x_j - x}{h_j} + M_j \dfrac{x - x_{j-1}}{h_j}\)</span></p>
<p>对<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(S_j''\)</span><span class="heti-spacing"> </span></span>积分，可以得到：</p>
<ul>
<li><span class="arithmatex">\(S_j'(x) = -M_{j-1} \dfrac{(x_j - x)^2}{2h_j} + M_{j-1} \dfrac{(x - x_{j-1})^2}{2h_j} + A_j\)</span></li>
<li><span class="arithmatex">\(S_j(x) = M_{j-1} \dfrac{(x_j - x)^3}{6h_j} + M_{j-1} \dfrac{(x - x_{j-1})^3}{6h_j} + A_jx + B_j\)</span></li>
</ul>
<p>其中<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A_j, B_j\)</span><span class="heti-spacing"> </span></span>能通过方程<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(S_j(x_{j-1}) = y_{j-1}, S_j(x_j) = y_j\)</span><span class="heti-spacing"> </span></span>求解。可以得到：</p>
<ul>
<li><span class="arithmatex">\(A_j = \dfrac{y_j - y_{j-1}}{h_j} - \dfrac{M_j - M_{j-1}}{6}h_j\)</span></li>
<li><span class="arithmatex">\(A_j x + B_j = (y_{j-1} - \dfrac{M_{j-1}}{6} h_j^2) \dfrac{x_j - x}{h_j} + (y_j - \dfrac{M_j}{6}h_j^2)\dfrac{x - x_{j-1}}{h_j}\)</span></li>
</ul>
<p>现在我们来求解<span><span class="heti-spacing"> </span><span class="arithmatex">\(M_j\)</span></span>：因为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(S'\)</span><span class="heti-spacing"> </span></span>在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(x_j\)</span><span class="heti-spacing"> </span></span>上是连续的，所以：</p>
<ul>
<li><span class="arithmatex">\([x_{j-1}, x_j]\)</span>: <span class="arithmatex">\(S_j'(x) = -M_{j-1} \dfrac{(x_j - x)^2}{2h_j} + M_j \dfrac{(x - x_{j-1})^2}{2h_j} + f[x_{j-1}, x_j] - \dfrac{M_j - M_{j-1}}{6}h_j\)</span></li>
<li><span class="arithmatex">\([x_j, x_{j+1}]\)</span>: <span class="arithmatex">\(S_{j+1}'(x) = -M_j \dfrac{(x_{j+1} - x)^2}{2h_{j+1}} + M_{j+1} \dfrac{(x - x_j)^2}{2h_{j+1}} + f[x_j, x_{j+1}] - \dfrac{M_{j+1} - M_j}{6}h_{j+1}\)</span></li>
</ul>
<p>根据<span><span class="heti-spacing"> </span><span class="arithmatex">\(S_j'(x_j) = S_{j+1}'(x_j)\)</span></span>，我们可以结合<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(M_{j-1}, M_j, M_{j+1}\)</span><span class="heti-spacing"> </span></span>的系数——定义<span><span class="heti-spacing"> </span><span class="arithmatex">\(\lambda_j = \dfrac{h_{j+1}}{h_j + h_{j+1}}, \mu_j = 1 - \lambda_j, g_j = \dfrac{6}{h_j + h_{j+1}} (f[x_j, x_{j+1}] - f[x_{j-1}, x_j])\)</span></span>，可以得到：<span class="arithmatex">\(\mu_j M_{j-1} + 2M_j + \lambda_j M_{j+1} = g_j\ (1 \le j \le n - 1)\)</span>（下图就是这个递推式的矩阵表示（一个三对角矩阵<heti-adjacent class="heti-adjacent-half">）</heti-adjacent><heti-adjacent class="heti-adjacent-half">）</heti-adjacent>。也就是说，我们有<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n+1\)</span><span class="heti-spacing"> </span></span>个未知数，但只有<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n-1\)</span><span class="heti-spacing"> </span></span>个方程，所以还需要<span class="heti-skip"><span class="heti-spacing"> </span>2<span class="heti-spacing"> </span></span>个额外的边界条件。</p>
<div style="text-align: center">
<img src="images/C3/2.png" width="50%/"/>
</div>
<ul>
<li>
<p><strong>固定边界</strong>(clamped boundary)：<span class="arithmatex">\(S'(a) = y_0', S'(b) = y_n'\)</span></p>
</li>
<li>
<p><span class="arithmatex">\([a, x_1]\)</span>: <span class="arithmatex">\(S_1'(x) = -M_0 \dfrac{(x_1 - x)^2}{2h_1} + M_1 \dfrac{(x - a)^2}{2h_1} + f[x_0, x_1] - \dfrac{M_1 - M_0}{6}h_1\)</span></p>
</li>
<li>在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\([x_{n-1}, b]\)</span><span class="heti-spacing"> </span></span>上<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(S_n'\)</span><span class="heti-spacing"> </span></span>也是类似的：<span class="arithmatex">\(\begin{cases}2M_0 + M_1 = \dfrac{6}{h_1} (f[x_0, x_1] - y_0') = g_0 \\ M_{n-1} + 2M_n = \dfrac{6}{h_n} (y_n' - f[x_{n-1}, x_n]) = g_n\end{cases}\)</span></li>
</ul>
<p><strong>算法：固定三次样条</strong></p>
<div style="text-align: center">
<img src="images/C3/11.png" width="80%/"/>
</div>
<div style="text-align: center">
<img src="images/C3/12.png" width="80%/"/>
</div>
<ul>
<li>
<p><strong>自由边界</strong>(free boundary)：<span class="arithmatex">\(S''(a) = y_0'' = M_0, S''(b) = y_n'' = M_n\)</span>，且<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(M_0 = M_n = 0\)</span><span class="heti-spacing"> </span></span>时</p>
</li>
<li>
<p>那么<span><span class="heti-spacing"> </span><span class="arithmatex">\(\lambda_0 = 0, g_0 = 2y_0'';\ \mu_n = 0, g_n = 2y_n''\)</span></span></p>
</li>
<li>此时的样条称为<strong>自然样条</strong>(natural spline)</li>
</ul>
<p><strong>算法：自然三次样条</strong></p>
<div style="text-align: center">
<img src="images/C3/9.png" width="80%/"/>
</div>
<div style="text-align: center">
<img src="images/C3/10.png" width="80%/"/>
</div>
<ul>
<li><strong>周期边界</strong>(periodic boundary)：如果<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f\)</span><span class="heti-spacing"> </span></span>是周期函数，即<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(y_n = y_0\)</span><span class="heti-spacing"> </span></span>且<span><span class="heti-spacing"> </span><span class="arithmatex">\(S'(a^+) = S'(b^-) \Rightarrow M_0 = M_n\)</span></span></li>
</ul>
<div style="text-align: center">
<img src="images/C3/3.png" width="50%/"/>
</div>
<p><strong>注</strong></p>
<ul>
<li>只要系数矩阵是严格对角占优的，那么三次样条能通过边界被<strong>唯一</strong>确定</li>
<li>如果<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f \in C[a, b]\)</span><span class="heti-spacing"> </span></span>且<span><span class="heti-spacing"> </span><span class="arithmatex">\(\dfrac{\max h_i}{\min h_i} \le C &lt; \infty\)</span></span>，那么当<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(h_i \rightarrow 0\)</span><span class="heti-spacing"> </span></span>时，<span class="arithmatex">\(S(x) \xrightarrow{\text{uniform}} f(x)\)</span>。也就是说，在保证不增加样条阶数的情况下，可通过增加节点个数来提升近似精度</li>
</ul>
<p><strong>算法概述：三次样条插值法</strong></p>
<ol>
<li>计算<span><span class="heti-spacing"> </span><span class="arithmatex">\(\mu_j, \lambda_j, g_j\)</span></span></li>
<li>求解<span><span class="heti-spacing"> </span><span class="arithmatex">\(M_j\)</span></span></li>
<li>找到包含<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(x\)</span><span class="heti-spacing"> </span></span>的子区间，即找到相应的<span><span class="heti-spacing"> </span><span class="arithmatex">\(j\)</span></span></li>
<li>通过<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(S_j(x)\)</span><span class="heti-spacing"> </span></span>得到<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f(x)\)</span><span class="heti-spacing"> </span></span>的近似值</li>
</ol>
<h1 id="chap-8-approximation-theory">Chap 8: Approximation Theory<a class="headerlink" href="#chap-8-approximation-theory" title="Permanent link">⚓︎</a></h1>
<p>近似理论的目标是：给定<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(x_1, \dots, x_m\)</span><span class="heti-spacing"> </span></span>和<span><span class="heti-spacing"> </span><span class="arithmatex">\(y_1, \dots y_m\)</span></span>，寻找更简单的函数<span><span class="heti-spacing"> </span><span class="arithmatex">\(P(x) \approx f(x)\)</span></span>（近似表示<span><span class="heti-spacing"> </span><span class="arithmatex">\(f(x)\)</span></span><heti-adjacent class="heti-adjacent-half">）</heti-adjacent>。</p>
<p>然而，因为有时<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(m\)</span><span class="heti-spacing"> </span></span>可能会特别大，并且<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(y_i\)</span><span class="heti-spacing"> </span></span>是不准确的实验数据（即<span><span class="heti-spacing"> </span><span class="arithmatex">\(y_i \ne f(x_i)\)</span></span><heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，所以此时更合理的做法是去寻找最佳拟合的<span><span class="heti-spacing"> </span><span class="arithmatex">\(P(x)\)</span></span>，使得对于所有点而言，<span><span class="arithmatex">\(P(x_i) - y_i\)</span><span class="heti-spacing"> </span></span>尽可能小。下面我们就来介绍这些数学方法。</p>
<h2 id="discrete-least-square-approximation">Discrete Least Square Approximation<a class="headerlink" href="#discrete-least-square-approximation" title="Permanent link">⚓︎</a></h2>
<p>目标：确定一个多项式<span><span class="heti-spacing"> </span><span class="arithmatex">\(P_n(x) = a_0 + a_1 x + \dots a_n x^n\)</span></span>，用于近似表示一组数据<span><span class="heti-spacing"> </span><span class="arithmatex">\(\{(x_i, y_i)\ |\ i = 1, 2, \dots, m\}\)</span></span>，使得最小二乘误差<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(E_2 = \sum\limits_{i=1}^m [P_N(x_i) - y_i]^2\)</span><span class="heti-spacing"> </span></span>最小化，其中<span><span class="heti-spacing"> </span><span class="arithmatex">\(n \ll m\)</span></span></p>
<p>关键：<span><span class="arithmatex">\(E_2\)</span><span class="heti-spacing"> </span></span>实际上是一个关于<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(a_0, a_1, \dots, a_n\)</span><span class="heti-spacing"> </span></span>的函数，也就是说<span><span class="heti-spacing"> </span><span class="arithmatex">\(E_2(a_0, a_1, \dots, a_n) = \sum\limits_{i=1}^m [a_0 + a_1 x_i + \dots + a_n x_i^n - y_i]^2\)</span></span>。要想让<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(E_2\)</span><span class="heti-spacing"> </span></span>最小化，必要条件是<span><span class="heti-spacing"> </span><span class="arithmatex">\(\dfrac{\partial E_2}{\partial a_k} = 0, k = 0, \dots, n\)</span></span></p>
<div class="arithmatex">\[
\begin{align}
0 &amp; = \dfrac{\partial E_2}{\partial a_k} = 2\sum\limits_{i=1}^m [P_N(x_i) - y_i]^2 \dfrac{\partial P_n(x_i)}{\partial a_k} = 2 \sum\limits_{i=1}^m \Big[\sum\limits_{j=0}^n a_j x_i^j - y_i \Big]x_i^k \notag \\
&amp; = 2\Big\{\sum\limits_{j=0}^n a_j \Big(\sum\limits_{i=1}^m x_i^{j+k}\Big) - \sum\limits_{j=1}^m y_i x_i^k\Big\} \notag
\end{align}
\]</div>
<p>令<span><span class="heti-spacing"> </span><span class="arithmatex">\(b_k = \sum\limits_{i=1}^m x_i^k, c_k = \sum\limits_{i=1}^m y_i x_i^k\)</span></span>，那么：</p>
<div class="arithmatex">\[
\begin{bmatrix}b_{0+0} &amp; \dots &amp; b_{0+n} \\ \vdots &amp; \vdots &amp; \vdots \\ b_{n+0} &amp; \dots &amp; b_{n+n}\end{bmatrix} \begin{bmatrix}a_0 \\ \vdots \\ a_n\end{bmatrix} = \begin{bmatrix}c_0 \\ \vdots \\ c_n\end{bmatrix}
\]</div>
<p><strong>注</strong></p>
<ul>
<li><span><span class="arithmatex">\(P_n(x)\)</span><span class="heti-spacing"> </span></span>的顺序由用户给出，且必须不得超过<span><span class="heti-spacing"> </span><span class="arithmatex">\(m-1\)</span></span>。若<span><span class="heti-spacing"> </span><span class="arithmatex">\(n=m-1\)</span></span>，那么<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(P_n(x)\)</span><span class="heti-spacing"> </span></span>就是<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(E_2 = 0\)</span><span class="heti-spacing"> </span></span>的拉格朗日插值多项式</li>
<li>不强制要求<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(P_n(x)\)</span><span class="heti-spacing"> </span></span>是一个多项式</li>
<li>如果要考虑权重<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(w_i\)</span><span class="heti-spacing"> </span></span>的话，<span>LSA<span class="heti-spacing"> </span></span>的公式就变成：<span class="arithmatex">\(E_2 = \sum\limits_{i=1}^m w_i [P_N(x_i) - y_i]^2\)</span></li>
</ul>
<p><strong>例子</strong></p>
<p>例<span><span class="heti-spacing"> </span>1</span></p>
<p>题目：</p>
<div style="text-align: center">
<img src="images/C8/1.png" width="80%/"/>
</div>
<p>解答：</p>
<p>法<span><span class="heti-spacing"> </span>1</span></p>
<p>令<span><span class="heti-spacing"> </span><span class="arithmatex">\(y \approx P(x) = \dfrac{x}{ax + b}\)</span></span>，寻找<span><span class="heti-spacing"> </span><span class="arithmatex">\(a, b\)</span></span>，使得<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(E_2(a, b) = \sum\limits_{i=1}^m \Big(\dfrac{x_i}{ax_i + b} - y_i\Big)^2\)</span><span class="heti-spacing"> </span></span>最小化。</p>
<p><strong>线性化</strong>(linearization)：令<span><span class="heti-spacing"> </span><span class="arithmatex">\(Y = \dfrac{1}{y}, X = \dfrac{1}{x}\)</span></span>，那么<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(Y \approx a + b X\)</span><span class="heti-spacing"> </span></span>就是一个线性问题了。</p>
<p>将<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\((x_i, y_i)\)</span><span class="heti-spacing"> </span></span>转换为<span><span class="heti-spacing"> </span><span class="arithmatex">\((X_i, Y_i)\)</span></span>，<span><span class="arithmatex">\(a, b\)</span><span class="heti-spacing"> </span></span>就能被解出来了。</p>
<p>法<span><span class="heti-spacing"> </span>2</span></p>
<p>令<span><span class="heti-spacing"> </span><span class="arithmatex">\(y \approx P(x) = ae^{-\frac{b}{x}}\)</span></span>，不难发现<span><span class="heti-spacing"> </span><span class="arithmatex">\(\ln y \approx \ln a - \dfrac{b}{x}\)</span></span></p>
<p><strong>线性化</strong>：令<span><span class="heti-spacing"> </span><span class="arithmatex">\(Y = \ln y, X = \dfrac{1}{x}, A = \ln a, B = -b\)</span></span>，得到<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(Y \approx A + BX\)</span><span class="heti-spacing"> </span></span>这样一个线性问题。</p>
<p>将<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\((x_i, y_i)\)</span><span class="heti-spacing"> </span></span>转换为<span><span class="heti-spacing"> </span><span class="arithmatex">\((X_i, Y_i)\)</span></span>，<span><span class="arithmatex">\(a, b\)</span><span class="heti-spacing"> </span></span>就能被解出来了（<span class="arithmatex">\(a = e^A, b = -B, P(x) = ae^{-\frac{b}{x}}\)</span>）</p>
<p>例<span><span class="heti-spacing"> </span>2</span></p>
<p>题目：</p>
<div style="text-align: center">
<img src="images/C8/8.png" width="80%/"/>
</div>
<p>解答：</p>
<ul>
<li>拿那个带权重的<span class="heti-skip"><span class="heti-spacing"> </span>LSA<span class="heti-spacing"> </span></span>公式计算，得到一个关于<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(a, b\)</span><span class="heti-spacing"> </span></span>的函数</li>
<li>当所有偏导数均为<span class="heti-skip"><span class="heti-spacing"> </span>0<span class="heti-spacing"> </span></span>时，函数值最小；所以在代入具体值前，建议先化简偏导数公式，以减小计算量</li>
<li>得到的偏导数为：<span class="arithmatex">\(\begin{cases}\dfrac{\partial S}{\partial a} = 0 \Rightarrow \sum w_i x_i y_i = 0 \\ \dfrac{\partial S}{\partial b} = 0 \Rightarrow \sum w_i x_i^3 y_i = 0\end{cases}\)</span></li>
<li>再代入具体值，就可以得到关于<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(a, b\)</span><span class="heti-spacing"> </span></span>的二元一次方程</li>
<li>解得<span><span class="heti-spacing"> </span><span class="arithmatex">\(a = \dfrac{8}{7}, b = \dfrac{23}{49}\)</span></span></li>
</ul>
<h2 id="orthorgonal-polynomials-and-least-squares-approximation">Orthorgonal Polynomials and Least Squares Approximation<a class="headerlink" href="#orthorgonal-polynomials-and-least-squares-approximation" title="Permanent link">⚓︎</a></h2>
<p>目标：</p>
<ul>
<li>离散版本：给定<span><span class="heti-spacing"> </span><span class="arithmatex">\(x_1, \dots, x_m;\ y_1, \dots, y_m\)</span></span>，找到更简单的函数<span><span class="heti-spacing"> </span><span class="arithmatex">\(P(x) \approx f(x)\)</span></span>，使得<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(E = \sum\limits_{i=1}^m |P(x_i) - y_i|^2\)</span><span class="heti-spacing"> </span></span>最小化。</li>
<li>连续版本：给定在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\([a, b]\)</span><span class="heti-spacing"> </span></span>上的函数<span><span class="heti-spacing"> </span><span class="arithmatex">\(f(x)\)</span></span>，找到更简单的函数<span><span class="heti-spacing"> </span><span class="arithmatex">\(P(x) \approx f(x)\)</span></span>，使得<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(E = \int_a^b [P(x) - f(x)]^2 dx\)</span><span class="heti-spacing"> </span></span>最小化。</li>
</ul>
<p><strong>定义</strong> ：对于一组在区间<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\([a, b]\)</span><span class="heti-spacing"> </span></span>上的函数<span><span class="heti-spacing"> </span><span class="arithmatex">\(\{\varphi_0(x), \varphi_1(x), \dots, \varphi_n(x)\}\)</span></span>，当<span><span class="heti-spacing"> </span><span class="arithmatex">\(\forall x \in [a, b]\)</span></span>，<span><span class="arithmatex">\(a_0 \varphi_0(x) + a_1 \varphi_1(x) + \dots + a_n \varphi_n(x) = 0\)</span><span class="heti-spacing"> </span></span>时，有<span><span class="heti-spacing"> </span><span class="arithmatex">\(a_0 = a_1 \dots = a_n = 0\)</span></span>，那么称这组函数是<strong>线性独立</strong><span>(linearly independent)<span class="heti-spacing"> </span></span>的，否则称它们是<strong>线性相关</strong><span>(linearly dependent)<span class="heti-spacing"> </span></span>的。</p>
<p><strong>定理</strong> ：如果<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\varphi_j(x)\)</span><span class="heti-spacing"> </span></span>是一个<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(j\)</span><span class="heti-spacing"> </span></span>次多项式（<span class="arithmatex">\(j = 0, \dots, n\)</span><heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，那么<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\{\varphi_0(x), \varphi_1(x), \dots, \varphi_n(x)\}\)</span><span class="heti-spacing"> </span></span>在任意区间<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\([a, b]\)</span><span class="heti-spacing"> </span></span>上都是<strong>线性独立的</strong>(linear independent)。</p>
<p><strong>定理</strong> ：令<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\Pi_n\)</span><span class="heti-spacing"> </span></span>为一组次数至多为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n\)</span><span class="heti-spacing"> </span></span>的多项式，如果<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\{\varphi_0(x), \varphi_1(x), \dots, \varphi_n(x)\}\)</span><span class="heti-spacing"> </span></span>是<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\Pi_n\)</span><span class="heti-spacing"> </span></span>内一组线性独立的多项式，那么<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\Pi_n\)</span><span class="heti-spacing"> </span></span>内的任意多项式均可被唯一写做<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\varphi_0(x), \varphi_1(x), \dots, \varphi_n(x)\)</span><span class="heti-spacing"> </span></span>的一个线性组合。</p>
<p><strong>定义</strong> ：对于一般的一组线性独立的函数<span><span class="heti-spacing"> </span><span class="arithmatex">\(\{\varphi_0(x), \varphi_1(x), \dots, \varphi_n(x)\}\)</span></span>，关于它们的<strong>线性组合</strong> <span><span class="arithmatex">\(P(x) = \sum\limits_{j=0}^n a_j \varphi_j(x)\)</span><span class="heti-spacing"> </span></span>被称为<strong>广义多项式</strong>(generalized polynomial)。</p>
<p>一些特殊的多项式：</p>
<ul>
<li><span><span class="arithmatex">\(\{\varphi_j(x) = \cos jx\}, \{\psi_j(x) = \sin jx\} \Rightarrow \{\varphi_j(x), \psi_j(x)\}\)</span><span class="heti-spacing"> </span></span>得到的是<strong>三角多项式</strong>(trigonometric polynomial)</li>
<li><span><span class="arithmatex">\(\{\varphi_j(x) = e^{kjx}, k_i \ne k_j\}\)</span><span class="heti-spacing"> </span></span>得到的是<strong>指数多项式</strong>(exponential polynomial)</li>
</ul>
<p><strong>定义：权重函数<span><span class="heti-spacing"> </span>(weight function)</span></strong></p>
<ul>
<li><strong>离散</strong>版本：当对一组离散点<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\((x_i, y_i) (i = 1, \dots, n)\)</span><span class="heti-spacing"> </span></span>进行近似时，我们为每个点赋予一个误差项<span><span class="heti-spacing"> </span><span class="arithmatex">\(w_i\)</span></span>，它是一个正实数。此时我们要考虑让<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(E = \sum w_i [P(x_i) - y_i]^2\)</span><span class="heti-spacing"> </span></span>最小化。集合<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\{w_i\}\)</span><span class="heti-spacing"> </span></span>被称为<strong>权重</strong>(weight)。设置权重的目标是为这些点赋予不同的“重要程度”，以便实现更好的近似。</li>
<li><strong>连续</strong>版本：一个在区间<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(I\)</span><span class="heti-spacing"> </span></span>上的可积分的函数<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(w\)</span><span class="heti-spacing"> </span></span>被称为权重函数，它满足<span><span class="heti-spacing"> </span><span class="arithmatex">\(\forall x \in I, w(x) \ge 0\)</span></span>，但<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(w(x)\)</span><span class="heti-spacing"> </span></span>不会在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(I\)</span><span class="heti-spacing"> </span></span>的任意子区间上消失。此时我们要考虑让<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(E = \int_a^b w(x) [P(x) - f(x)]^2 dx\)</span><span class="heti-spacing"> </span></span>最小化。</li>
</ul>
<p><strong>定义：广义的最小二乘近似<span class="heti-skip"><span class="heti-spacing"> </span>(general least square approximation)<span class="heti-spacing"> </span></span>问题</strong></p>
<ul>
<li><strong>离散</strong>版本：给定一组离散点<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\((x_i, y_i)\)</span><span class="heti-spacing"> </span></span>和一组对应的权重<span><span class="heti-spacing"> </span><span class="arithmatex">\(\{w_i\}\)</span></span>（<span class="arithmatex">\(i = 1, \dots, m\)</span><heti-adjacent class="heti-adjacent-half">）</heti-adjacent>。我们要找到一个广义多项式<span><span class="heti-spacing"> </span><span class="arithmatex">\(P(x)\)</span></span>，使得误差<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(E = \sum w_i [P(x_i) - y_i]^2\)</span><span class="heti-spacing"> </span></span>最小化。</li>
<li><strong>连续</strong>版本：给定定义在区间<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\([a, b]\)</span><span class="heti-spacing"> </span></span>上的一个函数<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f(x)\)</span><span class="heti-spacing"> </span></span>和一个权重函数<span><span class="heti-spacing"> </span><span class="arithmatex">\(w(x)\)</span></span>。我们要找到一个广义多项式<span><span class="heti-spacing"> </span><span class="arithmatex">\(P(x)\)</span></span>，使得误差<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(E = \int_a^b w(x) [P(x) - f(x)]^2 dx\)</span><span class="heti-spacing"> </span></span>最小化。</li>
</ul>
<hr/>
<p><strong>内积</strong></p>
<p>映射<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(V \times V \rightarrow F\)</span><span class="heti-spacing"> </span></span>满足以下三个公理：</p>
<ul>
<li>共轭对称性：<span class="arithmatex">\((x, y) = \overline{(y, x)}\)</span></li>
<li>线性：<span class="arithmatex">\((ax, y) = a(x, y), (x + y, z) = (x, z) + (y, z)\)</span></li>
<li>正定性：<span class="arithmatex">\((x, x) \ge 0;\ (x, x) = 0 \Rightarrow x = 0\)</span></li>
</ul>
<p>内积就是<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(x\)</span><span class="heti-spacing"> </span></span>的范数<span><span class="heti-spacing"> </span><span class="arithmatex">\(\|x\| = \sqrt{(x, x)}\)</span></span></p>
<p>对于一般函数<span><span class="heti-spacing"> </span><span class="arithmatex">\((f, g)\)</span></span>：</p>
<ul>
<li>离散版本：<span class="arithmatex">\(\sum\limits_i f_i g_i = (f_1\ f_2\ \dots\ f_n) \begin{pmatrix}g_1 \\ g_2 \\ \vdots \\ g_n\end{pmatrix} = (f)^T(g)\)</span></li>
<li>连续版本：<span class="arithmatex">\(\int_a^b f(x)g(x) dx\)</span></li>
</ul>
<p>若带有权重函数，即<span><span class="heti-spacing"> </span><span class="arithmatex">\((f, g)_w\)</span></span>：</p>
<ul>
<li>
<p>离散版本：</p>
<div class="arithmatex">\[
\begin{align}
\sum\limits_i f_i g_i &amp; = (f_1\ f_2\ \dots\ f_n) \begin{pmatrix}w_1 &amp; 0 &amp; \dots &amp; 0 \\ 0 &amp; w_2 &amp; \dots &amp; 0 \\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ 0 &amp; 0 &amp; \dots &amp; w_n\end{pmatrix} \begin{pmatrix}g_1 \\ g_2 \\ \vdots \\ g_n\end{pmatrix} \notag \\
&amp; = (f)^T[w](g) \notag
\end{align}
\]</div>
</li>
<li>
<p>连续版本：<span class="arithmatex">\(\int_a^b w(x)f(x)g(x) dx\)</span></p>
</li>
</ul>
<hr/>
<p>对于<span><span class="heti-spacing"> </span><span class="arithmatex">\((f, g) = \begin{cases}\sum\limits_{i=1}^m w_i f(x_i) g(x_i) &amp; \text{discrete version} \\ \int_a^b w(x) f(x) g(x) dx &amp; \text{continuous version} \end{cases}\)</span></span>，可以证明它表示的是一个<strong>内积</strong>(inner product)，且<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\|f\| = \sqrt{(f, f)}\)</span><span class="heti-spacing"> </span></span>是一个<strong>范数</strong>。并且当<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\((f, g) = 0\)</span><span class="heti-spacing"> </span></span>时，我们称<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f, g\)</span><span class="heti-spacing"> </span></span>是<strong>正交的</strong>(orthogonal)。</p>
<p>因此一般的最小二乘近似问题可以被转换为：</p>
<div style="text-align: center">
<p>寻找一个广义多项式<span><span class="heti-spacing"> </span><span class="arithmatex">\(P(x)\)</span></span>，使得<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(E = (P - y, P - y) = \| P - y \|^2\)</span><span class="heti-spacing"> </span></span>最小化。</p>
</div>
<p>令<span><span class="heti-spacing"> </span><span class="arithmatex">\(P(x) = a_0 \varphi_0(x) + a_1 \varphi_1(x) + \dots + a_n \varphi_n(x)\)</span></span>，然后与求解离散问题类似：<span class="arithmatex">\(\dfrac{\partial E}{\partial a_k} = 0\)</span>，即对于所有<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(a_k\)</span><span class="heti-spacing"> </span></span>偏导数为<span class="heti-skip"><span class="heti-spacing"> </span>0<span class="heti-spacing"> </span></span>时误差取最小值。将等号左侧公式化简，可以得到：<span class="arithmatex">\(\sum\limits_{j=0}^n (\varphi_k, \varphi_j) a_j = (\varphi_k, f), k = 0, \dots, n\)</span>，也就是说：</p>
<div class="arithmatex">\[
\begin{bmatrix}b_{ij} = (\varphi_i, \varphi_j)\end{bmatrix} \begin{bmatrix}a_0 \\ \vdots \\ a_n\end{bmatrix} = \begin{bmatrix}(\varphi_0, f) \\  \vdots \\ (\varphi_n, f)\end{bmatrix} = \varepsilon
\]</div>
<p><strong>例子</strong></p>
<p>题目：使用<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(y = a_0 + a_1 x + a_2 x^2\ (w \equiv 1)\)</span><span class="heti-spacing"> </span></span>近似点集<span><span class="heti-spacing"> </span><span class="arithmatex">\(\{(1, 4), (2, 10), (3, 18), (4, 26)\}\)</span></span></p>
<p>解答：</p>
<p><span class="arithmatex">\(\varphi_0(x) = 1, \varphi_1(x) = x, \varphi_2(x) = x^2\)</span>，可以计算出：</p>
<div style="text-align: center">
<img src="images/C8/2.png" width="70%/"/>
</div>
<div style="text-align: center">
<img src="images/C8/3.png" width="70%/"/>
</div>
<p><span class="arithmatex">\(\|B\|_{\infty} = 484, \|B^{-1}\|_{\infty} = \dfrac{63}{4} \Rightarrow K(B) = 7623\)</span></p>
<hr/>
<p><strong>例子</strong></p>
<p>当使用<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\varphi_j(x) = x^j\)</span><span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(w(x) \equiv 1\)</span><span class="heti-spacing"> </span></span>近似<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f(x) \in C[0, 1]\)</span><span class="heti-spacing"> </span></span>时，<span class="arithmatex">\((\varphi_i, \varphi_j) = \int_0^1 x^i x^j dx = \dfrac{1}{i + j +1}\)</span>（<a href="https://en.wikipedia.org/wiki/Hilbert_matrix"><strong>希尔伯特矩阵</strong></a>(Hilbert matrix)）</p>
<p>改进：如果我们能找到一组一般的线性独立的函数<span><span class="heti-spacing"> </span><span class="arithmatex">\(\{\varphi_0(x), \varphi_1(x), \dots, \varphi_n(x) \}\)</span></span>，使得任何函数对<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\varphi_i(x), \varphi_j(x)\)</span><span class="heti-spacing"> </span></span>是<strong>正交的</strong>(orthogonal)，那么范数矩阵将会是个<strong>对角矩阵</strong>。此时我们有<span><span class="heti-spacing"> </span><span class="arithmatex">\(a_k = \dfrac{(\varphi_k, f)}{(\varphi_k, \varphi_k)}\)</span></span></p>
<p>下面考虑构造<strong>正交多项式</strong>(orthogonal polynomials)。</p>
<p><strong>定理</strong></p>
<p>对于一组在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\([a, b]\)</span><span class="heti-spacing"> </span></span>的多项式函数<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\{\varphi_0(x), \varphi_1(x), \dots, \varphi_n(x)\}\)</span><span class="heti-spacing"> </span></span>以及一个权重函数<span><span class="heti-spacing"> </span><span class="arithmatex">\(w\)</span></span>，当满足以下条件时，我们认为这些函数是正交的：</p>
<div class="arithmatex">\[
\varphi_0 (x) \equiv 1, \varphi_1(x) = x - B_1, \varphi_k(x) = (x - B_k)\varphi_{k-1}(x) - C_k \varphi_{k-2}(x)
\]</div>
<p>其中<span><span class="heti-spacing"> </span><span class="arithmatex">\(B_k = \dfrac{(x \varphi_{k-1}, \varphi_{k-1})}{(\varphi_{k-1}, \varphi_{k-1})}, C_k = \dfrac{(x \varphi_{k-1}, \varphi_{k-2})}{( \varphi_{k-2}, \varphi_{k-2})}\)</span></span></p>
<p><strong>注</strong></p>
<ul>
<li>这样构造出来的正交多项式都是<a href="https://en.wikipedia.org/wiki/Monic_polynomial"><strong>首一多项式</strong></a>(monic polynomial)（即最高次数项系数为<span class="heti-skip"><span class="heti-spacing"> </span>1<span class="heti-spacing"> </span></span>的多项式<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>。</li>
<li>该定理正是源自我们在线性代数中学过的<a href="https://en.wikipedia.org/wiki/Gram%E2%80%93Schmidt_process"><strong>格拉姆<span class="heti-skip"><span class="heti-spacing"> </span>-<span class="heti-spacing"> </span></span>施密特正交化</strong></a>(Gram-Schmidt process)。</li>
</ul>
<p><strong>例子</strong></p>
<p>例<span><span class="heti-spacing"> </span>1</span></p>
<p>题目<heti-adjacent class="heti-adjacent-half">：</heti-adjacent>（和之前基本一样的）使用<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(y = c_0 + c_1 x + c_2 x^2, w \equiv 1\)</span><span class="heti-spacing"> </span></span>近似点集<span><span class="heti-spacing"> </span><span class="arithmatex">\(\{(1, 4), (2, 10), (3, 18), (4, 26)\}\)</span></span></p>
<p>解答：</p>
<p>首先构造正交多项式<span><span class="heti-spacing"> </span><span class="arithmatex">\(\varphi_0(x), \varphi_1(x), \varphi_2(x)\)</span></span>，令<span><span class="heti-spacing"> </span><span class="arithmatex">\(y = a_0 \varphi_0(x) + a_1 \varphi_1(x) + a_2 \varphi_2(x)\)</span></span>（<span class="arithmatex">\(a_k = \dfrac{(\varphi_k, y)}{(\varphi_k, \varphi_k)}\)</span><heti-adjacent class="heti-adjacent-half">）</heti-adjacent>。接下来就计算出这些值：</p>
<div style="text-align: center">
<img src="images/C8/4.png" width="80%/"/>
</div>
<p>最终解得<span><span class="heti-spacing"> </span><span class="arithmatex">\(y = \dfrac{1}{2}x^2 + \dfrac{49}{10}x - \dfrac{3}{2}\)</span></span></p>
<p>例<span><span class="heti-spacing"> </span>2</span></p>
<p>题目：</p>
<div style="text-align: center">
<img src="images/C8/7.png" width="80%/"/>
</div>
<p>解答：</p>
<p>知道内积的求解公式和上述正交多项式的构造后，这题其实挺容易的。所以就直接给出答案了：</p>
<ul>
<li><span class="arithmatex">\(\varphi_0(x) = 1\)</span></li>
<li><span class="arithmatex">\(\varphi_1(x) = x - 2\)</span></li>
<li><span class="arithmatex">\(\varphi_2(x) = x^2 - 4x + \dfrac{8}{3}\)</span></li>
</ul>
<p><strong>算法：正交多项式近似</strong></p>
<p>用一个有被容忍值约束的误差的多项式，近似一个给定的函数。</p>
<ul>
<li>输入：数据个数<span><span class="heti-spacing"> </span><span class="arithmatex">\(m\)</span></span>；<span class="arithmatex">\(x[m];\ y[m]\)</span>；权重<span><span class="heti-spacing"> </span><span class="arithmatex">\(w[m]\)</span></span>；容忍值<span><span class="heti-spacing"> </span><span class="arithmatex">\(TOL\)</span></span>；多项式最大阶数<span><span class="heti-spacing"> </span><span class="arithmatex">\(Max_n\)</span></span></li>
<li>输出：近似多项式的系数</li>
</ul>
<div class="language-c highlight"><pre><span></span><code><span id="__span-19-1"><a href="#__codelineno-19-1" id="__codelineno-19-1" name="__codelineno-19-1"></a><span class="n">Step</span><span class="w"> </span><span class="mi">1</span><span class="w">  </span><span class="n">Set</span><span class="w"> </span><span class="n">phi_0</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="err">≡</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span>
</span><span id="__span-19-2"><a href="#__codelineno-19-2" id="__codelineno-19-2" name="__codelineno-19-2"></a><span class="w">            </span><span class="n">a_0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iprod</span><span class="p">(</span><span class="n">phi_0</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">iprod</span><span class="p">(</span><span class="n">phi_0</span><span class="p">,</span><span class="w"> </span><span class="n">phi_0</span><span class="p">);</span><span class="w"> </span>
</span><span id="__span-19-3"><a href="#__codelineno-19-3" id="__codelineno-19-3" name="__codelineno-19-3"></a><span class="w">            </span><span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a_0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">phi_0</span><span class="p">(</span><span class="n">x</span><span class="p">);</span><span class="w"> </span>
</span><span id="__span-19-4"><a href="#__codelineno-19-4" id="__codelineno-19-4" name="__codelineno-19-4"></a><span class="w">            </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iprod</span><span class="p">(</span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a_0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">iprod</span><span class="p">(</span><span class="n">phi_0</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">);</span>
</span><span id="__span-19-5"><a href="#__codelineno-19-5" id="__codelineno-19-5" name="__codelineno-19-5"></a><span class="n">Step</span><span class="w"> </span><span class="mi">2</span><span class="w">  </span><span class="n">Set</span><span class="w"> </span><span class="n">B_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iprod</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">phi_0</span><span class="p">,</span><span class="w"> </span><span class="n">phi_0</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">iprod</span><span class="p">(</span><span class="n">phi_0</span><span class="p">,</span><span class="w"> </span><span class="n">phi_0</span><span class="p">);</span><span class="w"> </span>
</span><span id="__span-19-6"><a href="#__codelineno-19-6" id="__codelineno-19-6" name="__codelineno-19-6"></a><span class="w">            </span><span class="n">phi_1</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">B_1</span><span class="p">;</span>
</span><span id="__span-19-7"><a href="#__codelineno-19-7" id="__codelineno-19-7" name="__codelineno-19-7"></a><span class="w">            </span><span class="n">a_1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iprod</span><span class="p">(</span><span class="n">phi_1</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">iprod</span><span class="p">(</span><span class="n">phi_1</span><span class="p">,</span><span class="w"> </span><span class="n">phi_1</span><span class="p">);</span><span class="w"> </span>
</span><span id="__span-19-8"><a href="#__codelineno-19-8" id="__codelineno-19-8" name="__codelineno-19-8"></a><span class="w">            </span><span class="n">P</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">a_1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">phi_1</span><span class="p">(</span><span class="n">x</span><span class="p">);</span><span class="w"> </span>
</span><span id="__span-19-9"><a href="#__codelineno-19-9" id="__codelineno-19-9" name="__codelineno-19-9"></a><span class="w">            </span><span class="n">err</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">a_1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">iprod</span><span class="p">(</span><span class="n">phi_1</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">);</span>
</span><span id="__span-19-10"><a href="#__codelineno-19-10" id="__codelineno-19-10" name="__codelineno-19-10"></a><span class="n">Step</span><span class="w"> </span><span class="mi">3</span><span class="w">  </span><span class="n">Set</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
</span><span id="__span-19-11"><a href="#__codelineno-19-11" id="__codelineno-19-11" name="__codelineno-19-11"></a><span class="n">Step</span><span class="w"> </span><span class="mi">4</span><span class="w">  </span><span class="k">while</span><span class="w"> </span><span class="p">((</span><span class="n">k</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">Max_n</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="o">|</span><span class="n">err</span><span class="o">|</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">TOL</span><span class="p">))</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="n">steps</span><span class="w"> </span><span class="mi">5-7</span><span class="o">:</span>
</span><span id="__span-19-12"><a href="#__codelineno-19-12" id="__codelineno-19-12" name="__codelineno-19-12"></a><span class="w">    </span><span class="n">Step</span><span class="w"> </span><span class="mi">5</span><span class="w">  </span><span class="n">k</span><span class="o">++</span><span class="p">;</span>
</span><span id="__span-19-13"><a href="#__codelineno-19-13" id="__codelineno-19-13" name="__codelineno-19-13"></a><span class="w">    </span><span class="n">Step</span><span class="w"> </span><span class="mi">6</span><span class="w">  </span><span class="n">B_k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iprod</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">phi_1</span><span class="p">,</span><span class="w"> </span><span class="n">phi_1</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">iprod</span><span class="p">(</span><span class="n">phi_1</span><span class="p">,</span><span class="w"> </span><span class="n">phi_1</span><span class="p">);</span><span class="w"> </span>
</span><span id="__span-19-14"><a href="#__codelineno-19-14" id="__codelineno-19-14" name="__codelineno-19-14"></a><span class="w">            </span><span class="n">C_k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iprod</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">phi_1</span><span class="p">,</span><span class="w"> </span><span class="n">phi_0</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">iprod</span><span class="p">(</span><span class="n">phi_0</span><span class="p">,</span><span class="w"> </span><span class="n">phi_0</span><span class="p">);</span>
</span><span id="__span-19-15"><a href="#__codelineno-19-15" id="__codelineno-19-15" name="__codelineno-19-15"></a><span class="w">            </span><span class="n">phi_2</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">B_k</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">phi_1</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">C_k</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">phi_0</span><span class="p">(</span><span class="n">x</span><span class="p">);</span><span class="w"> </span>
</span><span id="__span-19-16"><a href="#__codelineno-19-16" id="__codelineno-19-16" name="__codelineno-19-16"></a><span class="w">            </span><span class="n">a_k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">iprod</span><span class="p">(</span><span class="n">phi_2</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">iprod</span><span class="p">(</span><span class="n">phi_2</span><span class="p">,</span><span class="w"> </span><span class="n">phi_2</span><span class="p">);</span>
</span><span id="__span-19-17"><a href="#__codelineno-19-17" id="__codelineno-19-17" name="__codelineno-19-17"></a><span class="w">    </span><span class="n">Step</span><span class="w"> </span><span class="mi">7</span><span class="w">  </span><span class="n">Set</span><span class="w"> </span><span class="n">phi_0</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">phi_1</span><span class="p">(</span><span class="n">x</span><span class="p">);</span><span class="w"> </span><span class="n">phi_1</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">phi_2</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
</span><span id="__span-19-18"><a href="#__codelineno-19-18" id="__codelineno-19-18" name="__codelineno-19-18"></a><span class="n">Step</span><span class="w"> </span><span class="mi">8</span><span class="w">  </span><span class="n">Output</span><span class="p">();</span><span class="w"> </span><span class="n">STOP</span><span class="p">.</span>
</span></code></pre></div>
<p><strong>讨论</strong></p>
<p>问题：这里的 <code>err</code> 是否是最小二乘误差，为什么？</p>
<p>解答：</p>
<p>是的，并且 <code>err</code> 的推导公式如下：</p>
<div class="arithmatex">\[
\begin{align}
err &amp; = \| P - y \|^2 = (P - y, P - y) = (\sum\limits_{k=0}^n a_k \varphi_k - y, \sum\limits_{i=0}^n a_i \varphi_i - y) \notag \\
&amp; = \sum\limits_{k=0}^n a_k^2 (\varphi_k, \varphi_k) - 2 \sum\limits_{k=0}^n a_k (\varphi_k, y) + (y, y) = (y, y) - \sum\limits_{k=0}^n a_k (\varphi_k, y) \notag
\end{align}
\]</div>
<h2 id="chebyshev-polynomials-and-economization-of-power-series">Chebyshev Polynomials and Economization of Power Series<a class="headerlink" href="#chebyshev-polynomials-and-economization-of-power-series" title="Permanent link">⚓︎</a></h2>
<p>前面讲过，解决一般的最小二乘近似问题的目标是：</p>
<div style="text-align: center">
<p>寻找一个广义多项式<span><span class="heti-spacing"> </span><span class="arithmatex">\(P(x)\)</span></span>，使得<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(E = (P - y, P - y) = \| P - y \|^2\)</span><span class="heti-spacing"> </span></span>最小化。</p>
</div>
<p>再次明确：我们的目标是最小化<span><span class="heti-spacing"> </span><span class="arithmatex">\(\|P - y\|_{\infty}\)</span></span>——这是一个<strong>极小化极大问题</strong>(minimax problem)。</p>
<h3 id="targets">Targets<a class="headerlink" href="#targets" title="Permanent link">⚓︎</a></h3>
<p>目标<span><span class="heti-spacing"> </span>1.0</span>：找到<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n\)</span><span class="heti-spacing"> </span></span>阶多项式<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(P_n(x)\)</span><span class="heti-spacing"> </span></span>使得<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\|P_n - f\|_{\infty}\)</span><span class="heti-spacing"> </span></span>最小化。</p>
<p><strong>定义</strong> ：如果<span><span class="heti-spacing"> </span><span class="arithmatex">\(P(x_0) - f(x_0) = \pm \|P - f\|_{\infty}\)</span></span>，那么此时<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(x_0\)</span><span class="heti-spacing"> </span></span>被称为<span><span class="heti-spacing"> </span><span class="arithmatex">\((\pm)\)</span></span> <strong>偏差点</strong>(deviation point)（也就是正好在误差边界上的点<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>。</p>
<p>从任意地方构造出多项式并不容易，但我们能够检验多项式的一些特征：</p>
<ul>
<li>
<p>如果<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f \in C[a, b]\)</span><span class="heti-spacing"> </span></span>且<span><span class="heti-spacing"> </span><span class="arithmatex">\(f\)</span></span> <strong>不是</strong>一个<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n\)</span><span class="heti-spacing"> </span></span>阶多项式，那么存在一个唯一的多项式<span><span class="heti-spacing"> </span><span class="arithmatex">\(P_n(x)\)</span></span>，使得<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\|P_n - f\|_{\infty}\)</span><span class="heti-spacing"> </span></span>最小化</p>
</li>
<li>
<p><span><span class="arithmatex">\(P_n(x)\)</span><span class="heti-spacing"> </span></span>存在，且必须同时有正负偏差点</p>
</li>
<li>
<p><strong>切比雪夫定理</strong>(Chebyshev Theorem)：<span><span class="arithmatex">\(P_n(x)\)</span><span class="heti-spacing"> </span></span>最小化<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\|P_n - f\|_{\infty}\ \Leftrightarrow P_n(x)\)</span><span class="heti-spacing"> </span></span>至少有<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n+2\)</span><span class="heti-spacing"> </span></span>个关于<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f\)</span><span class="heti-spacing"> </span></span>的正负偏差点。也就是说，存在一组点<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(a \le t_1 &lt; \dots &lt; t_{n+2} \le b\)</span><span class="heti-spacing"> </span></span>使得<span><span class="heti-spacing"> </span><span class="arithmatex">\(P_n(t_k) - f(t_k) = \pm(-1)^k \|P_n - f\|_{\infty}\)</span></span>。集合<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\{t_k\}\)</span><span class="heti-spacing"> </span></span>被称为<strong>切比雪夫交替序列</strong>(Chebyshev alternating sequence)。</p>
</li>
</ul>
<blockquote>
<p><span><span class="arithmatex">\(P_n(x) - f(x)\)</span><span class="heti-spacing"> </span></span>至少有<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n+1\)</span><span class="heti-spacing"> </span></span>个根。</p>
</blockquote>
<div style="text-align: center">
<img src="images/C8/5.png" width="60%/"/>
</div>
<hr/>
<p>目标<span><span class="heti-spacing"> </span>2.0</span>：确定插值点<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\{x_0, \dots, x_n\}\)</span><span class="heti-spacing"> </span></span>使得<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(P_n(x)\)</span><span class="heti-spacing"> </span></span>最小化余项<span><span class="heti-spacing"> </span><span class="arithmatex">\(|P_n(x) - f(x)| = |R_n(x)| = \Big|\dfrac{f^{(n+1)}(\xi)}{(n+1)!} \prod\limits_{i=0}^n (x - x_i)\Big|\)</span></span></p>
<p>目标<span><span class="heti-spacing"> </span>2.1</span>：找到<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\{x_1, \dots, x_n\}\)</span><span class="heti-spacing"> </span></span>使得<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\|w_n\|_{\infty}\)</span><span class="heti-spacing"> </span></span>在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\([-1, 1]\)</span><span class="heti-spacing"> </span></span>最小化，其中<span><span class="heti-spacing"> </span><span class="arithmatex">\(w_n(x) = \prod\limits_{i=1}^n (x - x_i)\)</span></span></p>
<hr/>
<p>注意到<span><span class="heti-spacing"> </span><span class="arithmatex">\(w_n(x) = x^n - P_{n-1}(x)\)</span></span>，问题就变成了：</p>
<p>目标<span><span class="heti-spacing"> </span>3.0</span>：找到多项式<span><span class="heti-spacing"> </span><span class="arithmatex">\(P_{n-1}(x)\)</span></span>，使得<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\|x^n - P_{n-1}(x)\|_{\infty}\)</span><span class="heti-spacing"> </span></span>在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\([-1, 1]\)</span><span class="heti-spacing"> </span></span>上最小。</p>
<p>根据切比雪夫定理，我们知道<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(P_{n-1}(x)\)</span><span class="heti-spacing"> </span></span>有<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n+1\)</span><span class="heti-spacing"> </span></span>个关于<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(x^n\)</span><span class="heti-spacing"> </span></span>的偏差点，也就是说<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(w_n(x)\)</span><span class="heti-spacing"> </span></span>在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n+1\)</span><span class="heti-spacing"> </span></span>个点上交替获得最大值和最小值。</p>
<h3 id="chebyshev-polynomials">Chebyshev Polynomials<a class="headerlink" href="#chebyshev-polynomials" title="Permanent link">⚓︎</a></h3>
<p>考虑<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\cos (n \theta)\)</span><span class="heti-spacing"> </span></span>在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\([0, \pi]\)</span><span class="heti-spacing"> </span></span>上的<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n+1\)</span><span class="heti-spacing"> </span></span>个极值。</p>
<p>令<span><span class="heti-spacing"> </span><span class="arithmatex">\(x = \cos (\theta)\)</span></span>，那么<span><span class="heti-spacing"> </span><span class="arithmatex">\(x \in [-1, 1]\)</span></span>。我们称<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_n(x) = \cos (n\theta) = \cos (n \cdot \text{arc} \cos x)\)</span><span class="heti-spacing"> </span></span>为<strong>切比雪夫多项式</strong>(Chebyshev polonomial)。</p>
<ul>
<li><span><span class="arithmatex">\(T_n(x)\)</span><span class="heti-spacing"> </span></span>假设在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(t_k = \cos \Big(\dfrac{k}{n} \pi\Big) (k = 0, 1, \dots, n)\)</span><span class="heti-spacing"> </span></span>上，在最大值<span class="heti-skip"><span class="heti-spacing"> </span>1<span class="heti-spacing"> </span></span>和最小值<span class="heti-skip"><span class="heti-spacing"> </span>-1<span class="heti-spacing"> </span></span>之间交替变换，也就是说<span><span class="heti-spacing"> </span><span class="arithmatex">\(T_n(t_k) = (-1)^k \|T_n(x)\|_{\infty}\)</span></span></li>
<li><span><span class="arithmatex">\(T_n(x)\)</span><span class="heti-spacing"> </span></span>有<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n\)</span><span class="heti-spacing"> </span></span>个根<span><span class="heti-spacing"> </span><span class="arithmatex">\(x_k = \cos \Big(\dfrac{2k - 1}{2n} \pi \Big)(k = 1, \dots, n)\)</span></span></li>
<li><span><span class="arithmatex">\(T_n(x)\)</span><span class="heti-spacing"> </span></span>有递推关系式：<span class="arithmatex">\(T_0(x) = 1, T_1(x) = x, T_{n+1}(x) = 2x T_n(x) - T_{n-1}(x)\)</span></li>
<li><span><span class="arithmatex">\(T_n(x)\)</span><span class="heti-spacing"> </span></span>是一个最高阶系数为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(2^{n-1}\)</span><span class="heti-spacing"> </span></span>的<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n\)</span><span class="heti-spacing"> </span></span>阶多项式</li>
<li><span><span class="arithmatex">\(\{T_0(x), T_1(x), \dots\}\)</span><span class="heti-spacing"> </span></span>在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\([-1, 1]\)</span><span class="heti-spacing"> </span></span>上关于权重函数<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(w(x) = \dfrac{1}{\sqrt{1 - x^2}}\)</span><span class="heti-spacing"> </span></span>上正交，也就是说<span><span class="heti-spacing"> </span><span class="arithmatex">\((T_n, T_m) = \int_{-1}^1 \dfrac{T_n(x) T_m(x)}{\sqrt{1-x^2}} dx = \begin{cases}0 &amp; n \ne m \\ \pi &amp; n = m = 0 \\ \dfrac{\pi}{2} &amp; n = m \ne 0\end{cases}\)</span></span></li>
</ul>
<p>回到之前提到的目标：</p>
<ul>
<li>目标<span><span class="heti-spacing"> </span>3.0</span>：找到多项式<span><span class="heti-spacing"> </span><span class="arithmatex">\(P_{n-1}(x)\)</span></span>，使得<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\|x^n - P_{n-1}(x)\|_{\infty}\)</span><span class="heti-spacing"> </span></span>在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\([-1, 1]\)</span><span class="heti-spacing"> </span></span>上最小。</li>
<li>此时<span><span class="heti-spacing"> </span><span class="arithmatex">\(w_n(x) = x^n - P_{n-1}(x) = \dfrac{T_n(x)}{2^{n-1}}\)</span></span></li>
<li>目标<span><span class="heti-spacing"> </span>2.1</span>：找到<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\{x_1, \dots, x_n\}\)</span><span class="heti-spacing"> </span></span>使得<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\|w_n\|_{\infty}\)</span><span class="heti-spacing"> </span></span>在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\([-1, 1]\)</span><span class="heti-spacing"> </span></span>最小化，其中<span><span class="heti-spacing"> </span><span class="arithmatex">\(w_n(x) = \prod\limits_{i=1}^n (x - x_i)\)</span></span></li>
<li>此时<span><span class="heti-spacing"> </span><span class="arithmatex">\(\min\limits_{w_n \in \widetilde{\Pi}_n} \|w_n\|_{\infty} = \Big\|\dfrac{1}{2^{n-1}} T_n(x)\Big\|_{\infty} = \dfrac{1}{2^{n-1}}\)</span></span>。其中：<span><span class="arithmatex">\(\widetilde{\Pi}_n\)</span><span class="heti-spacing"> </span></span>是<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n\)</span><span class="heti-spacing"> </span></span>阶的<strong>首一多项式</strong>，<span><span class="arithmatex">\(\{x_1, \dots, x_n\}\)</span><span class="heti-spacing"> </span></span>是<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_n(x)\)</span><span class="heti-spacing"> </span></span>的<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n\)</span><span class="heti-spacing"> </span></span>个根</li>
<li>目标<span><span class="heti-spacing"> </span>2.0</span>：确定插值点<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\{x_0, \dots, x_n\}\)</span><span class="heti-spacing"> </span></span>使得<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(P_n(x)\)</span><span class="heti-spacing"> </span></span>最小化余项<span><span class="heti-spacing"> </span><span class="arithmatex">\(|P_n(x) - f(x)| = |R_n(x)| = \Big|\dfrac{f^{(n+1)}(\xi)}{(n+1)!} \prod\limits_{i=0}^n (x - x_i)\Big|\)</span></span></li>
<li>取<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_{n+1}(x)\)</span><span class="heti-spacing"> </span></span>上的<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n+1\)</span><span class="heti-spacing"> </span></span>个根作为插值点<span><span class="heti-spacing"> </span><span class="arithmatex">\(\{x_0, \dots, x_n\}\)</span></span>，然后关于<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f(x)\)</span><span class="heti-spacing"> </span></span>的插值多项式<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(P_n(x)\)</span><span class="heti-spacing"> </span></span>假设绝对误差的最小上界为<span><span class="heti-spacing"> </span><span class="arithmatex">\(\dfrac{M}{2^n (n+1)!}\)</span></span></li>
</ul>
<p><strong>例子</strong></p>
<p>问题：找到在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\([0, 1]\)</span><span class="heti-spacing"> </span></span>上关于<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f(x) = e^x\)</span><span class="heti-spacing"> </span></span>的最佳近似多项式，使得绝对误差不超过<span><span class="heti-spacing"> </span><span class="arithmatex">\(0.5 \times 10^{-4}\)</span></span>。</p>
<p>解答：</p>
<ol>
<li>确定<span><span class="heti-spacing"> </span><span class="arithmatex">\(n\)</span></span>：<ul>
<li>改写变量<span><span class="heti-spacing"> </span><span class="arithmatex">\(x = \dfrac{a+b}{2} + \dfrac{b-a}{2} t = \dfrac{1}{2}(t+1)\)</span></span></li>
<li><span class="arithmatex">\(|R_n| \le \dfrac{e}{(n+1)!} \times \dfrac{1}{2^{2n+1}} &lt; \dfrac{1}{2} \times 10^{-4}\)</span>，解得<span><span class="heti-spacing"> </span><span class="arithmatex">\(n = 4\)</span></span></li>
</ul>
</li>
<li>找到<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_5(t)\)</span><span class="heti-spacing"> </span></span>的根：<span class="arithmatex">\(t_0 = \cos \dfrac{\pi}{10}, \cos \dfrac{3 \pi}{10}, \cos \dfrac{5 \pi}{10}, \cos \dfrac{7 \pi}{10}, \cos \dfrac{9 \pi}{10}\)</span></li>
<li>对变量做点改变：<ul>
<li><span class="arithmatex">\(x_0 = \dfrac{1}{2} \Big(\cos \dfrac{\pi}{10} + 1\Big) \approx 0.98\)</span></li>
<li><span class="arithmatex">\(x_1 = \dfrac{1}{2} \Big(\cos \dfrac{3 \pi}{10} + 1\Big) \approx 0.79\)</span></li>
<li><span class="arithmatex">\(x_2 = \dfrac{1}{2} \Big(\cos \dfrac{5 \pi}{10} + 1\Big) \approx 0.50\)</span></li>
<li><span class="arithmatex">\(x_3 = \dfrac{1}{2} \Big(\cos \dfrac{7 \pi}{10} + 1\Big) \approx 0.21\)</span></li>
<li><span class="arithmatex">\(x_4 = \dfrac{1}{2} \Big(\cos \dfrac{9 \pi}{10} + 1\Big) \approx 0.02\)</span></li>
</ul>
</li>
<li>用插值点<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(x_0, \dots, x_4\)</span><span class="heti-spacing"> </span></span>计算<span><span class="heti-spacing"> </span><span class="arithmatex">\(L_4(x)\)</span></span></li>
</ol>
<h3 id="economization-of-power-series">Economization of Power Series<a class="headerlink" href="#economization-of-power-series" title="Permanent link">⚓︎</a></h3>
<p>目标：给定<span><span class="heti-spacing"> </span><span class="arithmatex">\(P_n(x) \approx f(x)\)</span></span>，幂级数<strong>经济化</strong><span>(economization)<span class="heti-spacing"> </span></span>的目标是在确保精度损失最小的情况下，降低多项式的次数。</p>
<p>考虑一个任意的<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n\)</span><span class="heti-spacing"> </span></span>阶多项式<span><span class="heti-spacing"> </span><span class="arithmatex">\(P_n(x) = a_n x^n + a_{n-1} x^{n-1} + \dots + a_1 x + a_0\)</span></span>，对应的多项式<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(P_{n-1}(x)\)</span><span class="heti-spacing"> </span></span>通过移除<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n\)</span><span class="heti-spacing"> </span></span>阶多项式<span><span class="heti-spacing"> </span><span class="arithmatex">\(Q_n(x)\)</span></span>（<span><span class="arithmatex">\(x^n\)</span><span class="heti-spacing"> </span></span>项的系数为<span><span class="heti-spacing"> </span><span class="arithmatex">\(a_n\)</span></span>）得到。那么<span><span class="heti-spacing"> </span><span class="arithmatex">\(\max\limits_{[-1, 1]} |f(x) - P_{n-1}(x)| \le \max\limits_{[-1, 1]} |f(x) - P_n(x)| + \max\limits_{[-1, 1]} |Q_n(x)|\)</span></span>，而<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(Q_n(x)\)</span><span class="heti-spacing"> </span></span>能够反映精度的损失。</p>
<p>为了最小化精度损失，<span><span class="arithmatex">\(Q_n(x)\)</span><span class="heti-spacing"> </span></span>必须为<span><span class="heti-spacing"> </span><span class="arithmatex">\(a_n \times \dfrac{T_n(x)}{2^{n-1}}\)</span></span></p>
<p><strong>注</strong></p>
<ul>
<li>对于一般区间<span><span class="heti-spacing"> </span><span class="arithmatex">\([a, b]\)</span></span>，需要改变变量。也就是说，令<span><span class="heti-spacing"> </span><span class="arithmatex">\(x = [(b - a) t + (a + b)] / 2\)</span></span>，然后寻找对于<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f(t)\)</span><span class="heti-spacing"> </span></span>在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\([-1, 1]\)</span><span class="heti-spacing"> </span></span>上的（近似）多项式<span><span class="heti-spacing"> </span><span class="arithmatex">\(P_n(t)\)</span></span>，最终得到<span><span class="heti-spacing"> </span><span class="arithmatex">\(P_n(x)\)</span></span>。</li>
<li>另一种方法是用<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_0(x), \dots, T_k(x)\)</span><span class="heti-spacing"> </span></span>的线性组合来表示每一项<span><span class="heti-spacing"> </span><span class="arithmatex">\(x^k\)</span></span>。比如，<span class="arithmatex">\(x = T_1(x)\)</span>，且<span><span class="heti-spacing"> </span><span class="arithmatex">\(x^3 = [T_3(x) + 3T_1(x)] / 4\)</span></span>。然后只要从原始多项式中移除切比雪夫函数就行了。</li>
</ul>
<p><strong>例子</strong></p>
<p>题目：已知<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f(x) = e^x\)</span><span class="heti-spacing"> </span></span>在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\([-1, 1]\)</span><span class="heti-spacing"> </span></span>上的<span class="heti-skip"><span class="heti-spacing"> </span>4<span class="heti-spacing"> </span></span>阶泰勒多项式为<span><span class="heti-spacing"> </span><span class="arithmatex">\(P_4 = 1 + x + \dfrac{x^2}{2} + \dfrac{x^3}{6} + \dfrac{x^4}{24}\)</span></span>。它的截断误差的上界为<span><span class="heti-spacing"> </span><span class="arithmatex">\(|R_4(x)| \le \dfrac{e}{5!} |x^5| \approx 0.023\)</span></span>。请将这个近似多项式的次数降至<span><span class="heti-spacing"> </span>2</span>。</p>
<p>解答</p>
<div style="text-align: center">
<img src="images/C8/6.png" width="80%/"/>
</div>
<h1 id="chap-4-numerical-differentiation-and-integration">Chap 4: Numerical Differentiation and Integration<a class="headerlink" href="#chap-4-numerical-differentiation-and-integration" title="Permanent link">⚓︎</a></h1>
<h2 id="numerical-differentiation">Numerical Differentiation<a class="headerlink" href="#numerical-differentiation" title="Permanent link">⚓︎</a></h2>
<p>目标：对于给定的<span><span class="heti-spacing"> </span><span class="arithmatex">\(x_0\)</span></span>，近似计算<span><span class="heti-spacing"> </span><span class="arithmatex">\(f'(x_0)\)</span></span>（即<strong>数值微分</strong>(numerical differentiation)）</p>
<p>微分计算公式：<span class="arithmatex">\(f'(x_0) = \lim\limits_{h \rightarrow 0} \dfrac{f(x_0 + h) - f(x_0)}{h}\)</span></p>
<p><img align="right" alt="" src="images/C4/2.png" width="25%"/>
<img align="right" alt="" src="images/C4/1.png" width="25%"/></p>
<ul>
<li>前向：<span class="arithmatex">\(f'(x_0) \approx \dfrac{f(x_0 + h) - f(x_0)}{h}\)</span></li>
<li>后向：<span class="arithmatex">\(f'(x_0) \approx \dfrac{f(x_0) - f(x_0 - h)}{h}\)</span></li>
</ul>
<p>现在我们用<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f(x)\)</span><span class="heti-spacing"> </span></span>的带有插值点<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(x_0, x_0 + h\)</span><span class="heti-spacing"> </span></span>的拉格朗日多项式来近似表示<span><span class="heti-spacing"> </span><span class="arithmatex">\(f(x)\)</span></span>：</p>
<div class="arithmatex">\[
\begin{align}
f(x) &amp; = \dfrac{f(x_0)(x - x_0 - h)}{x_0 - x_0 - h} + \dfrac{f(x_0 + h)(x - x_0)}{x_0 + h - x_0} \notag \\
&amp; + \dfrac{(x - x_0)(x - x_0 - h)}{2} f''(\xi_x) \notag \\
f'(x) &amp; = \dfrac{f(x_0 + h) - f(x_0)}{h} + \dfrac{2(x - x_0) - h}{2} f''(\xi_x) \notag \\
&amp; + \dfrac{(x - x_0)(x - x_0 - h)}{2} \cdot \dfrac{d}{dx} [f''(\xi_x)] \notag
\end{align}
\]</div>
<p>因此<span><span class="heti-spacing"> </span><span class="arithmatex">\(f'(x_0) = \dfrac{f(x_0 + h) - f(x_0)}{h} - \dfrac{h}{2}f''(\xi)\)</span></span></p>
<hr/>
<p>接下来用插值点为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\{x_0, x_1, \dots, x_n\}\)</span><span class="heti-spacing"> </span></span>的拉格朗日多项式来近似表示<span><span class="heti-spacing"> </span><span class="arithmatex">\(f(x)\)</span></span></p>
<div class="arithmatex">\[
\begin{align}
f(x) &amp; = \sum\limits_{k=0}^n f(x_k) L_k(x) + \dfrac{(x - x_0) \dots (x - x_n)}{(n+1)!} f^{(n+1)}(\xi_x) \notag \\
f'(x_j) &amp; = \sum\limits_{k=0}^n f(x_k)L_k'(x_j) + \dfrac{f^{(n+1)}(\xi_j)}{(n+1)!} \prod\limits_{\substack{k = 0 \\ k \ne j}}^n (x_j - x_k) \notag
\end{align}
\]</div>
<p>上述导数公式被称为近似<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f'(x_j)\)</span><span class="heti-spacing"> </span></span>的 <strong><span>n+1<span class="heti-spacing"> </span></span>点公式</strong>((n+1)-point formula)。</p>
<p><strong>注</strong></p>
<ul>
<li>一般来说，更多的评估点（即这里的插值点）会带来更大的近似精度</li>
<li>但另一方面，随着评估点的增加，舍入误差也在变大，因此数值微分是<strong>不稳定的</strong>！</li>
</ul>
<p><strong>例子</strong></p>
<p>例<span><span class="heti-spacing"> </span>1</span></p>
<p>题目：给定三个点<span><span class="heti-spacing"> </span><span class="arithmatex">\(x_0, x_0 + h, x_0 + 2h\)</span></span>，请推到关于它们的三点公式，然后选出对于<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f'(x)\)</span><span class="heti-spacing"> </span></span>而言最佳的三点公式。</p>
<p>解答：</p>
<p>根据前面的<span class="heti-skip"><span class="heti-spacing"> </span>n+1<span class="heti-spacing"> </span></span>点公式，不难得到：</p>
<div class="arithmatex">\[
\begin{align}
f'(x_j) = &amp; f(x_0) \Big[ \dfrac{2x_j - x_1 - x_2}{(x_0 - x_1)(x_0 - x_2)} \Big] + f(x_1) \Big[ \dfrac{2x_j - x_0 - x_2}{(x_1 - x_0)(x_1 - x_2)} \Big] \notag \\
&amp; + f(x_2) \Big[ \dfrac{2x_j - x_0 - x_1}{(x_2 - x_0)(x_2 - x_1)} \Big] + \dfrac{1}{6}f^{(3)}(\xi_j) \prod_{\substack{k = 0 \\ k \ne j}}^2(x_j - x_k)\ (j = 0, 1, 2) \notag
\end{align}
\]</div>
<p>将<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(x_0, x_1 = x_0 + h, x_2 = x_0 + 2h\)</span><span class="heti-spacing"> </span></span>代入上述公式，得到以下公式：</p>
<div class="arithmatex">\[
\begin{align}
f'(x_0) &amp; = \dfrac{1}{h}\Big[-\dfrac{3}{2} f(x_0) + 2f(x_0 + h) - \dfrac{1}{2}f(x_0 + 2h) \Big] + \dfrac{h^2}{3} f^{(3)}(\xi_0) \notag \\
f'(x_0 + h) &amp; = \dfrac{1}{h} \Big[ -\dfrac{1}{2} f(x_0) + \dfrac{1}{2} f(x_0 + 2h) \Big] - \dfrac{h^2}{6} f^{(3)}(\xi_1) \notag \\
f'(x_0 + 2h) &amp; = \dfrac{1}{h} \Big[ \dfrac{1}{2} f(x_0) - 2f(x_0 + h) + \dfrac{3}{2} f(x_0 + 2h) \Big] + \dfrac{h^2}{3} f^{(3)}(\xi_2) \notag
\end{align}
\]</div>
<p>方便起见，对于后两个公式，我们用<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(x_0\)</span><span class="heti-spacing"> </span></span>替代原来的<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(x_0 + h\)</span><span class="heti-spacing"> </span></span>和<span><span class="heti-spacing"> </span><span class="arithmatex">\(x_0 + 2h\)</span></span>，得到：</p>
<div class="arithmatex">\[
\begin{align}
f'(x_0) &amp; = \dfrac{1}{h}\Big[-\dfrac{3}{2} f(x_0) + 2f(x_0 + h) - \dfrac{1}{2}f(x_0 + 2h) \Big] + \dfrac{h^2}{3} f^{(3)}(\xi_0) \notag \\
f'(x_0) &amp; = \dfrac{1}{h} \Big[ -\dfrac{1}{2} f(x_0 - h) + \dfrac{1}{2} f(x_0 + h) \Big] - \dfrac{h^2}{6} f^{(3)}(\xi_1) \notag \\
f'(x_0 + 2h) &amp; = \dfrac{1}{h} \Big[ \dfrac{1}{2} f(x_0 - 2h) - 2f(x_0 - h) + \dfrac{3}{2} f(x_0) \Big] + \dfrac{h^2}{3} f^{(3)}(\xi_2) \notag
\end{align}
\]</div>
<p>观察发现第<span class="heti-skip"><span class="heti-spacing"> </span>1<span class="heti-spacing"> </span></span>个和第<span class="heti-skip"><span class="heti-spacing"> </span>3<span class="heti-spacing"> </span></span>个式子唯一的区别仅在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(h\)</span><span class="heti-spacing"> </span></span>和<span><span class="heti-spacing"> </span><span class="arithmatex">\(-h\)</span></span>，所以实际上只剩下<span class="heti-skip"><span class="heti-spacing"> </span>2<span class="heti-spacing"> </span></span>个式子，它们就是我们要找的三点公式：</p>
<div class="arithmatex">\[
\begin{align}
f'(x_0) &amp; = \dfrac{1}{h}\Big[-\dfrac{3}{2} f(x_0) + 2f(x_0 + h) - \dfrac{1}{2}f(x_0 + 2h) \Big] + \dfrac{h^2}{3} f^{(3)}(\xi_0)\ \xi_0 \in [x_0, x_0 + 2h] \notag \\
f'(x_0) &amp; = \dfrac{1}{h} \Big[ -\dfrac{1}{2} f(x_0 - h) + \dfrac{1}{2} f(x_0 + h) \Big] - \dfrac{h^2}{6} f^{(3)}(\xi_1)\ xi_1 \in [x_0 - h, x_0 + h] \notag
\end{align}
\]</div>
<div style="text-align: center">
<img src="images/C4/3.png" width="30%/"/>
</div>
<p>例<span><span class="heti-spacing"> </span>2</span></p>
<p>题目：寻找近似计算<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f''(x_0)\)</span><span class="heti-spacing"> </span></span>的方式。</p>
<p>解答</p>
<p>考虑在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(x_0\)</span><span class="heti-spacing"> </span></span>处的<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f(x_0 + h), f(x_0 - h)\)</span><span class="heti-spacing"> </span></span>的泰勒展开式：</p>
<div class="arithmatex">\[
\begin{align}
f(x_0 + h) &amp; = f(x_0) + f'(x_0) h + \dfrac{1}{2}f''(x_0)h^2 + \dfrac{1}{6} f'''(x_0) h^3 + \dfrac{1}{24} f^{(4)} (\xi_1) h^4 \notag \\
f(x_0 - h) &amp; = f(x_0) - f'(x_0) h + \dfrac{1}{2}f''(x_0)h^2 - \dfrac{1}{6} f'''(x_0) h^3 + \dfrac{1}{24} f^{(4)} (\xi_{-1}) h^4 \notag
\end{align}
\]</div>
<p>因此：<span class="arithmatex">\(f''(x_0) = \dfrac{1}{h^2} [f(x_0 - h) - 2f(x_0) + f(x_0 + h)] - \dfrac{h^2}{12} f^{(4)} (\xi)\)</span></p>
<h2 id="elements-of-numerical-integration">Elements of Numerical Integration<a class="headerlink" href="#elements-of-numerical-integration" title="Permanent link">⚓︎</a></h2>
<p>目标：近似计算<span><span class="heti-spacing"> </span><span class="arithmatex">\(I = \int_a^b f(x) dx\)</span></span>（即<strong>数值求积</strong>(numerical quadratrue)）</p>
<p>思路：使用<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f(x)\)</span><span class="heti-spacing"> </span></span>的<strong>拉格朗日插值多项式</strong>——从区间<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\([a, b]\)</span><span class="heti-spacing"> </span></span>上选择一组不同的点<span><span class="heti-spacing"> </span><span class="arithmatex">\(a \le x_0 &lt; x_1 \dots &lt; x_n \le b\)</span></span>。拉格朗日多项式为<span><span class="heti-spacing"> </span><span class="arithmatex">\(P_n(x) = \sum\limits_{k=0}^n f(x_k) L_k(x)\)</span></span>，因此：</p>
<div class="arithmatex">\[
\int_a^b f(x) dx \approx \sum\limits_{k=0}^n f(x_k) \int_a^b L_k(x) dx
\]</div>
<p>令<span><span class="heti-spacing"> </span><span class="arithmatex">\(A_k = \int_a^b L_k(x) dx = \int_a^b \prod\limits_{j \ne k} \dfrac{x - x_j}{x_k - x_j} dx\)</span></span></p>
<p>误差<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(R[f]\)</span><span class="heti-spacing"> </span></span>为：</p>
<div class="arithmatex">\[
\begin{align}
&amp; R[f] \notag \\
= &amp; \int_a^b f(x) dx - \sum\limits_{k=0}^n A_kf(x_k) \notag \\
= &amp; \int_a^b [f(x) - P_n(x)] dx = \int_a^b R_n(x) dx \notag \\
= &amp; \int_a^b \dfrac{f^{(n+1)}(\xi_x)}{(n+1)!} \prod\limits_{k=0}^n(x - x_k)dx \notag
\end{align}
\]</div>
<p><strong>定义</strong> ：求积公式的<strong>精度</strong><span>(degree of accuracy/precision)<span class="heti-spacing"> </span></span>为最大的正整数<span><span class="heti-spacing"> </span><span class="arithmatex">\(n\)</span></span>，使得公式对于每个<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(x^k(k = 0, 1, \dots, n)\)</span><span class="heti-spacing"> </span></span>都是精确的。</p>
<p><strong>例子</strong></p>
<p>题目</p>
<p>考虑在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\([a, b]\)</span><span class="heti-spacing"> </span></span>上的线性插值，我们有<span><span class="heti-spacing"> </span><span class="arithmatex">\(P_1(x) = \dfrac{x - b}{a - b}f(a) + \dfrac{x - a}{b - a}f(b)\)</span></span>。可以得到：</p>
<ul>
<li><span class="arithmatex">\(A_1 = A_2 = \dfrac{b - a}{2}\)</span></li>
<li><span class="arithmatex">\(\int_a^b f(x) dx \approx \dfrac{b - a}{2}[f(a) + f(b)]\)</span></li>
</ul>
<p>请计算上述公式的精度。</p>
<p>解答</p>
<p>考虑<span><span class="heti-spacing"> </span><span class="arithmatex">\(x^k(k = 0, 1, \dots)\)</span></span>：</p>
<ul>
<li><span class="arithmatex">\(x^0\)</span>：<span class="arithmatex">\(\int_a^b 1dx = b - a = \dfrac{b - a}{2}[1 + 1]\)</span></li>
<li><span class="arithmatex">\(x^1\)</span>：<span class="arithmatex">\(\int_a^b xdx = \dfrac{b^2 - a^2}{2} = \dfrac{b - a}{2}[a + b]\)</span></li>
<li><span class="arithmatex">\(x^2\)</span>：<span class="arithmatex">\(\int_a^b x^2dx = \dfrac{b^3 - a^3}{3} \ne \dfrac{b - a}{2}[a^2 + b^2]\)</span></li>
</ul>
<div style="text-align: center">
<img src="images/C4/4.png" width="40%/"/>
</div>
<p>因此精度阶数<span><span class="heti-spacing"> </span>= 1</span></p>
<hr/>
<p>对于等间距的节点<span><span class="heti-spacing"> </span><span class="arithmatex">\(x_i = a + ih, h = \dfrac{b - a}{n}, i = 0, 1, \dots, n\)</span></span></p>
<div class="arithmatex">\[
\begin{align}
A_i &amp; = \int_{x_0}^{x_n} \prod\limits_{j \ne i} \dfrac{x - x_j}{x_i - x_j} dx \notag \\
&amp; = \int_0^n \prod\limits_{i \ne j} \dfrac{(t - j)h}{(i - j)h} \times h dt = \dfrac{(b - a)\textcolor{green}{(-1)^{n-i}}}{\textcolor{green}{ni!(n - i)!}} \textcolor{green}{\int_0^n \prod\limits_{i \ne j} (t - j) dt} \notag 
\end{align}
\]</div>
<p>其中标绿色的部分（<span class="arithmatex">\(\dfrac{(-1)^{n-i}}{ni!(n - i)!} \int_0^n \prod\limits_{i \ne j} (t - j) dt\)</span>）被称为<strong>科茨系数</strong>(Cotes cofficient)，记作<span><span class="heti-spacing"> </span><span class="arithmatex">\(C_i^{(n)}\)</span></span></p>
<p><strong>注</strong> ：可以看到，科茨系数不取决于<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f(x)\)</span><span class="heti-spacing"> </span></span>或<span><span class="heti-spacing"> </span><span class="arithmatex">\([a, b]\)</span></span>，而仅由<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n, i\)</span><span class="heti-spacing"> </span></span>决定。因此我们可以从一张表中找出这些系数。上述公式称为<strong>牛顿<span class="heti-skip"><span class="heti-spacing"> </span>-<span class="heti-spacing"> </span></span>科茨公式</strong>(Newton-Cotes formula)</p>
<ul>
<li><span class="arithmatex">\(n = 1\)</span></li>
<li><span class="arithmatex">\(C_0^{(1)} = C_1^{(1)} = \dfrac{1}{2}\)</span></li>
<li><span class="arithmatex">\(\int_a^b f(x) dx \approx \dfrac{b - a}{2}[f(a) + f(b)]\)</span>（称为<strong>梯形法则</strong>(trapezoidal rule)）</li>
<li><span class="arithmatex">\(R[f] = \int_a^b \dfrac{f''(\xi_x)}{2!}(x-a)(x-b) dx = -\dfrac{1}{12}h^3f''(\xi)\)</span></li>
<li><span class="arithmatex">\(\xi \in [a, b], h = \dfrac{b - a}{1}\)</span></li>
<li>精度<span><span class="heti-spacing"> </span>= 1</span></li>
<li><span class="arithmatex">\(n = 2\)</span></li>
<li><span class="arithmatex">\(C_0^{(2)} = \dfrac{1}{6}, C_1^{(2)} = \dfrac{2}{3}, C_2^{(2)} = \dfrac{1}{6}\)</span></li>
<li><span class="arithmatex">\(\int_a^b f(x) dx \approx \dfrac{b - a}{6}[f(a) + 4f(\dfrac{a+b}{2}) + f(b)]\)</span>（称为<strong>辛普森法则</strong>(Simpson's rule)）</li>
<li><span class="arithmatex">\(R[f] = -\dfrac{1}{90} h^5 f^{(4)}(\xi)\)</span></li>
<li><span class="arithmatex">\(\xi \in (a, b), h = \dfrac{b - a}{2}\)</span></li>
<li>精度<span><span class="heti-spacing"> </span>= 3</span></li>
<li><span class="arithmatex">\(n = 3\)</span>：<strong>辛普森<span class="heti-skip"><span class="heti-spacing"> </span>3/8<span class="heti-spacing"> </span></span>法则</strong>，精度<span><span class="heti-spacing"> </span>= 3</span>，<span class="arithmatex">\(R[f] = -\dfrac{3}{80}h^5 f^{(5)}(\xi)\)</span></li>
<li><span class="arithmatex">\(n = 4\)</span>：<strong>科茨法则</strong>(Cotes' Rule)，精度<span><span class="heti-spacing"> </span>= 5</span>，3，<span class="arithmatex">\(R[f] = -\dfrac{8}{945}h^7 f^{(6)}(\xi)\)</span></li>
</ul>
<p><strong>定理</strong></p>
<p>对于使用<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n+1\)</span><span class="heti-spacing"> </span></span>个点的牛顿<span class="heti-skip"><span class="heti-spacing"> </span>-<span class="heti-spacing"> </span></span>科茨公式，<span class="arithmatex">\(\exists \xi \in (a, b)\)</span>，使得：</p>
<div class="arithmatex">\[
\int_a^b f(x) dx = \sum\limits_{k=0}^n A_k f(x_k) + \dfrac{h^{n+3}f^{(n+2)}(\xi)}{(n+2)!} \int_0^n t^2(t - 1) \dots (t - n) dt
\]</div>
<ul>
<li>如果<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n\)</span><span class="heti-spacing"> </span></span>为<strong>偶数</strong>，那么<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f \in C^{n+2}[a, b]\)</span><span class="heti-spacing"> </span></span>且<span><span class="heti-spacing"> </span><span class="arithmatex">\(\int_a^b f(x) dx = \sum\limits_{k=0}^n A_k f(x_k) + \dfrac{h^{n+2}f^{(n+1)}(\xi)}{(n+1)!} \int_0^n t(t - 1) \dots (t - n) dt\)</span></span></li>
<li>如果<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n\)</span><span class="heti-spacing"> </span></span>为<strong>奇数</strong>，那么<span><span class="heti-spacing"> </span><span class="arithmatex">\(f \in C^{n+1}[a, b]\)</span></span></li>
</ul>
<h2 id="compotsite-numerical-integration">Compotsite Numerical Integration<a class="headerlink" href="#compotsite-numerical-integration" title="Permanent link">⚓︎</a></h2>
<p>由于高阶多项式容易发生振荡，所以我们用<strong>分段</strong><span>(piecewise)<span class="heti-spacing"> </span></span>插值的方式来近似<span><span class="heti-spacing"> </span><span class="arithmatex">\(f(x)\)</span></span>。这里用到了低阶的牛顿<span class="heti-skip"><span class="heti-spacing"> </span>-<span class="heti-spacing"> </span></span>科茨公式。</p>
<h3 id="composite-trapezoidal-rule">Composite Trapezoidal Rule<a class="headerlink" href="#composite-trapezoidal-rule" title="Permanent link">⚓︎</a></h3>
<p><strong>复合梯形法则</strong><span>(composite trapezoidal rule)<span class="heti-spacing"> </span></span>涉及到的变量有：<span class="arithmatex">\(h = \dfrac{b-a}{n}, x_k = a + kh\ (k=0, \dots, n)\)</span>。</p>
<p>我们将梯形公式作用在每个区间<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\([x_{k-1}, x_k]\)</span><span class="heti-spacing"> </span></span>上，即：</p>
<div class="arithmatex">\[
\int_{x_{k-1}}^{x_k} f(x)dx \approx \dfrac{x_k - x_{k-1}}{2} [f(x_{k-1}) + f(x_k)], k = 1, \dots, n \Rightarrow \\
\int_a^b f(x)dx \approx \sum\limits_{k=1}^n \dfrac{h}{2}[f(x_{k-1}) + f(x_k)] = \dfrac{h}{2}\Big[f(a) + 2\sum\limits_{k=1}^{n-1} f(x_k) + f(b) \Big] = \textcolor{cornflowerblue}{T_n} \\
\begin{align}
R[f] &amp; = \sum\limits_{k=1}^n \Big[-\dfrac{h^3}{12} f''(\xi_k)\Big] = -\dfrac{h^2}{12}(b-a) \dfrac{\sum\limits_{k=1}^n f''(\xi_k)}{n} \notag \\
&amp; = -\dfrac{h^2}{12}(b-a) f''(\xi), \xi \in (a, b) \notag
\end{align}
\]</div>
<blockquote>
<p><span><span class="arithmatex">\(R[f]\)</span><span class="heti-spacing"> </span></span>的公式涉及到<strong>中值定理</strong>(MVT)。</p>
</blockquote>
<h3 id="composite-simpsons-rule">Composite Simpson's Rule<a class="headerlink" href="#composite-simpsons-rule" title="Permanent link">⚓︎</a></h3>
<p><strong>复合辛普森法则</strong><span>(composite Simpson rule)<span class="heti-spacing"> </span></span>涉及到的变量和复合梯形公式一致：<span class="arithmatex">\(h = \dfrac{b-a}{n}, x_k = a + kh\ (k=0, \dots, n)\)</span>。</p>
<p>我们将辛普森公式作用在每个区间<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\([x_{k-1}, x_k]\)</span><span class="heti-spacing"> </span></span>上，即：</p>
<div class="arithmatex">\[
\int_{x_{k-1}}^{x_k} f(x)dx \approx \dfrac{h}{6} [f(x_{k}) + 4 f(x_{k+\frac{1}{2}}) + f(x_{k+1})], k = 1, \dots, n \Rightarrow \\
\int_a^b f(x)dx \approx \dfrac{h}{6}\Big[f(x_a) + 4\sum\limits_{k=0}^{n-1}f(x_{k+\frac{1}{2}}) + 2\sum\limits_{k=0}^{n-2}f(x_{k+1}) + f(x_b)\Big] = \textcolor{cornflowerblue}{S_n} \\
R[f] = -\dfrac{b-a}{180} \Big(\dfrac{h}{2}\Big)^4 f^{(4)}(\xi)
\]</div>
<p><strong>注</strong></p>
<p>为了简化记号，我们令<span><span class="heti-spacing"> </span><span class="arithmatex">\(n' = 2n\)</span></span>，那么<span><span class="heti-spacing"> </span><span class="arithmatex">\(h' = \dfrac{b-a}{n'} = \dfrac{h}{2}, x_k = a+kh'\)</span></span>，所以：</p>
<div class="arithmatex">\[
S_n = \dfrac{h'}{3}[f(a) + 4 \sum\limits_{odd\ k} f(x_k) + 2 \sum\limits_{even\ k} f(x_k) + f(b)]
\]</div>
<hr/>
<p>上述的复合方法都是<strong>稳定的</strong>。来看下面这个例子：</p>
<p><strong>例子</strong></p>
<p>考虑在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\([a, b]\)</span><span class="heti-spacing"> </span></span>上有<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n\)</span><span class="heti-spacing"> </span></span>个子区间的辛普森法则。假设<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f(x_i)\)</span><span class="heti-spacing"> </span></span>由<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f^*(x_i)\)</span><span class="heti-spacing"> </span></span>近似，满足<span><span class="heti-spacing"> </span><span class="arithmatex">\(f(x_i) = f^*(x_i) + \varepsilon_i\ (i = 0, \dots, n)\)</span></span>，那么累积误差为：</p>
<div class="arithmatex">\[
e(h) = \Big|\dfrac{h}{3}[\varepsilon_0 + 4 \sum\limits_{odd\ k} \varepsilon_k + 2 \sum\limits_{even\ k} \varepsilon_k + \varepsilon_n]\Big|
\]</div>
<p>若<span><span class="heti-spacing"> </span><span class="arithmatex">\(|\varepsilon_i| &lt; \varepsilon\ (i = 0, \dots, n)\)</span></span>，那么：</p>
<div class="arithmatex">\[
e(h) &lt; \dfrac{h}{3} [\varepsilon + 4(n/2)\varepsilon + 2(n/2-1)\varepsilon + \varepsilon] = nh\varepsilon = (b-a)\varepsilon
\]</div>
<p>可以看到，当我们修正分区，以确保准确性时，增加的计算量<strong>不会</strong>带来更多的舍入误差。</p>
<p><strong>讨论</strong></p>
<p>题目：使用<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n=8\)</span><span class="heti-spacing"> </span></span>梯形法则和辛普森法则来近似<span><span class="heti-spacing"> </span><span class="arithmatex">\(\pi = \int_0^1 \dfrac{4}{1+x^2} dx\)</span></span>。</p>
<p>答案</p>
<div class="arithmatex">\[
\begin{align}
T_8 &amp; = \dfrac{1}{16}\Big[f(0) + 2\sum\limits_{k=1}^7f(x_k) + f(1)\Big] \quad \text{where } x_k = \dfrac{k}{8} \notag \\
&amp; = \textcolor{green}{3.1}\textcolor{red}{383988494} \notag
\end{align}
\]</div>
<div class="arithmatex">\[
\begin{align}
S_4 &amp; = \dfrac{1}{24}\Big[f(0) + 4\sum\limits_{odd}f(x_k)+ 2\sum\limits_{even}f(x_k) + f(1)\Big] \quad \text{where } x_k = \dfrac{k}{8} \notag \\
&amp; = \textcolor{green}{3.141592}\textcolor{red}{502} \notag
\end{align}
\]</div>
<p>在编程的时候，我们通常会将一个子区间划分为两个均等宽度的更小的子区间。也就是说，令<span><span class="heti-spacing"> </span><span class="arithmatex">\(n = 2^k\ (k = 0, 1, \dots)\)</span></span></p>
<p>当<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(k=9\)</span><span class="heti-spacing"> </span></span>时，<span class="arithmatex">\(T_{512} = \textcolor{green}{3.141592}\textcolor{red}{02}\)</span></p>
<p><span class="arithmatex">\(\dfrac{4}{3}T_8 - \dfrac{1}{3}T_4 = \textcolor{green}{3.141592}\textcolor{red}{502} = S_4\)</span></p>
<h2 id="romberg-integration">Romberg Integration<a class="headerlink" href="#romberg-integration" title="Permanent link">⚓︎</a></h2>
<p>回顾一下梯形法则的误差公式：<span class="arithmatex">\(R_n[f] = -\dfrac{h^2}{12}(b-a)f''(\xi)\)</span>。当我们将每个子区间的长度缩减至原来的一半时，</p>
<div class="arithmatex">\[
R_{2n}[f] = -\Big(\dfrac{h}{2}\Big)^2 \dfrac{1}{12}(b-a)f''(\xi') \approx \dfrac{1}{4}R_n[f]
\]</div>
<p>从而得到：<span class="arithmatex">\(\dfrac{I - T_{2n}}{I - T_n} \approx \dfrac{1}{4}\)</span>，解得<span><span class="heti-spacing"> </span><span class="arithmatex">\(I \approx \dfrac{4T_{2n} - T_n}{4 - 1} = \dfrac{4}{3}T_{2n} - \dfrac{1}{3}T_n = S_n\)</span></span></p>
<p>一般情况下：</p>
<ul>
<li><span class="arithmatex">\(\dfrac{4T_{2n} - T_n}{4 - 1} = S_n\)</span></li>
<li><span class="arithmatex">\(\dfrac{4^2S_{2n} - S_n}{4^2 - 1} = C_n\)</span></li>
<li><span class="arithmatex">\(\dfrac{4^3C_{2n} - C_n}{4^3 - 1} = R_n\)</span> -&gt; <strong><span>Romberg<span class="heti-spacing"> </span></span>序列</strong>(Romberg sequence)</li>
</ul>
<p><strong><span>Romberg<span class="heti-spacing"> </span></span>法</strong>如下所示：</p>
<div style="text-align: center">
<img src="images/C4/5.png" width="80%/"/>
</div>
<p>可以看到，<span>Romberg<span class="heti-spacing"> </span></span>法通过不断将积分区间对分（涉及到接下来介绍的<a href="#richardsons-extrapolation"><span class="heti-skip"><span class="heti-spacing"> </span>Richardson<span class="heti-spacing"> </span></span>外推法</a><heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，在这些子区间上作用<a href="#composite-trapezoidal-rule">（复合）梯形法则</a>，从而提高积分精度。</p>
<p>其递推公式为：</p>
<div class="arithmatex">\[
R_{k, j} = R_{k, j-1} + \dfrac{1}{4^{j-1} - 1}(R_{k, j-1} - R_{k-1, j-1}) \quad k = j, j+1, \dots
\]</div>
<p>对应的表格为：</p>
<div class="arithmatex">\[
\begin{matrix}
h &amp; R_{1, 1} \\
\frac{h}{2} &amp; R_{2, 1} &amp; R_{2, 2} \\
\frac{h}{4} &amp; R_{3, 1} &amp; R_{3, 2} &amp; R_{3, 3} \\
\vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \ddots \\
\frac{h}{2^{n-1}} &amp; R_{n, 1} &amp; R_{n, 2} &amp; R_{n, 3} &amp; \dots &amp; R_{n, n}
\end{matrix}
\]</div>
<p><strong>算法：Romberg</strong></p>
<p>近似积分<span><span class="heti-spacing"> </span><span class="arithmatex">\(I = \int_a^b f(x) dx\)</span></span>，选择整数<span><span class="heti-spacing"> </span><span class="arithmatex">\(n &gt; 0\)</span></span></p>
<ul>
<li>输入：端点<span><span class="heti-spacing"> </span><span class="arithmatex">\(a, b\)</span></span>；整数<span><span class="heti-spacing"> </span><span class="arithmatex">\(n\)</span></span></li>
<li>输出：数组<span><span class="heti-spacing"> </span><span class="arithmatex">\(R\)</span></span>（按行计算<span><span class="heti-spacing"> </span><span class="arithmatex">\(R\)</span></span>；只保留<span class="heti-skip"><span class="heti-spacing"> </span>2<span class="heti-spacing"> </span></span>行（节省空间<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>）</li>
</ul>
<div class="language-c highlight"><pre><span></span><code><span id="__span-20-1"><a href="#__codelineno-20-1" id="__codelineno-20-1" name="__codelineno-20-1"></a><span class="n">Step</span><span class="w"> </span><span class="mi">1</span><span class="w">  </span><span class="n">Set</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
</span><span id="__span-20-2"><a href="#__codelineno-20-2" id="__codelineno-20-2" name="__codelineno-20-2"></a><span class="w">            </span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="p">));</span>
</span><span id="__span-20-3"><a href="#__codelineno-20-3" id="__codelineno-20-3" name="__codelineno-20-3"></a><span class="n">Step</span><span class="w"> </span><span class="mi">2</span><span class="w">  </span><span class="n">Output</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]);</span>
</span><span id="__span-20-4"><a href="#__codelineno-20-4" id="__codelineno-20-4" name="__codelineno-20-4"></a><span class="n">Step</span><span class="w"> </span><span class="mi">3</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="n">steps</span><span class="w"> </span><span class="mi">4-8</span><span class="o">:</span>
</span><span id="__span-20-5"><a href="#__codelineno-20-5" id="__codelineno-20-5" name="__codelineno-20-5"></a><span class="w">    </span><span class="c1">// approximation from Trapezoidal method</span>
</span><span id="__span-20-6"><a href="#__codelineno-20-6" id="__codelineno-20-6" name="__codelineno-20-6"></a><span class="w">    </span><span class="n">Step</span><span class="w"> </span><span class="mi">4</span><span class="w">  </span><span class="n">Set</span><span class="w"> </span><span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="o">/</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">[</span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">sum</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="mi">-2</span><span class="p">),</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">k</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">0.5</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">h</span><span class="p">))];</span>
</span><span id="__span-20-7"><a href="#__codelineno-20-7" id="__codelineno-20-7" name="__codelineno-20-7"></a><span class="w">    </span><span class="n">Step</span><span class="w"> </span><span class="mi">5</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">i</span><span class="o">:</span>
</span><span id="__span-20-8"><a href="#__codelineno-20-8" id="__codelineno-20-8" name="__codelineno-20-8"></a><span class="w">                </span><span class="c1">// extrapolation</span>
</span><span id="__span-20-9"><a href="#__codelineno-20-9" id="__codelineno-20-9" name="__codelineno-20-9"></a><span class="w">                </span><span class="n">set</span><span class="w"> </span><span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">j</span><span class="mi">-1</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">j</span><span class="mi">-1</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="mi">-1</span><span class="p">])</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">pow</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
</span><span id="__span-20-10"><a href="#__codelineno-20-10" id="__codelineno-20-10" name="__codelineno-20-10"></a><span class="w">    </span><span class="n">Step</span><span class="w"> </span><span class="mi">6</span><span class="w">  </span><span class="n">Output</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">i</span><span class="p">);</span>
</span><span id="__span-20-11"><a href="#__codelineno-20-11" id="__codelineno-20-11" name="__codelineno-20-11"></a><span class="w">    </span><span class="n">Step</span><span class="w"> </span><span class="mi">7</span><span class="w">  </span><span class="n">Set</span><span class="w"> </span><span class="n">h</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
</span><span id="__span-20-12"><a href="#__codelineno-20-12" id="__codelineno-20-12" name="__codelineno-20-12"></a><span class="w">    </span><span class="n">Step</span><span class="w"> </span><span class="mi">8</span><span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="n">set</span><span class="w"> </span><span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">j</span><span class="p">];</span><span class="w">    </span><span class="c1">// update row 1 of R</span>
</span><span id="__span-20-13"><a href="#__codelineno-20-13" id="__codelineno-20-13" name="__codelineno-20-13"></a><span class="n">Step</span><span class="w"> </span><span class="mi">9</span><span class="w">  </span><span class="n">STOP</span><span class="p">.</span>
</span></code></pre></div>
<h2 id="richardsons-extrapolation">Richardson's Extrapolation<a class="headerlink" href="#richardsons-extrapolation" title="Permanent link">⚓︎</a></h2>
<p><strong><span>Richardson<span class="heti-spacing"> </span></span>外推法</strong><span>(Richardson's extrapolation)<span class="heti-spacing"> </span></span>实现的目标是：使用低阶公式获取高精度的结果。</p>
<p>它的核心思想是：利用同一数值方法在不同步长下计算出的结果，通过线性组合来消除或减小近似解中的主要误差项，从而得到一个更高精度的估计值。</p>
<blockquote>
<p>这和求解一元方程的<a href="2.html#aitkens--method"><span class="heti-skip"><span class="heti-spacing"> </span>Aitken's <span class="arithmatex">\(\Delta^2\)</span><span class="heti-spacing"> </span></span>法</a>在思想上有共通之处。</p>
</blockquote>
<p>假设对于某些<span><span class="heti-spacing"> </span><span class="arithmatex">\(h \ne 0\)</span></span>，我们有公式<span><span class="heti-spacing"> </span><span class="arithmatex">\(T_0(h)\)</span></span>，用于近似未知量<span><span class="heti-spacing"> </span><span class="arithmatex">\(I\)</span></span>，并且其<strong>截断误差</strong>的形式为：</p>
<div class="arithmatex">\[
T_0(h) - I = \alpha_1 h + \alpha_2 h^2 + \alpha_3 h^3 + \dots
\]</div>
<p>用<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(h\)</span><span class="heti-spacing"> </span></span>一半的值替代自身，我们有：</p>
<div class="arithmatex">\[
T_0(h/2) - I = \alpha_1 (h/2) + \alpha_2 (h/2)^2 + \alpha_3 (h/2)^3 + \dots
\]</div>
<p>结合上述两个公式，我们就可以将精度从<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(O(h)\)</span><span class="heti-spacing"> </span></span>提升至<span><span class="heti-spacing"> </span><span class="arithmatex">\(O(h^2)\)</span></span>：</p>
<div class="arithmatex">\[
\dfrac{2T_0(\frac{h}{2}) - T_0(h)}{2 - 1} - I = -\dfrac{1}{2}\alpha_2 h^2 - \dfrac{3}{4} \alpha_3 h^3 - \dots
\]</div>
<p>令<span><span class="heti-spacing"> </span><span class="arithmatex">\(T_1 = \dfrac{2T_0(\frac{h}{2}) - T_0(h)}{2 - 1} = I + \beta_1 h^2 + \beta_2 h^3 + \dots\)</span></span>。类似地，我们可以将精度提升至<span><span class="heti-spacing"> </span><span class="arithmatex">\(O(h^3)\)</span></span>：</p>
<div class="arithmatex">\[
T_2 = \dfrac{2^2T_1(\frac{h}{2}) - T_1(h)}{2^2 - 1} = I + \gamma_1 h^3 + \gamma_2 h^4 + \dots
\]</div>
<p>以此类推，我们可以将精度可以提升到<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(m+1\)</span><span class="heti-spacing"> </span></span>阶：</p>
<div class="arithmatex">\[
T_m = \dfrac{2^mT_{m-1}(\frac{h}{2}) - T_{m-1}(h)}{2^m - 1} = I + \delta_1 h^{m+1} + \delta_2 h^{m+2} + \dots
\]</div>
<p><strong>例子</strong></p>
<p>题目</p>
<div style="text-align: center">
<img src="images/C4/7.png" width="80%/"/>
</div>
<p>解答</p>
<p>由<span class="heti-skip"><span class="heti-spacing"> </span>Gemini 2.5 pro<span class="heti-spacing"> </span></span>作答，且通过笔者验证。</p>
<ol>
<li>
<p>建立误差方程：</p>
<p>令<span><span class="heti-spacing"> </span><span class="arithmatex">\(N(A) = \frac{f(x_0+A)-2f(x_0)+f(x_0-A)}{A^2}\)</span></span>。我们可以将真实值表示为：</p>
<div class="arithmatex">\[f''(x_0) = N(A) + K_1A^2 + K_2A^4 + \dots\]</div>
<p>其中<span><span class="heti-spacing"> </span><span class="arithmatex">\(K_1 = -\frac{f^{(4)}(x_0)}{12}\)</span></span>。</p>
</li>
<li>
<p>使用两种步长：</p>
<p>我们使用步长<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A/2\)</span><span class="heti-spacing"> </span></span>来计算近似值：</p>
<ul>
<li><strong>步长<span><span class="heti-spacing"> </span>A</span></strong>: <span class="arithmatex">\(f''(x_0) = N(A) + K_1A^2 + K_2A^4 + \dots\)</span>（式<span><span class="heti-spacing"> </span>1</span>）</li>
<li><strong>步长<span><span class="heti-spacing"> </span>A/2</span></strong>: <span class="arithmatex">\(f''(x_0) = N(A/2) + K_1(A/2)^2 + K_2(A/2)^4 + \dots = N(A/2) + \frac{K_1}{4}A^2 + \frac{K_2}{16}A^4 + \dots\)</span>（式<span><span class="heti-spacing"> </span>2</span>）</li>
</ul>
</li>
<li>
<p>消除<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(O(A^2)\)</span><span class="heti-spacing"> </span></span>误差项：</p>
<p>为了消除<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(K_1A^2\)</span><span class="heti-spacing"> </span></span>项，我们将（式<span><span class="heti-spacing"> </span>2</span>）乘以<span><span class="heti-spacing"> </span>4</span>，然后减去（式<span><span class="heti-spacing"> </span>1</span><heti-adjacent class="heti-adjacent-half">）</heti-adjacent>：</p>
<ul>
<li><span class="arithmatex">\(4f''(x_0) = 4N(A/2) + K_1A^2 + \frac{K_2}{4}A^4 + \dots\)</span></li>
<li><span class="arithmatex">\(f''(x_0) = N(A) + K_1A^2 + K_2A^4 + \dots\)</span></li>
</ul>
<p>两式相减得到：</p>
<p><span class="arithmatex">\(3f''(x_0) = 4N(A/2) - N(A) - \frac{3K_2}{4}A^4 + \dots\)</span></p>
</li>
<li>
<p>导出新公式：</p>
<p>整理上式，我们得到一个新的<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f''(x_0)\)</span><span class="heti-spacing"> </span></span>的近似公式，其误差项为<span><span class="heti-spacing"> </span><span class="arithmatex">\(O(A^4)\)</span></span>：</p>
<div class="arithmatex">\[f''(x_0) \approx \frac{4N(A/2) - N(A)}{3}\]</div>
<p>这个公式的误差为<span><span class="heti-spacing"> </span><span class="arithmatex">\(O(A^4)\)</span></span>，比原来的<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(O(A^2)\)</span><span class="heti-spacing"> </span></span>精度更高。</p>
</li>
</ol>
<h2 id="adapative-quadrature-methods">Adapative Quadrature Methods<a class="headerlink" href="#adapative-quadrature-methods" title="Permanent link">⚓︎</a></h2>
<p>目标：预测函数变化量，根据变化的需求调整步幅。</p>
<p>前面介绍的复合积分方法的缺点是：对所有区间递归划分子区间，这样计算量太大，而且还有产生了许多不必要的计算，这很浪费。因此，我们采用一种仅对具有<strong>较大误差</strong><span>(large error)<span class="heti-spacing"> </span></span>的区间进行划分的方法，避免额外的计算。我们称这样的方法为<strong>自适应求积方法</strong>(adapative quadrature mehtods)。</p>
<p>那么什么算“较大误差”呢？一种简单的确定策略是使用<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\int_a^b f(x) dx\)</span><span class="heti-spacing"> </span></span>的总误差<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\varepsilon\)</span><span class="heti-spacing"> </span></span>来确定边界：在长度为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(h\)</span><span class="heti-spacing"> </span></span>的区间中，误差应该要小于<span><span class="heti-spacing"> </span><span class="arithmatex">\(h \dfrac{\varepsilon}{b - a}\)</span></span>。当误差超过这个值时，我们就认为是较大误差，需要继续划分该区间。</p>
<p>接下来的问题就是如何估计一个区间的误差。这里我们暂时仅考虑辛普森法则下的误差估计——即如何估计：</p>
<div class="arithmatex">\[
\varepsilon(f, a, b) \approx \int_a^b f(x)dx - S(a, b) = \dfrac{h^5}{90} f^{(4)}(\xi)
\]</div>
<p>其中<span><span class="heti-spacing"> </span><span class="arithmatex">\(h = \dfrac{b-a}{2}, \xi \in [a, b]\)</span></span>。</p>
<p>这个问题的答案在例<span class="heti-skip"><span class="heti-spacing"> </span>2<span class="heti-spacing"> </span></span>中给出。</p>
<p><strong>例子</strong></p>
<p>考虑基于复合辛普森法则的自适应方法：</p>
<div class="arithmatex">\[
\int_a^b f(x)dx = S(a, b) - \dfrac{h^5}{90}f^{(4)}(\xi)
\]</div>
<p>其中<span><span class="heti-spacing"> </span><span class="arithmatex">\(S(a, b) = \dfrac{h}{3}[f(a) + 4f(a + h) + f(b)], h = \dfrac{b-a}{2}\)</span></span>。令：</p>
<div class="arithmatex">\[
\begin{align}
S\Big(a, \dfrac{a+b}{2}\Big) = \dfrac{h}{6}[f(a) + 4f(a + h/2) + f(a + h)] \notag \\
S\Big(\dfrac{a+b}{2}, b\Big) = \dfrac{h}{6}[f(a + h) + 4f(a + 3h/2) + f(b)] \notag
\end{align}
\]</div>
<p>那么：</p>
<div class="arithmatex">\[
\int_a^b f(x) dx = S\Big(a, \dfrac{a+b}{2}\Big) + S\Big(\dfrac{a+b}{2}, b\Big) - \dfrac{1}{16} \times \dfrac{h^5}{90}f^{(4)}(\eta) \\
\begin{align}
&amp;\ \Big| \int_a^b f(x) dx - S\Big(a, \dfrac{a+b}{2}\Big) - S\Big(\dfrac{a+b}{2}, b\Big) \Big| \notag \\
\approx &amp;\ \dfrac{1}{15} \Big|S(a, b) - S\Big(a, \dfrac{a+b}{2}\Big) - S\Big(\dfrac{a+b}{2}, b\Big) \Big| \notag \\
&lt; &amp;\ \varepsilon \notag
\end{align}
\]</div>
<p>可以看到，相比一般的辛普森法则，结合自适应方法后误差只有原来的<span><span class="heti-spacing"> </span><span class="arithmatex">\(\dfrac{1}{15}\)</span></span> 🎉</p>
<h2 id="gaussian-quadrature">Gaussian Quadrature<a class="headerlink" href="#gaussian-quadrature" title="Permanent link">⚓︎</a></h2>
<p>目标：构造一个公式<span><span class="heti-spacing"> </span><span class="arithmatex">\(\int_a^b w(x) f(x) dx \approx \sum\limits_{k=0}^n A_k f(x_k)\)</span></span>，对于<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n+1\)</span><span class="heti-spacing"> </span></span>个点而言精度为<span><span class="heti-spacing"> </span><span class="arithmatex">\(2n+1\)</span></span>。</p>
<p>思路：确定<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(2n+2\)</span><span class="heti-spacing"> </span></span>个未知量<span><span class="heti-spacing"> </span><span class="arithmatex">\(x_0, \dots, x_n;\ A_0, \dots, A_n\)</span></span>，使得公式在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f(x) = 1, x, x^2, \dots, x^{2n+1}\)</span><span class="heti-spacing"> </span></span>上都是精确的。点<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(x_0, \dots, x_n\)</span><span class="heti-spacing"> </span></span>被称为<strong>高斯点</strong>(Gaussian points)，这个方法被称为<strong>高斯求积</strong>(Gaussian quadrature)</p>
<p><strong>讨论</strong></p>
<p>题目：使用<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n = 1\)</span><span class="heti-spacing"> </span></span>的高斯求积近似表示<span><span class="heti-spacing"> </span><span class="arithmatex">\(\int_0^1 \sqrt{x} f(x) dx\)</span></span>。</p>
<p>解答</p>
<p>假设<span><span class="heti-spacing"> </span><span class="arithmatex">\(\int_0^1 \sqrt{x} f(x) dx \approx A_0 f(x_0) + A_1 f(x_1)\)</span></span>。</p>
<p>公式必须在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f(x) = 1, x, x^2, x^3\)</span><span class="heti-spacing"> </span></span>上精确表示。计算<span><span class="heti-spacing"> </span><span class="arithmatex">\(\begin{cases}\frac{2}{3} = A_0 + A_1 \\ \frac{2}{5} = A_0 x_0 + A_1 x_1 \\ \frac{2}{7} = A_0 x_0^2 + A_1 x_1^2 \\ \frac{2}{9} = A_0x_0^3 + A_1 x_1^3\end{cases}\)</span></span>，解得：<span class="arithmatex">\(\begin{cases}x_0 \approx 0.8212 \\ x_1 \approx 0.2899 \\ A_0 \approx 0.3891 \\ A_1 \approx 0.2776\end{cases}\)</span></p>
<p><strong>定理</strong> ：当且仅当<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(W(x) = \prod\limits_{k=0}^n(x - x_k)\)</span><span class="heti-spacing"> </span></span>与所有阶数不超过<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n\)</span><span class="heti-spacing"> </span></span>的多项式正交时，<span><span class="arithmatex">\(x_0, \dots, x_n\)</span><span class="heti-spacing"> </span></span>是<strong>高斯点</strong>。</p>
<p>正交多项式的集合<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\{\varphi_0, \varphi_1, \dots, \varphi_n, \dots\}\)</span><span class="heti-spacing"> </span></span>是线性独立的，且<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\varphi_{n+1}\)</span><span class="heti-spacing"> </span></span>和任何多项式<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(P_m(x)\ (m \le n)\)</span><span class="heti-spacing"> </span></span>正交。所以，如果我们拿<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\varphi_{n+1}\)</span><span class="heti-spacing"> </span></span>作为<span><span class="heti-spacing"> </span><span class="arithmatex">\(W(x)\)</span></span>，那么 <strong><span><span class="arithmatex">\(\varphi_{n+1}\)</span><span class="heti-spacing"> </span></span>的根</strong>就是高斯点了。</p>
<p><strong>例子</strong></p>
<p>题目：使用高斯求积来近似计算<span><span class="heti-spacing"> </span><span class="arithmatex">\(\int_0^1 \sqrt{x} f(x) dx\)</span></span>，其中<span><span class="heti-spacing"> </span><span class="arithmatex">\(n = 1\)</span></span></p>
<p>解答</p>
<p>假设<span><span class="heti-spacing"> </span><span class="arithmatex">\(\int_0^1 \sqrt{x} f(x) dx \approx A_0 f(x_0) + A_1 f(x_1)\)</span></span>。</p>
<ol>
<li>
<p>构造正交多项式<span><span class="heti-spacing"> </span><span class="arithmatex">\(\varphi_2\)</span></span>。令<span><span class="heti-spacing"> </span><span class="arithmatex">\(\varphi_0(x) = 1, \varphi_1(x) = x + a, \varphi_2(x) = x^2 + bx + c\)</span></span></p>
<ul>
<li><span class="arithmatex">\((\varphi_0, \varphi_1) = 0 \Rightarrow \int_0^1 \sqrt{x} (x + a) dx = 0 \Rightarrow a = - \dfrac{3}{5}\)</span></li>
<li><span class="arithmatex">\((\varphi_0, \varphi_2) = 0 \Rightarrow \int_0^1 \sqrt{x} (x^2 + bx + c) dx = 0 \Rightarrow a = - \dfrac{10}{9}\)</span></li>
<li><span class="arithmatex">\((\varphi_1, \varphi_2) = 0 \Rightarrow \int_0^1 \sqrt{x} (x - \dfrac{3}{5})(x + bx + c) dx = 0 \Rightarrow a = \dfrac{5}{21}\)</span></li>
<li><span class="arithmatex">\(\therefore \varphi_2(x) = x^2 - \dfrac{10}{9}x + \dfrac{5}{21}\)</span></li>
</ul>
</li>
<li>
<p>找到<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\varphi_2\)</span><span class="heti-spacing"> </span></span>的两个根，作为高斯点<span><span class="heti-spacing"> </span><span class="arithmatex">\(x_0, x_1\)</span></span>：<span class="arithmatex">\(x_{0;1} = \dfrac{\frac{10}{9} \pm \sqrt{(\frac{10}{9})^2 - \frac{20}{21}}}{2}\)</span></p>
</li>
<li>
<p>因为这个公式必须在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f(x) = 1, x\)</span><span class="heti-spacing"> </span></span>上是精确的，所以我们能比较容易地求解<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A_0, A_1\)</span><span class="heti-spacing"> </span></span>的线性方程组（待定系数）</p>
</li>
</ol>
<p>最终结果为：<span class="arithmatex">\(x_0 \approx 0.8212, x_1 \approx 0.2899, A_0 \approx 0.3891, A_1 \approx 0.2776\)</span></p>
<p>现在使用上述结果来近似计算<span><span class="heti-spacing"> </span><span class="arithmatex">\(\int_0^1 \sqrt{x} e^x dx\)</span></span></p>
<div class="arithmatex">\[
\int_0^1 \sqrt{x} e^x dx \approx A_0 e^{x_0} + A_1 e^{x_1} = 0.3891 \times e^{0.8212} + 0.2776 \times e^{0.2899} \approx 1.2555
\]</div>
<p>而<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\int_0^1 \sqrt{x} (2x-1) dx = \dfrac{2}{15}\)</span><span class="heti-spacing"> </span></span>是精确的。</p>
<p>一些特殊的正交多项式：</p>
<ul>
<li><strong>勒让德多项式</strong>(Legendre polynomials)：定义在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\([-1, 1]\)</span><span class="heti-spacing"> </span></span>上且<span><span class="heti-spacing"> </span><span class="arithmatex">\(w(x) \equiv 1\)</span></span></li>
</ul>
<p>$$
  P_k(x) = \dfrac{1}{2^k k!} \dfrac{d<sup>k}{dx</sup>k}(x^2 - 1)^k \quad \quad (P_k, P_l) = \begin{cases}0 &amp; k \ne l \ \dfrac{2}{2k+1} &amp; k = l\end{cases}
  $$</p>
<p><span class="arithmatex">\(P_0 = 1, P_1 = x, (k + 1)P_{k+1} = (2k + 1)xP_k - kP_{k-1}\)</span></p>
<p>使用<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(P_{n+1}\)</span><span class="heti-spacing"> </span></span>的根的公式称为<strong>高斯<span class="heti-skip"><span class="heti-spacing"> </span>-<span class="heti-spacing"> </span></span>勒让德求积公式</strong>。</p>
<ul>
<li><strong>切比雪夫多项式</strong>(Chebyshev polynomials)：定义在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\([-1, 1]\)</span><span class="heti-spacing"> </span></span>上且<span><span class="heti-spacing"> </span><span class="arithmatex">\(w(x) = \dfrac{1}{\sqrt{1 - x^2}}\)</span></span></li>
</ul>
<p>$$
  T_k(x) = \cos (k \times \arccos x)
  $$</p>
<p><span><span class="arithmatex">\(T_{n+1}\)</span><span class="heti-spacing"> </span></span>的根为<span><span class="heti-spacing"> </span><span class="arithmatex">\(x_k = \cos \Big(\dfrac{2k + 1}{2n + 2} \pi \Big) \quad (k = 0, \dots, n)\)</span></span></p>
<p>公式<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\int_{-1}^1 \dfrac{1}{\sqrt{1 - x^2}} f(x) dx = \sum\limits_{k=0}^n A_k f(x_k)\)</span><span class="heti-spacing"> </span></span>称为<strong>高斯<span class="heti-skip"><span class="heti-spacing"> </span>-<span class="heti-spacing"> </span></span>切比雪夫求积公式</strong>。</p>
<ul>
<li>注意到积分端点<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\pm 1\)</span><span class="heti-spacing"> </span></span>是积分上的<strong>奇点</strong>(singular points)，此时在等间距的点上使用牛顿<span class="heti-skip"><span class="heti-spacing"> </span>-<span class="heti-spacing"> </span></span>科茨公式会出现问题；而高斯积分能够避免这个问题。</li>
</ul>
<h1 id="chap-5-initial-value-problems-for-ordinary-differential-equations">Chap 5: Initial-Value Problems for Ordinary Differential Equations<a class="headerlink" href="#chap-5-initial-value-problems-for-ordinary-differential-equations" title="Permanent link">⚓︎</a></h1>
<h2 id="the-elementary-theory-of-initial-value-problems">The Elementary Theory of Initial-Value Problems<a class="headerlink" href="#the-elementary-theory-of-initial-value-problems" title="Permanent link">⚓︎</a></h2>
<p><span>1<span class="heti-spacing"> </span></span>阶<a href="https://en.wikipedia.org/wiki/Ordinary_differential_equation"><strong>常微分方程</strong></a><span>(ordinary differential equations, ODE)<span class="heti-spacing"> </span></span>的<a href="https://en.wikipedia.org/wiki/Initial_value_problem"><strong>初值问题</strong></a>(initial-value problems, IVP)：</p>
<div class="arithmatex">\[
\begin{cases}
\dfrac{dy}{dt} = f(t, y), t \in [a, b] \\
y(a) = \alpha
\end{cases}
\]</div>
<blockquote>
<p>第一个方程表达的意思的是（未知）函数<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(y\)</span><span class="heti-spacing"> </span></span>随自变量<span><span class="heti-spacing"> </span><span class="arithmatex">\(t\)</span></span>（往往是时间）的变化率是一个关于<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(t, y\)</span><span class="heti-spacing"> </span></span>的（已知）函数；第二个方程就是初始条件。</p>
</blockquote>
<p>目标：在一组网格点<span class="heti-skip"><span class="heti-spacing"> </span>(mesh points) <span class="arithmatex">\(a = t_0 &lt; t_1 &lt; \dots &lt; t_n = b\)</span><span class="heti-spacing"> </span></span>上（通常是等间距的）计算<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(y(t)\)</span><span class="heti-spacing"> </span></span>的近似值。也就是说，计算<span><span class="heti-spacing"> </span><span class="arithmatex">\(w_i \approx y(t_i) = y_i\ (i = 1, \dots, n)\)</span></span>。</p>
<p><strong>定义</strong> ：</p>
<p>对于函数<span><span class="heti-spacing"> </span><span class="arithmatex">\(f(t, y)\)</span></span>，若存在常数<span><span class="heti-spacing"> </span><span class="arithmatex">\(L &gt; 0\)</span></span>，满足：</p>
<div class="arithmatex">\[
|f(t, y_1) - f(t, y_2)| \le L|y_1 - y_2|
\]</div>
<p>我们称该函数满足在变量<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(y \in D \subset R^2\)</span><span class="heti-spacing"> </span></span>上的 <strong><span>Lipschitz<span class="heti-spacing"> </span></span>条件</strong>。</p>
<p><strong>定理</strong> ：</p>
<p>假设<span><span class="heti-spacing"> </span><span class="arithmatex">\(D = \{(t, y)\ |\ a \le t \le b, -\infty &lt; y &lt; \infty\}\)</span></span>，且<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f(t, y)\)</span><span class="heti-spacing"> </span></span>在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(D\)</span><span class="heti-spacing"> </span></span>上连续。若<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f\)</span><span class="heti-spacing"> </span></span>满足在变量<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(y \in D\)</span><span class="heti-spacing"> </span></span>上的<span class="heti-skip"><span class="heti-spacing"> </span>Lipschitz<span class="heti-spacing"> </span></span>条件，那么初值问题</p>
<div class="arithmatex">\[
y'(t) = f(t, y), a \le t \le b, y(a) = \alpha
\]</div>
<p>有<strong>唯一解</strong> <span class="arithmatex">\(y(t)\)</span>（<span class="arithmatex">\(a \le t \le b\)</span><heti-adjacent class="heti-adjacent-half">）</heti-adjacent>。</p>
<p><strong>定义</strong> ：</p>
<p>若初值问题</p>
<div class="arithmatex">\[
y'(t) = f(t, y), a \le t \le b, y(a) = \alpha
\]</div>
<p>满足以下条件，我们称之为<strong>适定性问题</strong>(well-posed problem)：</p>
<ul>
<li>问题存在唯一解<span><span class="heti-spacing"> </span><span class="arithmatex">\(y(t)\)</span></span></li>
<li>
<p><span class="arithmatex">\(\forall \varepsilon &gt; 0\)</span>，存在正常数<span><span class="heti-spacing"> </span><span class="arithmatex">\(k(\varepsilon)\)</span></span>，使得当<span><span class="heti-spacing"> </span><span class="arithmatex">\(|\varepsilon_0| &lt; \varepsilon\)</span></span>，并且<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\delta(t)\)</span><span class="heti-spacing"> </span></span>在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\([a, b]\)</span><span class="heti-spacing"> </span></span>上连续且<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(|\delta(t)| &lt; \varepsilon\)</span><span class="heti-spacing"> </span></span>时，对于</p>
<div class="arithmatex">\[
z'(t) = f(t, z) + \delta(t), a \le t \le b, z(a) = \alpha + \varepsilon_0
\]</div>
<p>（上述式子称为<strong>扰动问题</strong>(perturbed problem)<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，存在唯一解<span><span class="heti-spacing"> </span><span class="arithmatex">\(z(t)\)</span></span>，满足<span><span class="heti-spacing"> </span><span class="arithmatex">\(|z(t) - y(t)| &lt; k(\varepsilon) \cdot  \varepsilon\ (a \le t \le b)\)</span></span></p>
</li>
</ul>
<p><strong>定理</strong> ：</p>
<p>假设<span><span class="heti-spacing"> </span><span class="arithmatex">\(D = \{(t, y)\ |\ a \le t \le b, -\infty &lt; y &lt; \infty\}\)</span></span>，且<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f(t, y)\)</span><span class="heti-spacing"> </span></span>在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(D\)</span><span class="heti-spacing"> </span></span>上连续。若<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f\)</span><span class="heti-spacing"> </span></span>满足在变量<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(y \in D\)</span><span class="heti-spacing"> </span></span>上的<span class="heti-skip"><span class="heti-spacing"> </span>Lipschitz<span class="heti-spacing"> </span></span>条件，那么初值问题</p>
<div class="arithmatex">\[
y'(t) = f(t, y), a \le t \le b, y(a) = \alpha
\]</div>
<p>具有<strong>适定性</strong>(well-posed)。</p>
<h2 id="eulers-method">Euler's Method<a class="headerlink" href="#eulers-method" title="Permanent link">⚓︎</a></h2>
<p><img align="right" alt="" src="images/C5/9.png" width="30%"/></p>
<blockquote>
<p>继续往下阅读前，不妨回顾一下前面提出的<a href="#the-elementary-theory-of-initial-value-problems">目标</a>。</p>
</blockquote>
<p><span class="arithmatex">\(y'(t_0) \approx \dfrac{y(t_0 + h) - y(t_0)}{h}\ \Rightarrow\ y(t_1) \approx y(t_0) + hy'(t_0) = \alpha + hf(t_0, \alpha)\)</span></p>
<p>其中<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(h\)</span><span class="heti-spacing"> </span></span>为步长。</p>
<p><strong>欧拉法</strong><span>(Euler's method)<span class="heti-spacing"> </span></span>的核心是<u>用切线近似曲线</u>，它通过<strong>差分方程</strong><span>(difference equations)<span class="heti-spacing"> </span></span>来计算近似值：<span class="arithmatex">\(\begin{cases}w_0 = \alpha \\ w_{i+1} = w_i + hf(t_i, w_i)\end{cases}\ (i = 0, \dots, n - 1)\)</span></p>
<p><strong>定理</strong> ：</p>
<p>假设<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f\)</span><span class="heti-spacing"> </span></span>在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(D = \{(t, y)\ |\ a \le t \le b, -\infty &lt; y &lt; \infty \}\)</span><span class="heti-spacing"> </span></span>上是连续的，且满足<span class="heti-skip"><span class="heti-spacing"> </span>Lipschitz<span class="heti-spacing"> </span></span>条件（对应常数<span><span class="heti-spacing"> </span><span class="arithmatex">\(L\)</span></span><heti-adjacent class="heti-adjacent-half">）</heti-adjacent>；且存在常数<span><span class="heti-spacing"> </span><span class="arithmatex">\(M, \forall\ a \le t \le b\)</span></span>，满足<span><span class="heti-spacing"> </span><span class="arithmatex">\(|y''(t)| \le M\)</span></span>。</p>
<p>令<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(y(t)\)</span><span class="heti-spacing"> </span></span>为初值问题<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(y'(t) = f(t, y), a \le t \le b, y(a) = \alpha\)</span><span class="heti-spacing"> </span></span>的唯一解，且<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(w_0, w_1, \dots, w_n\)</span><span class="heti-spacing"> </span></span>为通过欧拉法（对于某些正整数<span><span class="heti-spacing"> </span><span class="arithmatex">\(n\)</span></span>）得到的近似值，那么：</p>
<div class="arithmatex">\[
|y_i - w_i| \le \dfrac{hM}{2L}[e^{L(t_i - a)} - 1] \quad (i = 0, 1, \dots, n)
\]</div>
<p><strong>注</strong> ：</p>
<p><span><span class="arithmatex">\(y''(t)\)</span><span class="heti-spacing"> </span></span>可在不知道<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(y(t)\)</span><span class="heti-spacing"> </span></span>的情况下被计算出来：</p>
<div class="arithmatex">\[
y''(t) = \dfrac{d}{dt}y'(t) = \dfrac{d}{dt}f(t, y(t)) = \dfrac{\partial}{\partial t}f(t, y(t)) + \dfrac{\partial}{\partial y}f(t, y(t)) \cdot f(t, y(t))
\]</div>
<hr/>
<p>代入舍入误差后，差分方程为：<span class="arithmatex">\(\begin{cases}w_0 = \alpha \textcolor{red}{+ \delta_0} \\ w_{i+1} = w_i + hf(t_i, w_i) \textcolor{red}{+ \delta_{i+1}}\end{cases}(i = 0, \dots, n - 1)\)</span></p>
<p><strong>定理</strong> ：</p>
<p>令<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(y(t)\)</span><span class="heti-spacing"> </span></span>为初值问题<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(y'(t) = f(t, y), a \le t \le b, y(a) = \alpha\)</span><span class="heti-spacing"> </span></span>的唯一解，且<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(w_0, w_1, \dots, w_n\)</span><span class="heti-spacing"> </span></span>为使用上述差分方程得到的近似值。若<span><span class="heti-spacing"> </span><span class="arithmatex">\(|\delta_i| &lt; \delta\ (i = 0, \dots, n)\)</span></span>，那么<span><span class="heti-spacing"> </span><span class="arithmatex">\(\forall\ i\)</span></span></p>
<div class="arithmatex">\[
|y_i - w_i| \le \dfrac{1}{L} \Big(\dfrac{hM}{2} + \dfrac{\delta}{h}\Big)[e^{L(t_i - a)} - 1] + |\delta_0|e^{L(t_i - a)}
\]</div>
<blockquote>
<p>其中<span><span class="heti-spacing"> </span><span class="arithmatex">\(h \ge \sqrt{2 \delta / M}\)</span></span></p>
</blockquote>
<h2 id="high-order-taylor-methods">High Order Taylor Methods<a class="headerlink" href="#high-order-taylor-methods" title="Permanent link">⚓︎</a></h2>
<p><strong>定义</strong> ：</p>
<p>差分法<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\begin{cases}w_0 = \alpha \\ w_{i+1} = w_i + h\varphi(t_i, w_i)\end{cases} (i = 0, \dots, n - 1)\)</span><span class="heti-spacing"> </span></span>的<strong>局部截断误差</strong><span>(local truncation error)<span class="heti-spacing"> </span></span>为：</p>
<div class="arithmatex">\[
\tau_{i+1}(h) = \dfrac{y_{i+1} - (y_i + h\varphi(t_i, y_i))}{h} = \dfrac{y_{i+1} - y_i}{h} - \varphi(t_i, y_i) \quad (i = 0, \dots, n - 1)
\]</div>
<p><strong>注</strong> ：局部截断误差就是<span><span class="heti-spacing"> </span><span class="arithmatex">\(\dfrac{y_{i+1} - w_{i+1}}{h}\)</span></span>（基于假设<span><span class="heti-spacing"> </span><span class="arithmatex">\(w_i = y_i\)</span></span><heti-adjacent class="heti-adjacent-half">）</heti-adjacent>。</p>
<p>欧拉法的局部截断误差：</p>
<div class="arithmatex">\[
\begin{align}
\tau_{i+1} &amp; = \dfrac{y_{i+1} - w_{i+1}}{h} = \dfrac{[y_i + hy'(t_i) + \frac{h^2}{2}y''(\xi_i)] - [y_i + hf(t_i, y_i)]}{h} \notag \\
&amp; = \dfrac{h}{2} y''(\xi_i) = O(h) \notag
\end{align}
\]</div>
<p><strong>注</strong> ：</p>
<div class="arithmatex">\[
\begin{align}
y_{i+1} &amp; = y(t_{i+1}) = y(t_i + h) = y(t_i) + y'(t_i)h + y''(\xi_i) \dfrac{h^2}{2} \notag \\
&amp; = y_i + hy'(t_i) + \frac{h^2}{2}y''(\xi_i) \notag
\end{align}
\]</div>
<blockquote>
<p>我一开始没看出这一点（<del>还是太菜了</del>）</p>
</blockquote>
<p>所以欧拉法本质上是<strong>泰勒展开式的<span class="heti-skip"><span class="heti-spacing"> </span>1<span class="heti-spacing"> </span></span>阶形式</strong>，换句话说我们可通过<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n = 1\)</span><span class="heti-spacing"> </span></span>时泰勒展开式得到的欧拉法近似表示<span><span class="heti-spacing"> </span><span class="arithmatex">\(y(t)\)</span></span>。</p>
<hr/>
<p>高阶泰勒法公式为：</p>
<div class="arithmatex">\[
y_{i+1} = y_i + hf(t_i, y_i) + \dfrac{h^2}{2} f'(t_i, y_i) + \dots + \dfrac{h^n}{n!}f^{(n-1)}(t_i, y_i) + \dfrac{h^{(n+1)}}{(n+1)!}f^{(n)}(\xi_i, y(\xi_i))
\]</div>
<p>对于阶数为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n\)</span><span class="heti-spacing"> </span></span>的泰勒法，其对应的差分方程为：</p>
<div class="arithmatex">\[
\begin{cases}w_0 = \alpha \\ w_{i+1} = w_i + hT^{(n)}(t_i, w_i)\end{cases} (i = 0, \dots, n - 1)
\]</div>
<p>其中<span><span class="heti-spacing"> </span><span class="arithmatex">\(T^{(n)}(t_i, w_i) = f(t_i, w_i) + \dfrac{h}{2}f'(t_i, w_i) + \dots + \dfrac{h^{n-1}}{n!} f^{(n-1)}(t_i, w_i)\)</span></span></p>
<p>若<span><span class="heti-spacing"> </span><span class="arithmatex">\(y \in C^{n+1}[a, b]\)</span></span>，那么局部截断误差是<span><span class="heti-spacing"> </span><span class="arithmatex">\(O(h^n)\)</span></span>。</p>
<p><strong>讨论</strong></p>
<p>题目：应用<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n = 10\)</span><span class="heti-spacing"> </span></span>的<span class="heti-skip"><span class="heti-spacing"> </span>3<span class="heti-spacing"> </span></span>阶泰勒法，解决初值问题<span><span class="heti-spacing"> </span><span class="arithmatex">\(y' = y - t^2 + 1, 0 \le t \le 2, y(0) = 0.5\)</span></span>。</p>
<blockquote>
<p>这里的<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n\)</span><span class="heti-spacing"> </span></span>是区间分段数，不是题目前面讲的阶数。</p>
</blockquote>
<p>解答：</p>
<p>找到<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f\)</span><span class="heti-spacing"> </span></span>的前两个导数：</p>
<ul>
<li><span class="arithmatex">\(f(t, y(t)) = y(t) - t^2 + 1\)</span></li>
<li><span class="arithmatex">\(f'(t, y(t)) = y'(t) - 2t = y(t) - t^2 + 1 - 2t\)</span></li>
<li><span class="arithmatex">\(f''(t, y(t)) = y'(t) - 2t - 2 = y(t) - t^2 - 2t - 1\)</span></li>
</ul>
<p>得到：</p>
<div class="arithmatex">\[
\begin{align}
T^{(3)}(t_i, w_i) &amp; = f(t_i, w_i) + \dfrac{h}{2} f'(t_i, w_i) + \dfrac{h^2}{6}f''(t_i, w_i) \notag \\
&amp; = \Big(1 + \dfrac{h}{2} + \dfrac{h^2}{6} \Big)(w_i - t_i^2 + 1) - \Big(1 + \dfrac{h}{3}\Big)ht_i - \dfrac{h^2}{3} \notag
\end{align}
\]</div>
<p>通过<span class="heti-skip"><span class="heti-spacing"> </span>3<span class="heti-spacing"> </span></span>阶泰勒法，得到差分方程：<span class="arithmatex">\(\begin{cases}w_0 = 0.5 \\ w_{i+1} = w_i + h\Big[\Big(1 + \dfrac{h}{2} + \dfrac{h^2}{6}\Big)(w_i - t_i^2 + 1) - \Big(1 + \dfrac{h}{3}ht_i - \dfrac{h^2}{3}\Big)\Big]\end{cases}\)</span></p>
<p>因为<span><span class="heti-spacing"> </span><span class="arithmatex">\(n = 10\)</span></span>，那么<span><span class="heti-spacing"> </span><span class="arithmatex">\(h = 0.2, t_i = 0.2i, w_{i+1} = 1.22133w_i - 0.00855i^2 - 0.00853i + 0.21867\)</span></span>。</p>
<h3 id="other-eulers-methods">Other Euler's Methods<a class="headerlink" href="#other-eulers-methods" title="Permanent link">⚓︎</a></h3>
<ul>
<li>
<p><strong>隐式欧拉法</strong>(implicit Euler's method)</p>
</li>
<li>
<p><span class="arithmatex">\(y'(t_0) \approx \dfrac{y(t_0) - y(t_0 - h)}{h}\ \Rightarrow\ \textcolor{red}{y(t_1)} \approx y(t_0) + hy'(t_1) + \alpha + hf(t_1, \textcolor{red}{y(t_1)})\)</span></p>
<p><img align="right" alt="" src="images/C5/11.png" width="30%"/></p>
</li>
<li>
<p>差分方程为<span><span class="heti-spacing"> </span><span class="arithmatex">\(\begin{cases}w_0 = \alpha \\ \textcolor{red}{w_{i+1}} = w_i + hf(t_{i+1}, \textcolor{red}{w_{i+1}})\end{cases} (i = 0, \dots, n - 1)\)</span></span></p>
<ul>
<li>之所以称为“隐式”，是因为差分方程左右两边都有<span><span class="heti-spacing"> </span><span class="arithmatex">\(w_{i+1}\)</span></span>，这意味着我们需要通过解方程得到<span><span class="heti-spacing"> </span><span class="arithmatex">\(w_{i+1}\)</span></span>，而无法像一般的欧拉法（相对地，我们将其称为<strong>显式欧拉法</strong>）那样直接计算得到<span><span class="heti-spacing"> </span><span class="arithmatex">\(w_{i+1}\)</span></span></li>
</ul>
</li>
<li>
<p>通常以迭代形式求解<span><span class="heti-spacing"> </span><span class="arithmatex">\(w_{i+1}\)</span></span>，其初始值通过显式法给出</p>
</li>
<li>
<p>隐式欧拉法的局部截断误差为<span><span class="heti-spacing"> </span><span class="arithmatex">\(\tau_{i+1} = \dfrac{y_{i+1} - w_{i+1}}{h} = -\dfrac{h}{2}y''(\xi_i) = O(h)\)</span></span></p>
</li>
<li>
<p>相比显式法，该方法更为<strong>稳定</strong>，因为计算<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(w_{i+1}\)</span><span class="heti-spacing"> </span></span>时用到了未来的信息<span><span class="heti-spacing"> </span><span class="arithmatex">\(t_{i+1}, w_{i+1}\)</span></span>，从而能更准确地预测未来趋势，对解的约束也就越强；而显式法只用了当前的信息<span><span class="heti-spacing"> </span><span class="arithmatex">\(t_{i}, w_{i}\)</span></span>，其预测结果自然会有更大的偏差</p>
</li>
<li>
<p><strong>梯形法</strong>(trapezoidal method)</p>
</li>
<li>
<p>差分方程为<span><span class="heti-spacing"> </span><span class="arithmatex">\(\begin{cases}w_0 = \alpha \\ \textcolor{red}{w_{i+1}} = w_i + \dfrac{h}{2}[f(t_i, w_i) + f(t_{i+1}, \textcolor{red}{w_{i+1}})]\end{cases} (i = 0, \dots, n - 1)\)</span></span></p>
</li>
<li>
<p>注：局部截断误差为<span><span class="heti-spacing"> </span><span class="arithmatex">\(O(h^2)\)</span></span>；但必须以迭代方式求解隐式方程</p>
</li>
<li>
<p><strong>两步法</strong>(double-step method)</p>
</li>
<li>
<p><span class="arithmatex">\(y'(t_0) = \dfrac{1}{2h}[y(t_0 + h) - y(t_0 - h)] - \dfrac{h^2}{6}y^{(3)}(\xi_1)\ \Rightarrow\ y(t_2) \approx y(t_0) + 2hf(t_1, y(t_1))\)</span></p>
</li>
<li>差分方程为<span><span class="heti-spacing"> </span><span class="arithmatex">\(\begin{cases}w_0 = \alpha \\ w_{i+1} = w_{i-1} + 2hf(t_i, w_i)\end{cases} (i = 1, \dots, n - 1)\)</span></span></li>
<li>该方法要求知道两个初始点，故得其名；而先前讨论的方法都是<strong>单步法</strong>(single-step methods)<ul>
<li>也就是说，两步法除了要知道<span><span class="heti-spacing"> </span><span class="arithmatex">\(w_0\)</span></span>（即原来的初值）外，还要知道<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(w_1\)</span><span class="heti-spacing"> </span></span>的值，因此需要先用单步法得到<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(w_1\)</span><span class="heti-spacing"> </span></span>后再用多步法</li>
</ul>
</li>
<li>若假设<span><span class="heti-spacing"> </span><span class="arithmatex">\(w_{i-1} = y_{i-1}, w_i = y_i\)</span></span>，那么局部截断误差为<span><span class="heti-spacing"> </span><span class="arithmatex">\(O(h^2)\)</span></span></li>
<li>由于两步法用到了更多点的信息，因此能得到更精确的近似结果</li>
</ul>
<p><strong>比较上述各法的优劣</strong> ：</p>
<table>
<thead>
<tr>
<th style="text-align: center;">方法</th>
<th style="text-align: center;">👍</th>
<th style="text-align: center;">👎</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">显式欧拉法</td>
<td style="text-align: center;">简单</td>
<td style="text-align: center;">低阶精度</td>
</tr>
<tr>
<td style="text-align: center;">隐式欧拉法</td>
<td style="text-align: center;">稳定</td>
<td style="text-align: center;">低阶精度、耗时（计算量大）</td>
</tr>
<tr>
<td style="text-align: center;">梯形法</td>
<td style="text-align: center;">更精确</td>
<td style="text-align: center;">耗时</td>
</tr>
<tr>
<td style="text-align: center;">两步法</td>
<td style="text-align: center;">更精确、显式</td>
<td style="text-align: center;">要求一个额外的初始点</td>
</tr>
</tbody>
</table>
<h2 id="runge-kutta-methods">Runge-Kutta Methods<a class="headerlink" href="#runge-kutta-methods" title="Permanent link">⚓︎</a></h2>
<p><strong><span>Runge-Kutta<span class="heti-spacing"> </span></span>法</strong>是一种具有高阶局部截断误差的单步方法，无需计算<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f\)</span><span class="heti-spacing"> </span></span>的导数。</p>
<p>思路：在单步法中，某个线段从<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\((t_i, w_i)\)</span><span class="heti-spacing"> </span></span>出发，以某个斜率延伸至下一个点<span><span class="heti-spacing"> </span><span class="arithmatex">\((t_{i+1}, w_{i+1})\)</span></span>。我们可以通过<strong>找到更好的斜率</strong>来改善结果。</p>
<p>观察以下修改过的欧拉法（即改进欧拉法，下面会介绍的<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>：</p>
<div class="arithmatex">\[
\begin{cases}
w_{i+1} = w_i + h\Big[ \dfrac{1}{2} K_1 + \dfrac{1}{2} K_2 \Big] \\
K_1 = f(t_i, w_i) \\
K_2 = f(t_i + h, w_i + hK_1)
\end{cases}
\]</div>
<ul>
<li>斜率是否必须是<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(K_1, K_2\)</span><span class="heti-spacing"> </span></span>的平均值？</li>
<li>步幅是否必须为<span><span class="heti-spacing"> </span><span class="arithmatex">\(h\)</span></span>？</li>
</ul>
<p>我们将其进一步泛化（从一般的平均值<span class="heti-skip"><span class="heti-spacing"> </span>-&gt;<span class="heti-spacing"> </span></span>加权平均值<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>：</p>
<div class="arithmatex">\[
\begin{cases}
w_{i+1} &amp; = w_i + h[\textcolor{red}{\lambda_1} K_1 + \textcolor{red}{\lambda_2} K_2 ] \\
K_1 &amp; = f(t_i, w_i) \\
K_2 &amp; = f(t_i + \textcolor{red}{p}h, w_i + \textcolor{red}{p}hK_1)
\end{cases}
\]</div>
<p>我们要找到<span><span class="heti-spacing"> </span><span class="arithmatex">\(\lambda_1, \lambda_2, p\)</span></span>，使得该方法的局部阶段误差的阶数为<span><span class="heti-spacing"> </span>2</span>。</p>
<ol>
<li>写出<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(K_2\)</span><span class="heti-spacing"> </span></span>在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\((t_i, y_i)\)</span><span class="heti-spacing"> </span></span>上的泰勒展开式：</li>
</ol>
<p>$$
   \begin{align}
   K_2 &amp; = f(t_1 + ph, y_i + phK_1) \notag \
   &amp; = f(t_i, y_i) + phf_t(t_i, y_i) + phK_1f_y(t_i, y_i) + O(h^2) \notag \
   &amp; = y'(t_i) + phy''(t_i) + O(h^2) \notag 
   \end{align}
   $$</p>
<p><strong>注</strong> ：</p>
<p>$$
   \begin{align}
   y''(t) &amp; = \dfrac{d}{dt}f(t, y) \notag \
   &amp; = f_t(t, y) + f_y(t, y) \dfrac{dy}{dt} \notag \
   &amp; = f_t(t, y) + f_y(t, y)f(t, y) \notag
   \end{align}
   $$</p>
<ol>
<li>将<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(K_2\)</span><span class="heti-spacing"> </span></span>代入到第一个式子中：</li>
</ol>
<p>$$
   \begin{align}
   w_{i+1} &amp; = y_i + h{\lambda_1 y'(t_i) + \lambda_2[y'(t_i) + phy''(t_i) + O(h^2)]} \notag \
   &amp; = y_i + (\lambda_1 + \lambda_2) hy'(t_i) + \lambda_2 ph^2 y''(t_i) + O(h^3) \notag
   \end{align}
   $$</p>
<ol>
<li>找到<span><span class="heti-spacing"> </span><span class="arithmatex">\(\lambda_1, \lambda_2, p\)</span></span>，使得<span><span class="heti-spacing"> </span><span class="arithmatex">\(\tau_{i+1} = (y_{i+1} - w_{i+1}) / h = O(h^2)\)</span></span></li>
</ol>
<div class="arithmatex">\[
\begin{cases}
w_{i+1} &amp; = y_i + (\lambda_1 + \lambda_2) hy'(t_i) + \lambda_2 ph^2 y''(t_i) + O(h^3) \\
y_{i+1} &amp; = y_i + hy'(t_i) + \dfrac{h^2}{2} y''(t_i) + O(h^3) 
\end{cases}
\]</div>
<p>比对上面两个方程，可以得到：<span class="arithmatex">\(\lambda_1 + \lambda_2 = 1, \lambda_2 p = \dfrac{1}{2}\)</span>（<span>3<span class="heti-spacing"> </span></span>个未知数，<span>2<span class="heti-spacing"> </span></span>个方程）</p>
<p>所以有无穷多个解。而由这两个方程得到的一系列方法被称为 <strong><span>2<span class="heti-spacing"> </span></span>阶龙格<span class="heti-skip"><span class="heti-spacing"> </span>-<span class="heti-spacing"> </span></span>库塔法</strong>(Runge-Kutta method of order 2)。</p>
<p><strong>注</strong> ：本节开始提到的改进欧拉法就是龙格<span class="heti-skip"><span class="heti-spacing"> </span>-<span class="heti-spacing"> </span></span>库塔法的一种特殊情况（<span class="arithmatex">\(p = 1, \lambda_1 = \lambda_2 = \dfrac{1}{2}\)</span>）</p>
<p><strong><span>2<span class="heti-spacing"> </span></span>阶龙格<span class="heti-skip"><span class="heti-spacing"> </span>-<span class="heti-spacing"> </span></span>库塔法的多种形式</strong> ：</p>
<ul>
<li>
<p><strong>中点法</strong>(midpoint method)：将从二阶泰勒法中的<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T^{(2)}(t, y)\)</span><span class="heti-spacing"> </span></span>用<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f(t + h / 2, y + (h / 2)f(t, y))\)</span><span class="heti-spacing"> </span></span>替换得到的差分方程法。</p>
<div class="arithmatex">\[
\begin{cases}
w_0 = \alpha \\
w_{i+1} = w_i + hf(t_i + \dfrac{h}{2}, w_i + \dfrac{h}{2}f(t_i, w_i))
\end{cases}
\quad (i = 0, \dots, N - 1)
\]</div>
</li>
<li>
<p><strong>改进欧拉法</strong>(modified Euler method)：</p>
<div class="arithmatex">\[
\begin{cases}
w_0 = \alpha \\
w_{i+1} = w_i + \dfrac{h}{2}[f(t_i, w_i) + f(t_{i+1}, w_i + hf(t_i, w_i))]
\end{cases}
\quad (i = 0, \dots, N - 1)
\]</div>
</li>
<li>
<p><strong><span>Heun<span class="heti-spacing"> </span></span>法</strong>：</p>
<div class="arithmatex">\[
\begin{cases}
w_0 = \alpha \\
w_{i+1} = w_i + \dfrac{h}{4}[f(t_i, w_i) + 3f(t_i + \dfrac{2}{3}h, w_i + \dfrac{2}{3}hf(t_i, w_i))]
\end{cases}
\quad (i = 0, \dots, N - 1)
\]</div>
</li>
</ul>
<hr/>
<p>计算更高精度：</p>
<div class="arithmatex">\[
\begin{cases}
w_{i+1} = y_i + h[\textcolor{red}{\lambda_1} K_1 + \textcolor{red}{\lambda_2} K_2 + \dots + \textcolor{red}{\lambda_m} K_m] \\
K_1 = f(t_i, w_i) \\
K_2 = f(t_i + \textcolor{red}{\alpha_2} h, w_i + \textcolor{red}{\beta_{21}} hK_1) \\
K_3 = f(t_i + \textcolor{red}{\alpha_3} h, w_i + \textcolor{red}{\beta_{31}} hK_1 + \textcolor{red}{\beta_{32}} hK_2) \\
\dots \\
K_m = f(t_i + \textcolor{red}{\alpha_m} h, w_i + \textcolor{red}{\beta_{m1}} hK_1 + \textcolor{red}{\beta_{m2}} hK_2 + \dots + \textcolor{red}{\beta_{m, m-1}} hK_{m-1}) \\
\end{cases}
\]</div>
<p>最流行的是经典 <strong><span>4<span class="heti-spacing"> </span></span>阶龙格<span class="heti-skip"><span class="heti-spacing"> </span>-<span class="heti-spacing"> </span></span>库塔法</strong>：</p>
<div class="arithmatex">\[
\begin{cases}
w_{i+1} = w_i + \dfrac{h}{6}(K_1 + 2K_2 + 2K_3 + K_4) \\
K_1 = f(t_i, w_i) \\
K_2 = f(t_i + \dfrac{h}{2}, w_i + \dfrac{h}{2} K_1) \\
K_3 = f(t_i + \dfrac{h}{2}, w_i + \dfrac{h}{2} K_2) \\
K_4 = f(t_i + h, w_i + hK_3)
\end{cases}
\]</div>
<p><strong>注</strong> ：</p>
<ul>
<li>
<p>在使用龙格<span class="heti-skip"><span class="heti-spacing"> </span>-<span class="heti-spacing"> </span></span>库塔法时，主要的计算量在于求解<span><span class="heti-spacing"> </span><span class="arithmatex">\(f\)</span></span>。<span>Butcher<span class="heti-spacing"> </span></span>已经帮我们建立好了每步求值次数与局部截断误差阶数之间的关系：</p>
<p></p><div style="text-align: center">
<img src="images/C5/12.png" width="70%/"/>
</div>
</li>
<li>
<p>因为龙格<span class="heti-skip"><span class="heti-spacing"> </span>-<span class="heti-spacing"> </span></span>库塔法是基于泰勒展开式的，所以<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(y\)</span><span class="heti-spacing"> </span></span>不得不足够平滑，以获取在高阶方法下的更高的精度。通常低阶方法相比高阶方法会采用更小的步幅。</p>
</li>
</ul>
<h2 id="multistep-methods">Multistep Methods<a class="headerlink" href="#multistep-methods" title="Permanent link">⚓︎</a></h2>
<p>思路：使用<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(y, y'\)</span><span class="heti-spacing"> </span></span>在多个网格点<span class="heti-skip"><span class="heti-spacing"> </span>(mesh points)<span class="heti-spacing"> </span></span>上的线性组合，以得到更好的近似值<span><span class="heti-spacing"> </span><span class="arithmatex">\(y(t_{i+1})\)</span></span>。</p>
<p><strong>多步法</strong><span>(multistep method)<span class="heti-spacing"> </span></span>的一般形式如下：</p>
<div class="arithmatex">\[
w_{i+1} = \textcolor{red}{a_{m-1}} w_i + \textcolor{red}{a_{m-2}} w_{i-1} + \dots + \textcolor{red}{a_0} w_{i+1-m} + h[\textcolor{red}{b_m} f_{i+1} + \textcolor{red}{b_{m-1}} f_i + \dots + \textcolor{red}{b_0} f_{i+1-m}]
\]</div>
<ul>
<li>在隐式法中，<span class="arithmatex">\(b_m \ne 0\)</span></li>
<li>在显式法中，<span class="arithmatex">\(b_m = 0\)</span></li>
</ul>
<p>具体方法：从积分中获取。在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\([t_i, t_{i+1}]\)</span><span class="heti-spacing"> </span></span>上对<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(y'(t) = f(t, y)\)</span><span class="heti-spacing"> </span></span>进行积分，得到：</p>
<div class="arithmatex">\[
y(t_{i+1}) - y(t_i) = \int_{t_i}^{t_{i+1}} f(t, y(t)) dt
\]</div>
<p>关键是<strong>近似计算积分</strong>。不同的近似方法会得到不同的差分方程。</p>
<h3 id="adams-bashforth-explicit-m-step-technique">Adams-Bashforth Explicit <span class="arithmatex">\(m\)</span>-step Technique<a class="headerlink" href="#adams-bashforth-explicit-m-step-technique" title="Permanent link">⚓︎</a></h3>
<p>使用<strong>牛顿后向差分</strong>公式，在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\((t_i, f_i), (t_{i-1}, f_{i-1}), \dots, (t_{i+1-m}, f_{i+1-m})\)</span><span class="heti-spacing"> </span></span>上对<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f\)</span><span class="heti-spacing"> </span></span>进行插值，并得到<span><span class="heti-spacing"> </span><span class="arithmatex">\(P_{m-1}(t)\)</span></span>。或者令<span><span class="heti-spacing"> </span><span class="arithmatex">\(t = t_i + sh, s \in [0, 1]\)</span></span>，我们有：</p>
<div class="arithmatex">\[
\int_{t_i}^{t_{i+1}} f(t, y(t)) dt = h \int_0^1 P_{m-1}(t_i + sh) ds + h \int_0^1 \underbrace{R_{m-1}}_{\substack{\text{local} \\ \text{truncation} \\ \text{error}}}(t_i + sh) ds
\]</div>
<p>最后得到显式公式：<span class="arithmatex">\(w_{i+1} = w_i + h\int_0^1 P_{m-1}(t_i + sh)ds\)</span></p>
<p><strong>定义</strong> ：</p>
<p>多步法的局部截断误差为：</p>
<div class="arithmatex">\[
\tau_{i+1}(h) = \dfrac{y_{i+1} - (a_{m-1}y_i + \dots + a_0 y_{i+1-m})}{h} - [b_m f_{i+1} + \dots + b_0 f_{i+1-m}]
\]</div>
<p>其中<span><span class="heti-spacing"> </span><span class="arithmatex">\(i = m-1, m, \dots, n - 1\)</span></span></p>
<p><strong>例子</strong></p>
<p>题目：请求出<span class="heti-skip"><span class="heti-spacing"> </span>Adams-Bashforth 2<span class="heti-spacing"> </span></span>步显式法。</p>
<p>解答：</p>
<p>使用牛顿后向差分公式，在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\((t_i, f_i), (t_{i-1}, f_{i-1})\)</span><span class="heti-spacing"> </span></span>上对<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f\)</span><span class="heti-spacing"> </span></span>插值：</p>
<div class="arithmatex">\[
P_1(t_i + sh) = f_i + s \nabla f_i = f_i + s(f_i - f_{i-1})
\]</div>
<p>得到<span><span class="heti-spacing"> </span><span class="arithmatex">\(w_{i+1} = w_i + h \int_0^1 [f_i + s(f_i - f_{i-1})] ds = w_i + \dfrac{h}{2} (3f_i - f_{i-1})\)</span></span></p>
<p>局部截断误差为：</p>
<div class="arithmatex">\[
\begin{align}
\tau_{i+1} &amp; = \dfrac{y(t_{i+1}) - w_{i+1}}{h} = \int_0^1 R_1 (t_i + sh) ds \notag \\
&amp; = \int_0^1 \dfrac{d^2 f(\xi_i, t(\xi_i))}{dt^2} \dfrac{1}{2!} sh(s+1)h ds = \dfrac{5}{12} h^2 y'''(\widetilde{\xi_i}) \notag
\end{align}
\]</div>
<p><strong>注</strong> ：</p>
<p>一般来说，对于<span><span class="heti-spacing"> </span><span class="arithmatex">\(\tau = A_mh^my^{(m+1)}(\xi_i)\)</span></span>，<span><span class="arithmatex">\(A_m\)</span><span class="heti-spacing"> </span></span>和系数<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f_i, f_{i-1}, f_{i+1-m}\)</span><span class="heti-spacing"> </span></span>能从表格中找到。</p>
<div style="text-align: center">
<img src="images/C5/1.png" width="80%/"/>
</div>
<p><span>Adams-Bashforth 4<span class="heti-spacing"> </span></span>步显式法：<span class="arithmatex">\(w_{i+1} = w_i + \dfrac{5}{24} (55f_i - 59 f_{i-1} + 37 f_{i-2} - 9f_{i-3})\)</span></p>
<h3 id="adams-moulton-implicit-m-step-technique">Adams-Moulton Implicit <span class="arithmatex">\(m\)</span>-step Technique<a class="headerlink" href="#adams-moulton-implicit-m-step-technique" title="Permanent link">⚓︎</a></h3>
<p>使用牛顿前向差分公式，在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\((t_{i+1}, \textcolor{red}{f_{i+1}}), (t_i, f_i), \dots, (t_{i+1-m}, f_{i+1-m})\)</span><span class="heti-spacing"> </span></span>上对<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f\)</span><span class="heti-spacing"> </span></span>进行插值，并得到<span><span class="heti-spacing"> </span><span class="arithmatex">\(P_m(t)\)</span></span>。类似的，我们可以得到一组<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\tau_{i+1} = B_m h^{m+1} y^{(m+2)} (\xi_i)\)</span><span class="heti-spacing"> </span></span>的隐式公式。</p>
<div style="text-align: center">
<img src="images/C5/2.png" width="80%/"/>
</div>
<p><span>Adams-Moulton 3<span class="heti-spacing"> </span></span>步隐式法：<span class="arithmatex">\(w_{i+1} = w_i + \dfrac{h}{24} (9 f_{i+1} + 19 f_i - 5 f_{i-1} + f_{i-2})\)</span></p>
<h3 id="adams-predictor-corrector-system">Adams Predictor-Corrector System<a class="headerlink" href="#adams-predictor-corrector-system" title="Permanent link">⚓︎</a></h3>
<ol>
<li>用 <strong><span>Runge-Kutta<span class="heti-spacing"> </span></span>法</strong>计算前<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(m\)</span><span class="heti-spacing"> </span></span>个初始值（为多步法（<span><span class="arithmatex">\(m\)</span><span class="heti-spacing"> </span></span>步）的启动做准备）</li>
<li>用 <strong><span>Adams-Bashforth<span class="heti-spacing"> </span></span>显式法</strong>进行预测（效率高）</li>
<li>用 <strong><span>Adams-Moulton<span class="heti-spacing"> </span></span>隐式法</strong>进行校正（提高精度，更稳定）</li>
</ol>
<p><strong>注</strong> ：</p>
<ul>
<li>对于上述步骤用到的三个公式，它们的局部截断误差必须有<strong>相同的阶数</strong>。</li>
<li>最受欢迎的系统是将<span class="heti-skip"><span class="heti-spacing"> </span>4<span class="heti-spacing"> </span></span>阶<span class="heti-skip"><span class="heti-spacing"> </span>Adams-Bashforth<span class="heti-spacing"> </span></span>法作为预测器，将<span class="heti-skip"><span class="heti-spacing"> </span>1<span class="heti-spacing"> </span></span>次迭代下的<span class="heti-skip"><span class="heti-spacing"> </span>Adams-Moulton<span class="heti-spacing"> </span></span>法作为校正器，而起始值通过<span class="heti-skip"><span class="heti-spacing"> </span>4<span class="heti-spacing"> </span></span>阶<span class="heti-skip"><span class="heti-spacing"> </span>Runge-Kutta<span class="heti-spacing"> </span></span>法获得。</li>
</ul>
<h3 id="derive-from-taylor-expansion">Derive from Taylor Expansion<a class="headerlink" href="#derive-from-taylor-expansion" title="Permanent link">⚓︎</a></h3>
<blockquote>
<p>回顾<a href="#multistep-methods">多步法的一般形式</a>。</p>
</blockquote>
<p>思路：扩展在关于<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(t_i\)</span><span class="heti-spacing"> </span></span>的泰勒级数里的<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(y_{i-1}, \dots, y_{i+1-m}\)</span><span class="heti-spacing"> </span></span>和<span><span class="heti-spacing"> </span><span class="arithmatex">\(f_{i+1}, f_{i-1}, \dots, f_{i+1-m}\)</span></span>，并让<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(h^k\)</span><span class="heti-spacing"> </span></span>的系数相等，以获得<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(a_0, \dots, a_{m-1}\)</span><span class="heti-spacing"> </span></span>和<span><span class="heti-spacing"> </span><span class="arithmatex">\(b_0, \dots, b_m\)</span></span>。</p>
<p><strong>例子</strong></p>
<p>例<span><span class="heti-spacing"> </span>1</span></p>
<p>题目：请求出形如以下形式的<span class="heti-skip"><span class="heti-spacing"> </span>4<span class="heti-spacing"> </span></span>阶公式：</p>
<div class="arithmatex">\[
w_{i+1} = \textcolor{red}{a_2}w_i + \textcolor{red}{a_1}w_{i-1} + \textcolor{red}{a_0}w_{i-2} + h[\textcolor{red}{b_3}f_i + \textcolor{red}{b_2}f_{i-1} + \textcolor{red}{b_1}f_{i-2} + \textcolor{red}{b_0}f_{i-3}]
\]</div>
<p>解答：</p>
<p>在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(t_i\)</span><span class="heti-spacing"> </span></span>处扩展<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(y_{i-1}, y_{i-2}, f_{i-1}, f_{i-2}, f_{i-3}\)</span><span class="heti-spacing"> </span></span>和<span><span class="heti-spacing"> </span><span class="arithmatex">\(y(t_{i+1})\)</span></span></p>
<p>假设<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(w_i = y_i\)</span><span class="heti-spacing"> </span></span>的情况下，<span class="arithmatex">\(\tau_{i+1} = \dfrac{y_{i+1} - w_{i+1}}{h} = O(h^4)\)</span></p>
<div class="arithmatex">\[
\begin{align}
y_{i-1} = &amp; y_i - hy_i' + \dfrac{1}{2} h^2 y_i'' - \dfrac{1}{6}h^3 y_i''' + \dfrac{1}{24}h^4 y_i^{(4)} + O(h^5) \notag \\
y_{i-2} = &amp; y_i - 2hy_i' + 2 h^2 y_i'' - \dfrac{4}{3}h^3 y_i''' + \dfrac{2}{3}h^4 y_i^{(4)} + O(h^5) \notag \\
f_{i-1} = &amp; y_i' - hy_i'' + \dfrac{1}{2}h^2 y_i''' - \dfrac{1}{6}h^3y_i^{(4)} + O(h^4) \notag \\
f_{i-2} = &amp; y_i' - 2hy_i'' + 2h^2 y_i''' - \dfrac{4}{3}h^3y_i^{(4)} + O(h^4) \notag \\
f_{i-3} = &amp; y_i' - 3hy_i'' + \dfrac{9}{2}h^2 y_i''' - \dfrac{9}{2}h^3y_i^{(4)} + O(h^4) \notag \\
\end{align}
\]</div>
<div class="arithmatex">\[
y(t_{i+1}) = y_i + hy_i' + \dfrac{1}{2}h^2y_i'' + \dfrac{1}{6}h^3 y_i''' + \dfrac{1}{24}h^4 y_i^{(4)} + O(h^5)
\]</div>
<p>有<span class="heti-skip"><span class="heti-spacing"> </span>5<span class="heti-spacing"> </span></span>个方程，<span>7<span class="heti-spacing"> </span></span>个未知量。</p>
<ul>
<li>令<span><span class="heti-spacing"> </span><span class="arithmatex">\(a_0 = a_1 = 0\)</span> -&gt;</span> <strong><span>Adams-Bashforth<span class="heti-spacing"> </span></span>显式法</strong></li>
<li>用<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f_{i+1}\)</span><span class="heti-spacing"> </span></span>替换<span><span class="heti-spacing"> </span><span class="arithmatex">\(f_{i-1}\)</span></span>，并令<span><span class="heti-spacing"> </span><span class="arithmatex">\(a_0 = a_1 = 0\)</span> -&gt;</span> <strong><span>Adams-Moulton<span class="heti-spacing"> </span></span>隐式法</strong></li>
<li>
<p>用<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(w_{i-3}\)</span><span class="heti-spacing"> </span></span>替换<span><span class="heti-spacing"> </span><span class="arithmatex">\(f_{i-3}\)</span></span>，我们能得到另一组阶数为<span class="heti-skip"><span class="heti-spacing"> </span>4<span class="heti-spacing"> </span></span>的方法，包括了显式 <strong><span>Milne<span class="heti-spacing"> </span></span>法</strong>：</p>
<div class="arithmatex">\[
w_{i+1} = w_{i-3} + \dfrac{4h}{3}(2f_i - f_{i-1} + 2f_{i-2})
\]</div>
<p>其截断误差为<span><span class="heti-spacing"> </span><span class="arithmatex">\(\dfrac{14}{45}h^4y^{(5)}(\xi_i), \xi_i \in (t_{i-3}, t_{i+1})\)</span></span></p>
</li>
<li>
<p>令<span><span class="heti-spacing"> </span><span class="arithmatex">\(a_0 = 0, a_1 = 1\)</span> -&gt;</span> <strong><span>Simpson<span class="heti-spacing"> </span></span>隐式法</strong></p>
<div class="arithmatex">\[
w_{i+1} = w_{i-1} + \dfrac{h}{3}(f_{i+1} + 4f_i + f_{i-1})
\]</div>
<p>其截断误差为<span><span class="heti-spacing"> </span><span class="arithmatex">\(-\dfrac{h^4}{90}y^{(5)}(\xi_i), \xi_i \in (t_{i-1}, t_{i+1})\)</span></span></p>
</li>
</ul>
<hr/>
<p>例<span><span class="heti-spacing"> </span>2</span></p>
<p>题目：</p>
<div style="text-align: center">
<img src="images/C5/13.png" width="80%/"/>
</div>
<p>解答：</p>
<blockquote>
<p>解析过程来自<span><span class="heti-spacing"> </span>Gemini 2.5 pro</span>，并且也通过了笔者的验证。</p>
</blockquote>
<p>为了找到使局部截断误差最小的系数，我们的策略是，假设近似解<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(w_i\)</span><span class="heti-spacing"> </span></span>等于真实解<span><span class="heti-spacing"> </span><span class="arithmatex">\(y(t_i)\)</span></span>，然后将公式中的每一项围绕点<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(t_i\)</span><span class="heti-spacing"> </span></span>进行泰勒展开。通过匹配展开后<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(h\)</span><span class="heti-spacing"> </span></span>的同次幂的系数，我们使这个公式对于尽可能高阶的多项式都是精确的，从而达到最小化截断误差的目的。</p>
<p>我们把公式中的<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(y_{i+1}\)</span>, <span class="arithmatex">\(y_{i-1}\)</span><span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(y'_{i+1}\)</span> (<span class="heti-spacing"> </span></span>即<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f_{i+1}\)</span>)<span class="heti-spacing"> </span></span>围绕<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(t_i\)</span><span class="heti-spacing"> </span></span>展开。设步长为<span><span class="heti-spacing"> </span><span class="arithmatex">\(h\)</span></span>。</p>
<ul>
<li><span class="arithmatex">\(y_{i+1} = y(t_i + h) = y_i + h y'_i + \frac{h^2}{2} y''_i + \frac{h^3}{6} y'''_i + O(h^4)\)</span></li>
<li><span class="arithmatex">\(y_{i-1} = y(t_i - h) = y_i - h y'_i + \frac{h^2}{2} y''_i - \frac{h^3}{6} y'''_i + O(h^4)\)</span></li>
<li><span class="arithmatex">\(y'_{i+1} = y'(t_i + h) = y'_i + h y''_i + \frac{h^2}{2} y'''_i + O(h^3)\)</span></li>
</ul>
<p>将上述展开式代入原公式中：</p>
<p><span class="arithmatex">\(y_i + h y'_i + \frac{h^2}{2} y''_i + ... = a_0 y_i + a_1(y_i - h y'_i + \frac{h^2}{2} y''_i - ...) + \beta h(y'_i + h y''_i + ...)\)</span></p>
<p>现在，我们按<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(y\)</span><span class="heti-spacing"> </span></span>在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(t_i\)</span><span class="heti-spacing"> </span></span>点的各阶导数（<span class="arithmatex">\(y_i, y'_i, y''_i\)</span>）来合并与整理等式右边的项：</p>
<p><span class="arithmatex">\(y_i + h y'_i + \frac{h^2}{2} y''_i + ... = (a_0+a_1)y_i + h(-a_1+\beta)y'_i + h^2(\frac{a_1}{2}+\beta)y''_i + ...\)</span></p>
<p>为了让等式两边尽可能相等，我们令等式两边<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(h\)</span><span class="heti-spacing"> </span></span>的低次幂项的系数相等。这会给我们一个关于<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(a_0, a_1, \beta\)</span><span class="heti-spacing"> </span></span>的线性方程组。</p>
<ul>
<li>
<p>匹配<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(y_i\)</span><span class="heti-spacing"> </span></span>的系数<span class="heti-skip"><span class="heti-spacing"> </span>(<span class="heti-spacing"> </span></span>即<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(h^0\)</span><span class="heti-spacing"> </span></span>项<span><span class="heti-spacing"> </span>)</span>：<span class="arithmatex">\(1 = a_0 + a_1\)</span>（方程<span><span class="heti-spacing"> </span>1</span>）</p>
</li>
<li>
<p>匹配<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(y'_i\)</span><span class="heti-spacing"> </span></span>的系数<span class="heti-skip"><span class="heti-spacing"> </span>(<span class="heti-spacing"> </span></span>即<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(h^1\)</span><span class="heti-spacing"> </span></span>项<span><span class="heti-spacing"> </span>)</span>：<span class="arithmatex">\(h(1 \cdot y'_i) = h(-a_1 + \beta)y'_i \implies 1 = -a_1 + \beta\)</span>（方程<span><span class="heti-spacing"> </span>2</span>）</p>
</li>
<li>
<p>匹配<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(y''_i\)</span><span class="heti-spacing"> </span></span>的系数<span class="heti-skip"><span class="heti-spacing"> </span>(<span class="heti-spacing"> </span></span>即<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(h^2\)</span><span class="heti-spacing"> </span></span>项<span><span class="heti-spacing"> </span>)</span>：<span class="arithmatex">\(h^2(\frac{1}{2} \cdot y''_i) = h^2(\frac{a_1}{2} + \beta)y''_i \implies \frac{1}{2} = \frac{a_1}{2} + \beta\)</span>（方程<span><span class="heti-spacing"> </span>3</span>）</p>
</li>
</ul>
<p>解上述三元一次方程，最终得到：</p>
<ul>
<li><span class="arithmatex">\(a_0 = \frac{4}{3}\)</span></li>
<li><span class="arithmatex">\(a_1 = -\frac{1}{3}\)</span></li>
<li><span class="arithmatex">\(\beta = \frac{2}{3}\)</span></li>
</ul>
<h2 id="higher-order-equations-and-systems-of-differential-equations">Higher-Order Equations and Systems of Differential Equations<a class="headerlink" href="#higher-order-equations-and-systems-of-differential-equations" title="Permanent link">⚓︎</a></h2>
<h3 id="m-th-order-system-of-1st-order-ivp">m-th Order System of 1st-Order IVP<a class="headerlink" href="#m-th-order-system-of-1st-order-ivp" title="Permanent link">⚓︎</a></h3>
<div class="arithmatex">\[
\begin{cases}
u_1'(t) = f_1(t, u_1(t), \dots, u_m(t)) \\
\dots \\
u_m'(t) = f_m(t, u_1(t), \dots, u_m(t))
\end{cases}
\]</div>
<p>初始条件为：<span class="arithmatex">\(u_1(a) = \alpha_1, u_2(a) = \alpha_2, \dots, u_m(a) = \alpha_m\)</span></p>
<p>令<span><span class="heti-spacing"> </span><span class="arithmatex">\(\boldsymbol{y} = \begin{bmatrix}u_1 \\ \vdots \\ u_m\end{bmatrix}, \boldsymbol{f} = \begin{bmatrix}f_1 \\ \vdots \\ f_m\end{bmatrix}, \boldsymbol{\alpha} = \begin{bmatrix}\alpha_1 \\ \vdots \\ \alpha_m\end{bmatrix}\)</span></span>，可以得到：<span class="arithmatex">\(\begin{cases}\boldsymbol{y}'(t) = \boldsymbol{f}(t, \boldsymbol{y}) \\ \boldsymbol{y}(a) = \boldsymbol{\alpha}\end{cases}\)</span></p>
<h3 id="higher-order-differential-equation">Higher-Order Differential Equation<a class="headerlink" href="#higher-order-differential-equation" title="Permanent link">⚓︎</a></h3>
<div class="arithmatex">\[
\begin{cases}
y^{(m)}(t) = f(t, y, y', \dots, y^{(m-1)}), a \le t \le b \\
y(a) = \alpha_1, y'(a) = \alpha_2, \dots, y^{(m-1)}(a) = \alpha_m
\end{cases}
\]</div>
<p>思路：将高阶的微分方程归约到一个<span class="heti-skip"><span class="heti-spacing"> </span>1<span class="heti-spacing"> </span></span>阶的微分方程组。</p>
<p>令<span><span class="heti-spacing"> </span><span class="arithmatex">\(u_1(t) = y(t), u_2(t) = y'(t), \dots, u_m(t) = y^{(m-1)}(t)\)</span></span>，得到：</p>
<div class="arithmatex">\[
\begin{cases}
u_1' = y' = u_2 \\
u_2' = y'' = u_3 \\
\vdots \\
u_{m-1}' = y^{(m-1)} = u_m \\
u_m' = y^{(m)} = f(x, u_1, \dots, u_m)
\end{cases}
\]</div>
<p>初始条件为<span><span class="heti-spacing"> </span><span class="arithmatex">\(u_1(a) = \alpha_1, u_2(a) = \alpha_2, \dots, u_m(a) = \alpha_m\)</span></span>。</p>
<p><strong>例子</strong></p>
<p>题目：</p>
<p>使用欧拉法求解以下<span><span class="heti-spacing"> </span>IVP</span>（<span class="arithmatex">\(h = 0.1\)</span>）</p>
<div class="arithmatex">\[
\begin{align}
&amp; y'' - 2y' + y = te^t - 1.5t + 1 \quad \text{for } 0 \le t \le 0.2 \notag \\
&amp; y(0) = 0, y'(0) = -0.5 \notag
\end{align}
\]</div>
<p>解答：</p>
<p>令<span><span class="heti-spacing"> </span><span class="arithmatex">\(u_1(t) = y(t), u_2(t) = y'(t)\)</span></span>，得到：</p>
<div class="arithmatex">\[
\begin{cases}
u_1'(t) = u_2(t) \\
u_2'(t) = te^t - 1.5t + 1 - u_1(t) + 2u_2(t)
\end{cases}
\]</div>
<p>初始条件为<span><span class="heti-spacing"> </span><span class="arithmatex">\(u_1(0) = 0, u_2(0) = -0.5\)</span></span></p>
<p>根据</p>
<div class="arithmatex">\[
\begin{align}
w_{i+1} &amp; = w_1 + h\Big[\dfrac{1}{2}K_1 + \dfrac{1}{2}K_2\Big] \notag \\
K_1 &amp; = f(t_i, w_i) \notag \\
K_2 &amp; = f(t_i + h, w_i + hK_1) \notag
\end{align}
\]</div>
<p>，计算：</p>
<div style="text-align: center">
<img src="images/C5/3.png" width="90%/"/>
</div>
<p>精确解为：<span class="arithmatex">\(y(t) = \dfrac{t^3 e^t}{6} - te^t + 2e^t - 1.5t - 2\)</span></p>
<h2 id="stability">Stability<a class="headerlink" href="#stability" title="Permanent link">⚓︎</a></h2>
<p><strong>定义</strong></p>
<ul>
<li>
<p>当局部截断误差为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\tau_i(h)\)</span><span class="heti-spacing"> </span></span>的单微分方程法满足下面的条件时，我们认为它和近似得到的微分方程是<strong>一致的</strong>(consistent)：</p>
<div class="arithmatex">\[
\lim\limits_{h \rightarrow 0} \max\limits_{1 \le i \le n} |\tau_i(h)| = 0
\]</div>
<p>对于多步法，还要求对于<span><span class="heti-spacing"> </span><span class="arithmatex">\(i = 1, 2, \dots, m-1\)</span></span>，有<span><span class="heti-spacing"> </span><span class="arithmatex">\(\lim\limits_{h \rightarrow 0}|w_i - y_i| = 0\)</span></span></p>
</li>
<li>
<p>当满足下面的条件时，我们认为一步微分方程法关于近似得到的微分方程<strong>收敛</strong>(convergent)：</p>
<div class="arithmatex">\[
\lim\limits_{h \rightarrow 0} \max\limits_{1 \le i \le n} |w_i - y_i| = 0
\]</div>
<p>多步法和上面的一样。</p>
</li>
<li>
<p>若在初始条件中的小改变或小扰动产生对应较小的近似值变化，那么称该方法是<strong>稳定的</strong>(stable)。</p>
</li>
</ul>
<p><strong>讨论</strong></p>
<p>题目：使用显式欧拉法、隐式欧拉法，以及改进欧拉法解决以下初值问题：<span class="arithmatex">\(y'(t) = -30y(t), y(0) = 1\)</span>，区间为<span><span class="heti-spacing"> </span><span class="arithmatex">\([0, 0.5], h = 0.1\)</span></span>。</p>
<p>解答：</p>
<div style="text-align: center">
<img src="images/C5/10.png" width="80%/"/>
</div>
<p><strong>定义</strong> ：</p>
<p>将某个方法用在一个简单的<strong>测试方程</strong><span>(test equation)<span class="heti-spacing"> </span></span>上：<span class="arithmatex">\(y' = \lambda y, y(0) = \alpha\)</span>，其中<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\lambda\)</span><span class="heti-spacing"> </span></span>是复数且<span><span class="heti-spacing"> </span><span class="arithmatex">\(\text{Re}(\lambda) &lt; 0\)</span></span>。假设舍入误差仅在初始点被引入。如果这个初始误差在特定步幅<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(h\)</span><span class="heti-spacing"> </span></span>上被缩小的话，那么该方法关于<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(H = \lambda h\)</span><span class="heti-spacing"> </span></span>是<strong>绝对稳定的</strong>(absolutely stable)。所有<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(H\)</span><span class="heti-spacing"> </span></span>构成的集合称为<strong>绝对稳定性区域</strong>(the region of absolute stability)。</p>
<p>当<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>的绝对稳定性区域大于<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(B\)</span><span class="heti-spacing"> </span></span>时，称法<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>比法<span><span class="heti-spacing"> </span><span class="arithmatex">\(B\)</span></span> <strong>更稳定</strong>。</p>
<p><strong>例子</strong></p>
<div style="text-align: center">
<img src="images/C5/4.png" width="70%/"/>
</div>
<p><strong>例子</strong></p>
<p>例<span><span class="heti-spacing"> </span>1</span>：</p>
<p>考虑显式欧拉法<span><span class="heti-spacing"> </span><span class="arithmatex">\(w_{i+1} = w_i + hf_i\)</span></span></p>
<p><img align="right" alt="" src="images/C5/5.png" width="30%"/></p>
<div class="arithmatex">\[
w_{i+1} = w_i + h\lambda w_i = \alpha(1 + H)^{i+1}
\]</div>
<blockquote>
<p>这里令<span><span class="heti-spacing"> </span><span class="arithmatex">\(H = h \lambda\)</span></span></p>
</blockquote>
<div class="arithmatex">\[
\alpha^* = \alpha + \varepsilon \Rightarrow w_{i+1}^* = \alpha^* (1 + H)^{i+1} \Rightarrow \varepsilon_{i+1} = w_{i+1}^* - w_{i+1} = (1 + H)^{i + 1}\varepsilon
\]</div>
<p>因此要想保证误差减小，必须满足<span><span class="heti-spacing"> </span><span class="arithmatex">\(|1 + H| &lt; 1\)</span></span>，对应的稳定性区域（绿色部分）如右图所示。</p>
<hr/>
<p>例<span><span class="heti-spacing"> </span>2</span>：</p>
<p>考虑隐式欧拉法<span><span class="heti-spacing"> </span><span class="arithmatex">\(w_{i+1} = w_i + hf_{i+1}\)</span></span></p>
<p><img align="right" alt="" src="images/C5/6.png" width="30%"/></p>
<div class="arithmatex">\[
w_{i+1} = \Big(\dfrac{1}{1 - H}\Big)w_i \Rightarrow \varepsilon_{i+1} = \Big(\dfrac{1}{1 - H}\Big)^{i+1} \varepsilon
\]</div>
<p>因此要想保证误差减小，必须满足<span><span class="heti-spacing"> </span><span class="arithmatex">\(|1 - H| &gt; 1\)</span></span>，对应的稳定性区域（绿色部分）如右图所示。</p>
<p><strong>注</strong> ：它是<strong>无条件稳定的</strong>(unconditionally stable)，因为稳定性区域包含了整个左半平面，即<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\text{Re}(\lambda) &lt; 0\)</span><span class="heti-spacing"> </span></span>的情况。</p>
<hr/>
<p>例<span><span class="heti-spacing"> </span>3</span></p>
<p>考虑<span class="heti-skip"><span class="heti-spacing"> </span>2<span class="heti-spacing"> </span></span>阶<span class="heti-skip"><span class="heti-spacing"> </span>Runge-Kutta<span class="heti-spacing"> </span></span>隐式法：</p>
<div class="arithmatex">\[
\begin{cases}
w_{i+1} = w_i + hK_1 \\
K_1 = f(t_i + \dfrac{h}{2}, w_i + \dfrac{h}{2}K_1)
\end{cases}
\]</div>
<p><img align="right" alt="" src="images/C5/7.png" width="20%"/></p>
<p>可以得到<span><span class="heti-spacing"> </span><span class="arithmatex">\(K_1 = \dfrac{\lambda w_i}{1 - \frac{\lambda h}{2}} \Rightarrow w_{i+1} = \Big(\dfrac{2+H}{2-H}\Big)w_i \Rightarrow \Big|\dfrac{2+H}{2-H}\Big| &lt; 1\)</span></span></p>
<p><strong>注</strong> ：它是<strong>无条件稳定的</strong>(unconditionally stable)。</p>
<p><strong>补充：<span>1-4<span class="heti-spacing"> </span></span>阶的<span class="heti-skip"><span class="heti-spacing"> </span>Runge-Kutta<span class="heti-spacing"> </span></span>显式法</strong></p>
<p><img align="right" alt="" src="images/C5/8.png" width="30%"/></p>
<div class="arithmatex">\[
\begin{cases}
w_{i+1} &amp; = w_i + \dfrac{h}{6} (K_1 + 2K_2 + 2K_3 + 2K_4) \\
K_1 &amp; = f(t_i, w_i) \\
K_2 &amp; = f(t_i + \dfrac{h}{2}, w_i + \dfrac{h}{2} K_1) \\
K_3 &amp; = f(t_i + \dfrac{h}{2}, w_i + \dfrac{h}{2} K_2) \\
K_4 &amp; = f(t_i + h, w_i + \dfrac{h}{2} K_3) \\
\end{cases}
\]</div>
<div class="arithmatex">\[
\begin{align}
K_1 &amp; = \lambda w_i \notag \\
K_2 &amp; = \lambda w_i (1 + \dfrac{H}{2}) \notag \\
K_3 &amp; = \lambda w_i (1 + \dfrac{H}{2} + \dfrac{H^2}{4}) \notag \\
K_4 &amp; = \lambda w_i (1 + H + \dfrac{H^2}{2} + \dfrac{H^3}{4}) \notag \\
w_{i+1} &amp; = w_i \Big(1 + H + \dfrac{H^2}{2} + \dfrac{H^3}{6} + \dfrac{H^4}{24}\Big) \notag
\end{align}
\]</div>
<hr/>
<p>例<span><span class="heti-spacing"> </span>4</span></p>
<p>题目：</p>
<p>考虑以下<span class="heti-skip"><span class="heti-spacing"> </span>IVP<span class="heti-spacing"> </span></span>组（刚性组<span><span class="heti-spacing"> </span>(stiff system)</span><heti-adjacent class="heti-adjacent-half">）</heti-adjacent>：</p>
<div class="arithmatex">\[
\begin{cases}
u_1' &amp; = 9u_1 + 24u_2 + 5 \cos t - \dfrac{1}{3} \sin t, \quad u_1(0) = \dfrac{4}{3} \\
u_2' &amp; = -24u_1 - 51u_2 - 9 \cos t + \dfrac{1}{3} \sin t, \quad u_1(0) = \dfrac{2}{3}
\end{cases}
\]</div>
<p>如何选择步幅<span><span class="heti-spacing"> </span><span class="arithmatex">\(h\)</span></span>，以保证应用欧拉显式法之后的稳定性？</p>
<p>解答：</p>
<p>唯一解为：<span class="arithmatex">\(\begin{cases}u_1(t) = 2e^{-3t} - e^{-39t} + \dfrac{1}{3} \cos t \\ u_2(t) = -e^{-3t} + 2e^{-39t} - \dfrac{1}{3} \cos t\end{cases}\)</span>。</p>
<p>矩阵<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\begin{bmatrix}9 &amp; 24 \\ -24 &amp; 51\end{bmatrix}\)</span><span class="heti-spacing"> </span></span>的特征值为<span><span class="heti-spacing"> </span><span class="arithmatex">\(\lambda_1 = -3, \lambda_2 = -39\)</span></span></p>
<p><span class="arithmatex">\(-2 &lt; \lambda h &lt; 0 \Rightarrow h &lt; \dfrac{2}{39} \approx 0.051\)</span></p>
<hr/>
<p>例<span><span class="heti-spacing"> </span>5</span></p>
<p>题目：</p>
<div style="text-align: center">
<img src="images/C5/14.png" width="80%/"/>
</div>
<div class="language-text highlight"><pre><span></span><code>
</code></pre></div>
<p>解答：</p>
<p>以下解答来自<span><span class="heti-spacing"> </span>Gemini 2.5 pro</span>，且经过笔者验证。</p>
<ol>
<li>
<p>二阶龙格<span class="heti-skip"><span class="heti-spacing"> </span>-<span class="heti-spacing"> </span></span>库塔隐式法</p>
<p>公式为<span><span class="heti-spacing"> </span><span class="arithmatex">\(w_{i+1}=w_{i}+hK_{1}\)</span></span>，其中<span><span class="heti-spacing"> </span><span class="arithmatex">\(K_{1}=f(t_{i}+\frac{h}{2},w_{i}+\frac{h}{2}K_{1})\)</span></span>。</p>
<p>将<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f(t,y) = \lambda y\)</span><span class="heti-spacing"> </span></span>代入<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(K_1\)</span><span class="heti-spacing"> </span></span>的方程：</p>
<p><span class="arithmatex">\(K_1 = \lambda(w_i + \frac{h}{2}K_1) \implies K_1(1-\frac{h\lambda}{2})=\lambda w_i \implies K_1 = \frac{\lambda w_i}{1-\frac{h\lambda}{2}}\)</span></p>
<p>将其代入主公式：</p>
<p><span class="arithmatex">\(w_{i+1} = w_i + h(\frac{\lambda w_i}{1-\frac{h\lambda}{2}}) = w_i(1+\frac{h\lambda}{1-\frac{h\lambda}{2}}) = w_i(\frac{1-\frac{h\lambda}{2}+h\lambda}{1-\frac{h\lambda}{2}}) = w_i(\frac{1+\frac{h\lambda}{2}}{1-\frac{h\lambda}{2}})\)</span></p>
<p>令<span><span class="heti-spacing"> </span><span class="arithmatex">\(z=h\lambda\)</span></span>，增长因子为<span><span class="heti-spacing"> </span><span class="arithmatex">\(Q(z) = \frac{1+z/2}{1-z/2}\)</span></span>。绝对稳定区域要求<span><span class="heti-spacing"> </span><span class="arithmatex">\(|Q(z)| \le 1\)</span></span>。</p>
<p><span class="arithmatex">\(|\frac{1+z/2}{1-z/2}| \le 1 \implies |1+z/2| \le |1-z/2|\)</span></p>
<p>设<span><span class="heti-spacing"> </span><span class="arithmatex">\(z = x+iy\)</span></span>，则<span><span class="heti-spacing"> </span><span class="arithmatex">\(|1+\frac{x}{2}+i\frac{y}{2}| \le |1-\frac{x}{2}-i\frac{y}{2}|\)</span></span>。</p>
<p>两边平方得到<span><span class="heti-spacing"> </span><span class="arithmatex">\((1+\frac{x}{2})^2+(\frac{y}{2})^2 \le (1-\frac{x}{2})^2+(-\frac{y}{2})^2\)</span></span>，化简得<span><span class="heti-spacing"> </span><span class="arithmatex">\(1+x \le 1-x \implies 2x \le 0 \implies x \le 0\)</span></span>。</p>
<p>这意味着<span><span class="heti-spacing"> </span><span class="arithmatex">\(Re(z) = Re(h\lambda) \le 0\)</span></span>。该方法的绝对稳定区域是<strong>整个复平面的左半平面</strong>。</p>
</li>
<li>
<p>亚当斯<span class="heti-skip"><span class="heti-spacing"> </span>-<span class="heti-spacing"> </span></span>莫尔顿一阶隐式法（即梯形法）</p>
<p>公式为<span><span class="heti-spacing"> </span><span class="arithmatex">\(w_{i+1}=w_{i}+\frac{h}{2}(f_{i+1}+f_{i})\)</span></span>。</p>
<p>将<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f_i = \lambda w_i\)</span><span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(f_{i+1} = \lambda w_{i+1}\)</span><span class="heti-spacing"> </span></span>代入：</p>
<p><span class="arithmatex">\(w_{i+1} = w_i + \frac{h}{2}(\lambda w_{i+1} + \lambda w_i)\)</span></p>
<p><span class="arithmatex">\(w_{i+1}(1-\frac{h\lambda}{2}) = w_i(1+\frac{h\lambda}{2})\)</span></p>
<p><span class="arithmatex">\(w_{i+1} = w_i(\frac{1+\frac{h\lambda}{2}}{1-\frac{h\lambda}{2}})\)</span></p>
<p>这得到了与第一种方法<strong>完全相同的增长因子</strong>。因此，它的绝对稳定区域同样是<strong>整个复平面的左半平面</strong>。</p>
</li>
</ol>
<p>综上，两种方法的绝对稳定区域是<strong>相同的</strong>。</p></div>
<aside class="md-source-file">
<span class="md-source-file__fact">
<span class="md-icon" title="最后更新">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M21 13.1c-.1 0-.3.1-.4.2l-1 1 2.1 2.1 1-1c.2-.2.2-.6 0-.8l-1.3-1.3c-.1-.1-.2-.2-.4-.2m-1.9 1.8-6.1 6V23h2.1l6.1-6.1zM12.5 7v5.2l4 2.4-1 1L11 13V7zM11 21.9c-5.1-.5-9-4.8-9-9.9C2 6.5 6.5 2 12 2c5.3 0 9.6 4.1 10 9.3-.3-.1-.6-.2-1-.2s-.7.1-1 .2C19.6 7.2 16.2 4 12 4c-4.4 0-8 3.6-8 8 0 4.1 3.1 7.5 7.1 7.9l-.1.2z"></path></svg>
</span>
<span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-datetime" title="2025年6月22日 19:26:01">2025年6月22日 19:26:01</span>
</span>
<span class="md-source-file__fact">
<span class="md-icon" title="创建日期">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M14.47 15.08 11 13V7h1.5v5.25l3.08 1.83c-.41.28-.79.62-1.11 1m-1.39 4.84c-.36.05-.71.08-1.08.08-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8c0 .37-.03.72-.08 1.08.69.1 1.33.32 1.92.64.1-.56.16-1.13.16-1.72 0-5.5-4.5-10-10-10S2 6.5 2 12s4.47 10 10 10c.59 0 1.16-.06 1.72-.16-.32-.59-.54-1.23-.64-1.92M18 15v3h-3v2h3v3h2v-3h3v-2h-3v-3z"></path></svg>
</span>
<span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-datetime" title="2025年6月22日 19:26:01">2025年6月22日 19:26:01</span>
</span>
</aside>
<p style="font-size: 30px; font-weight: 600">评论区</p>
<div>
    如果大家有什么问题或想法，欢迎在下方留言~
  </div>
<!-- Insert generated snippet here -->
<script async="" crossorigin="anonymous" data-category="Announcements" data-category-id="DIC_kwDOMAb9Zs4CfmpP" data-emit-metadata="0" data-input-position="bottom" data-lang="zh-CN" data-mapping="pathname" data-reactions-enabled="1" data-repo="noughtq/notebook" data-repo-id="R_kgDOMAb9Zg" data-strict="0" data-theme="preferred_color_scheme" src="https://giscus.app/client.js">
</script>
<!-- Synchronize Giscus theme with palette -->
<script>
    var giscus = document.querySelector("script[src*=giscus]")

    // Set palette on initial load
    var palette = __md_get("__palette")
    if (palette && typeof palette.color === "object") {
      var theme = palette.color.scheme === "slate"
        ? "transparent_dark"
        : "light"

      // Instruct Giscus to set theme
      giscus.setAttribute("data-theme", theme) 
    }

    // Register event handlers after documented loaded
    document.addEventListener("DOMContentLoaded", function() {
      var ref = document.querySelector("[data-md-component=palette]")
      ref.addEventListener("change", function() {
        var palette = __md_get("__palette")
        if (palette && typeof palette.color === "object") {
          var theme = palette.color.scheme === "slate"
            ? "dark"
            : "light"

          // Instruct Giscus to change theme
          var frame = document.querySelector(".giscus-frame")
          frame.contentWindow.postMessage(
            { giscus: { setConfig: { theme } } },
            "https://giscus.app"
          )
        }
      })
    })
  </script>
<!-- 标题计数器 -->
<!-- 主页个性化 -->
</article>
</div>
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
</div>
<button class="md-top md-icon" data-md-component="top" hidden="" type="button">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"></path></svg>
  回到页面顶部
</button>
</main>
<footer class="md-footer">
<div class="md-footer-meta md-typeset">
<div class="md-footer-meta__inner md-grid">
<div class="md-copyright" style="margin-left: 33.5%">
<div class="md-copyright__highlight" style="text-align: center">
        Copyright © 2024-2025 <a href="https://github.com/NoughtQ">NoughtQ</a>
</div>
    
    
      Powered by
      <a href="https://www.mkdocs.org/" rel="noopener" target="_blank">
        MkDocs
      </a>
      with theme
      <a href="https://squidfunk.github.io/mkdocs-material/" rel="noopener" target="_blank">
        Material
      </a>
      modified by
      <a href="https://github.com/NoughtQ" rel="noopener" target="_blank">
        NoughtQ
      </a>
<!-- <br> -->
<div style="text-align: center;">
<a href="https://icp.gov.moe/?keyword=20252357" target="_blank">萌ICP备20252357号</a>
</div>
</div>
<div class="md-social">
<a class="md-social__link" href="https://github.com/noughtq" rel="noopener" target="_blank" title="github.com">
<svg viewbox="0 0 496 512" xmlns="http://www.w3.org/2000/svg"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8M97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"></path></svg>
</a>
<a class="md-social__link" href="https://blog.noughtq.top" rel="noopener" target="_blank" title="blog.noughtq.top">
<svg viewbox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M192 32c0 17.7 14.3 32 32 32 123.7 0 224 100.3 224 224 0 17.7 14.3 32 32 32s32-14.3 32-32C512 128.9 383.1 0 224 0c-17.7 0-32 14.3-32 32m0 96c0 17.7 14.3 32 32 32 70.7 0 128 57.3 128 128 0 17.7 14.3 32 32 32s32-14.3 32-32c0-106-86-192-192-192-17.7 0-32 14.3-32 32m-96 16c0-26.5-21.5-48-48-48S0 117.5 0 144v224c0 79.5 64.5 144 144 144s144-64.5 144-144-64.5-144-144-144h-16v96h16c26.5 0 48 21.5 48 48s-21.5 48-48 48-48-21.5-48-48z"></path></svg>
</a>
<a class="md-social__link" href="mailto:noughtq666@gmail.com" rel="noopener" target="_blank" title="">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="m20 8-8 5-8-5V6l8 5 8-5m0-2H4c-1.11 0-2 .89-2 2v12a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2"></path></svg>
</a>
</div>
</div>
</div>
</footer>
</div>
<div class="md-dialog" data-md-component="dialog">
<div class="md-dialog__inner md-typeset"></div>
</div>
<script id="__config" type="application/json">{"base": "../..", "features": ["content.action.edit", "content.action.view", "content.code.copy", "content.code.annotate", "content.footnote.tooltips", "navigation.tabs", "navigation.top", "navigation.footer", "navigation.indexes", "navigation.tracking", "navigation.prune", "search.share"], "search": "../../assets/javascripts/workers/search.d50fe291.min.js", "tags": null, "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}, "version": null}</script>
<script src="../../assets/javascripts/bundle.13a4f30d.min.js"></script>
<script src="../../js/anchor.js"></script>
<script src="../../js/katex.js"></script>
<script src="../../js/toc.js"></script>
<script src="../../js/typed.js"></script>
<script src="../../js/custom.js"></script>
<script src="https://unpkg.com/katex@0/dist/katex.min.js"></script>
<script src="https://unpkg.com/katex@0/dist/contrib/auto-render.min.js"></script>
</body>
</html>