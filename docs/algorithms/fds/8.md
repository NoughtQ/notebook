---
counter: True
---

# Chap 8: The Disjoint Set ADT

??? abstract "æ ¸å¿ƒçŸ¥è¯†"

	+ ç­‰ä»·å…³ç³»ã€ç­‰ä»·ç±»
	+ æ ¸å¿ƒæ“ä½œ
		+ `Union`
			+ Union by Size
			+ Union by Height
		+ `Find`
			+ è·¯å¾„å‹ç¼©

## Equivalence Relations

å®šä¹‰ï¼š

+ é›†åˆ $S$ çš„**å…³ç³»(relation)**$R$ï¼Œå¯¹äºæ¯å¯¹å…ƒç´  $(a ,b), a, b \in S$ï¼Œå®ƒä»¬çš„å…³ç³» $a \ R\ b$ï¼Œå¦‚æœå…¶å€¼ä¸ºçœŸï¼Œé‚£ä¹ˆç§° $a$ ä¸ $b$ ç›¸å…³($a$ is related to $b$)
+ å¯¹äºé›†åˆ $S$ çš„ä¸€ç§å…³ç³» $\sim$ï¼Œå¦‚æœå®ƒæ»¡è¶³*è‡ªåæ€§(reflexive)*ã€*å¯¹ç§°æ€§(symmetric)*å’Œ*ä¼ é€’æ€§(transitive)*ï¼Œé‚£ä¹ˆç§°è¿™ç§å…³ç³»ä¸º**ç­‰ä»·å…³ç³»(equivalence relation)**
	+ è‡ªåæ€§ï¼š$\forall a \in S, a\ R\ a$
	+ å¯¹ç§°æ€§ï¼š$a\ R\ b \leftrightarrow b\ R\ a$
	+ ä¼ é€’æ€§ï¼š$(a\ R\ b) \wedge (b\ R\ c) \rightarrow a\ R\ c$

+ å¯¹äºå…ƒç´  $a \in S$ çš„**ç­‰ä»·ç±»(equivalence class)**ï¼Œæ˜¯åŒ…å«æ‰€æœ‰ä¸ $a$ *ç›¸å…³*çš„å…ƒç´ çš„ $S$ çš„å­é›†
>ç­‰ä»·ç±»ç›¸å½“äº $S$ å†…çš„**åˆ†åŒº(partition)**ï¼Œ$S$å†…çš„æ¯ä¸ªå…ƒç´ ä»…å‡ºç°åœ¨ä¸€ä¸ªç­‰ä»·ç±»ä¸­

>æ³¨ï¼šç­‰ä»·å…³ç³»çš„è¯¦ç»†çŸ¥è¯†å‚è§ç¦»æ•£æ•°å­¦[Chap 9](../../math/dm/9.md#equivalence-relations)

## The Dynamic Equivalence Problem

!!! question "é—®é¢˜"

	ç»™å®šç­‰ä»·å…³ç³» $\sim$ï¼Œå¯¹äºä»»ä½•çš„ $a, b$ï¼Œåˆ¤æ–­ $a \sim b$ æ˜¯å¦æˆç«‹

ğŸŒ°

<div style="text-align: center; margin-top: 15px;">
<img src="Images/C8/Quicker_20240410_154916.png" width="80%" style="margin: 0 auto;">
</div>

ç®—æ³•â€”â€”**å¹¶æŸ¥é›†(Union/Find, the disjoint set)**ï¼Œè¿™æ˜¯ä¸€ç§*åŠ¨æ€çš„(dynamic)*ï¼Œ*åœ¨çº¿(on-line)*ç®—æ³•
>**åŠ¨æ€**ï¼šåœ¨ç®—æ³•æ‰§è¡Œè¿‡ç¨‹ä¸­ï¼Œ`Union()` ä¼šéšæ—¶æ›´æ–°é›†åˆ

ä¼ªä»£ç æ¨¡ç‰ˆï¼š

``` c
Algorithm: (Union / Find)
{   
	// step 1: read the relations in
	initialize N disjoint sets;
	while (read in a~b)
	{
		if (!(Find(a) == Find(b)))
			Union the two sets;
	} // end-while
	// step 2: decide if a~b
	while (read in a and b)
		if (Find(a) == Find(b))
			output(true) ;
		else
			output(false);
}
```
å¹¶æŸ¥é›†çš„å±æ€§ï¼š

+ é›†åˆçš„**å…ƒç´ (elements)**ï¼š$1, 2, 3, \dots, N$
>åˆå§‹çŠ¶æ€ï¼šæœ‰$N$ä¸ªé›†åˆï¼Œæ¯ä¸ªé›†åˆä»…æœ‰1ä¸ªå…ƒç´ 

+ å¯¹äºä¸€ç»„é›†åˆ $S_1, S_2, \dots \dots$ï¼Œå¦‚æœæ»¡è¶³ $S_i \cap S_j = \emptyset(i \ne j)$ï¼Œç§°è¿™äº›é›†åˆä¸º**ä¸ç›¸äº¤(disjoint)**
>å¦‚ä½•åœ¨ç¨‹åºä¸­è¡¨ç¤ºè¿™ç§æ•°æ®ç»“æ„ï¼Ÿâ€”â€”**æ ‘**ï¼Œå¹¶æ³¨æ„â€œæŒ‡é’ˆâ€åº”<u>ä»å­©å­èŠ‚ç‚¹æŒ‡å‘çˆ¶èŠ‚ç‚¹</u>

+ **è¿ç®—(operations)**
	+ `Union(i, j)`ï¼š ç”¨ $S = S_i \cup S_j$ å–ä»£ $S_i$ å’Œ $S_j$
	+ `Find(i)`ï¼šæ‰¾åˆ°åŒ…å«å…ƒç´  $i$ çš„é›†åˆ $S_k$

## Basic Data Structure

``` c
// Declaration
#ifndef _DisjSet_H

typedef int DisjSet[NumSet + 1];
typedef int SetType;
typedef int ElementType;

void Initialize(DisjSet S);
void SetUnion(DisjSet S, SetType Root1, SetType Root2);
SetType Find(ElementType X, DisjSet S);

#endif // _DisjSet_H
```

### Union(i, j)

!!! note "æ€è·¯"

	ä»¤ $S_i$ ä¸º $S_j$ çš„å­æ ‘ï¼ˆåè¿‡æ¥ä¹Ÿè¡Œï¼‰ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬å°†å…¶ä¸­ä¸€æ£µæ ‘çš„æ ¹èŠ‚ç‚¹æŒ‡å‘å¦ä¸€æ£µæ ‘çš„æ ¹èŠ‚ç‚¹

<div style="text-align: center; margin-top: 15px;">
<img src="Images/C8/Quicker_20240410_164944.png" width="80%" style="margin: 0 auto;">
</div>

!!! note "å®ç°æ–¹æ³•"

	=== "æ–¹æ³•1â€”â€”æ•°ç»„+æŒ‡é’ˆ:-1:"

		<div style="text-align: center; margin-top: 15px;">
		<img src="Images/C8/Quicker_20240410_165101.png" width="80%" style="margin: 0 auto;">
		</div>

	=== "æ–¹æ³•2â€”â€”åˆ©ç”¨**æ•°ç»„çš„ç´¢å¼•**:+1:"

		$$
		S[i] = \begin{cases}\text{the element's parent} &,\ \text{if the element isn't a root} \\ 0 &,\ \text{if the element is a root}\end{cases}
		$$

		>æ³¨ï¼šç´¢å¼•ä» **1** å¼€å§‹

		???+ example "ä¾‹å­"

			=== "å˜åŒ–å‰"

				<div style="text-align: center; margin-top: 15px;">
				<img src="Images/C8/Quicker_20240410_165640.png" width="80%" style="margin: 0 auto;">
				</div>

			=== "å˜åŒ–å"

				<div style="text-align: center; margin-top: 15px;">
				<img src="Images/C8/Quicker_20240410_165703.png" width="80%" style="margin: 0 auto;">
				</div>
	
ä»£ç å®ç°ï¼š

``` c
void Initialize(DisjSet S)
{
	int i;

	for (i = NumSets; i > 0; i--)
		S[i] = 0;
}
```

``` c
void SetUnion(DisSet S, SetType Rt1, SetType Rt2)
{
	S[Rt2] = Rt1;
}
```
æ—¶é—´å¤æ‚åº¦ï¼š$O(1)$

### Find(i)

!!! note "å®ç°æ–¹æ³•"

	=== "æ–¹æ³•1:-1:"

		æ ‘çš„èŠ‚ç‚¹æœ‰ä¸€ä¸ª `parent` å­—æ®µï¼Œåˆ©ç”¨å®ƒå¾—åˆ°æ•´æ£µæ ‘çš„æ ¹èŠ‚ç‚¹ï¼ˆè¿˜æ˜¯ä¸æ¨èâŒï¼‰

		<div style="text-align: center; margin-top: 15px;">
		<img src="Images/C8/Quicker_20240412_152330.png" width="40%" style="margin: 0 auto;">
		</div>

	=== "æ–¹æ³•2:+1:"

		ä»£ç å®ç°ï¼š

		``` c
		SetType Find(ElementType X, DisSet S)
		{
			for (; S[X] > 0; X = S[X]);
			return X;
		}
		```

		ï¼ˆæœ€åæƒ…å†µï¼‰æ—¶é—´å¤æ‚åº¦ï¼š$O(N)$ï¼ˆä¸$X$çš„æ·±åº¦æœ‰å…³ï¼Œ$N$ä¸ºæ•´ä¸ªå¹¶æŸ¥é›†çš„èŠ‚ç‚¹ä¸ªæ•°ï¼‰

### Analysis

å› ä¸º `union()` å’Œ `find()` æ“ä½œå¾€å¾€æ˜¯æˆå¯¹å‡ºç°çš„ï¼Œå› æ­¤è¦åˆ†æè¯¥ç®—æ³•çš„å¤æ‚åº¦ï¼Œéœ€è¦è€ƒè™‘æ‰§è¡Œä¸€ç³»åˆ—çš„ `union()` + `find()` è¿ç®—

ä»£ç å®ç°å®Œæ•´çš„å¹¶æŸ¥é›†æ“ä½œï¼š

``` c
// ä½¿ç”¨ä¸Šè¿°ç®—æ³•å®ç°çš„å¹¶æŸ¥è¿ç®—
{
	Initialize S[i] = {i} for i = 1,..., 12;
	for (k = 1; k <= Size; k++) // å¯¹äºæ¯ä¸€å¯¹i~j
		if (Find(i) != Find(j))
			SetUnion(Find(i), Find(j)); 
}
```

:star:æ³¨ï¼šè®°å¾—åœ¨è°ƒç”¨ `Union()` å‡½æ•°å‰ï¼Œä¸€å®šè¦å…ˆè°ƒç”¨ `Find()` æ‰¾åˆ°å…ƒç´ æ‰€åœ¨é›†åˆï¼ˆæ ‘ï¼‰çš„æ ¹èŠ‚ç‚¹ï¼Œå› ä¸ºæˆ‘ä»¬è¦åˆå¹¶ 2 ä¸ªå®Œæ•´çš„å¹¶æŸ¥é›†ï¼Œè€Œä¸æ˜¯ 2 ä¸ªèŠ‚ç‚¹ã€‚

---
è€ƒè™‘æœ€åæƒ…å†µï¼š`union(2, 1), find(1); union(3, 2), find(2); ...... union(N, N - 1), find(1);`ï¼Œè¿™äº›æ“ä½œæœ€ç»ˆä½¿ä¸€æ£µæ ‘é€€åŒ–æˆä¸€ä¸ªé“¾è¡¨ï¼Œæ­¤æ—¶æ—¶é—´å¤æ‚åº¦ä¸º $\Theta(N^2)$

<div style="text-align: center; margin-top: 15px;">
<img src="Images/C8/Quicker_20240410_170917.png" width="40%" style="margin: 0 auto;">
</div>

## Smart Union Algorithms

### Union-by-Size

æ ¹æ®**è§„æ¨¡(size)**åˆå¹¶æ ‘ï¼šæ€»æ˜¯å°†è§„æ¨¡å°çš„æ ‘åˆå¹¶åˆ°è§„æ¨¡å¤§çš„æ ‘ä¸Šï¼Œä»¤ `S[Root] = -size`ï¼Œåˆå§‹åŒ–ä¸º -1

å¼•ç†ï¼šä»¤æ ‘ $T$ ä¸ºé€šè¿‡ union-by-size æ–¹æ³•æ„é€ å‡ºçš„ï¼Œä¸”æœ‰ $N$ ä¸ªèŠ‚ç‚¹ï¼Œåˆ™ï¼š

$$
\mathrm{height}(T) \le \lfloor \log_2N \rfloor + 1
$$

>è¯æ˜ï¼šåˆ©ç”¨æ•°å­¦å½’çº³æ³•

å› æ­¤ `Find()` çš„æ—¶é—´å¤æ‚åº¦å˜ä¸º $O(\log N)$

æ•´ä¸ªç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ï¼š$O(N + M \log N)$ï¼ˆè¿›è¡Œ $N$ æ¬¡åˆå¹¶æ“ä½œå’Œ $M$ æ¬¡æŸ¥æ‰¾æ“ä½œåï¼‰

ä»£ç å®ç°ï¼š

``` c
void SetUnion(DisjSet S, SetType Root1, SetType Root2)
{
    if (Root1 == Root2)         // å¦‚æœæ˜¯åŒä¸€æ£µæ ‘ï¼Œå•¥éƒ½ä¸ç”¨åš
        return;
    if (S[Root2] < S[Root1])    // å¦‚æœ Root2 å¯¹åº”æ ‘çš„è§„æ¨¡æ›´å¤§
    {
        S[Root2] += S[Root1];
        S[Root1] = Root2;
    }
    else                        // å¦‚æœ Root1 å¯¹åº”æ ‘çš„è§„æ¨¡æ›´å¤§
    {
        S[Root1] += S[Root2];
        S[Root2] = Root1;
    }
}
```

### Union-by-Height(rank)

æ ¹æ®**é«˜åº¦(height)**åˆå¹¶æ ‘ï¼šæ€»æ˜¯å°†çŸ®çš„é‚£æ£µæ ‘åˆå¹¶åˆ°é«˜çš„é‚£æ£µæ ‘ä¸Šï¼Œå› æ­¤æ¯æ¬¡ `Union()` åæ ‘çš„é«˜åº¦æœ€å¤šå¢åŠ 1ï¼ˆå½“2æ£µæ ‘é«˜åº¦ç›¸åŒæ—¶ï¼‰ã€‚ä»¤ `S[Root] = -height`ï¼Œåˆå§‹åŒ–ä¸º -1

ä»£ç å®ç°ï¼š
``` c
void SetUnion(DisjSet S, SetType Root1, SetType Root2)
{
	if (S[Root2] < S[Root1])
		S[Root1] = Root2;
	else
	{
		if (S[Root1] == S[Root2])
			S[Root1]--;
		S[Root2] = Root1;
	}
}
```



## Path Compression

ç»è¿‡ä¸Šè¿°æ”¹è¿›ï¼Œ`Union` ç®—æ³•çš„æ€§èƒ½å·²ç»ä¸èƒ½å†æå‡äº†ï¼Œå› æ­¤æˆ‘ä»¬è€ƒè™‘æ”¹è¿› `Find` ç®—æ³•ã€‚äºæ˜¯æˆ‘ä»¬ä¾¿ç”¨åˆ°äº†**è·¯å¾„å‹ç¼©(path compression)**çš„æ–¹æ³•â€”â€”å¯¹äºä»æ ¹èŠ‚ç‚¹åˆ° $X$ è·¯å¾„ä¸Šçš„æ¯ä¸ªèŠ‚ç‚¹ï¼Œå°†å®ƒçš„çˆ¶èŠ‚ç‚¹è®¾ä¸º**æ ¹èŠ‚ç‚¹**

ç¤ºæ„å›¾ï¼š

<div style="text-align: center; margin-top: 15px;">
<img src="Images/C8/Quicker_20240421_170311.png" width="40%" style="margin: 0 auto;">
</div>

??? code "ä»£ç å®ç°"

	=== "é€’å½’ç‰ˆ"

		``` c
		// algorithm1--recursion
		SetType Find(ElementType X, DisSet S)
		{
			if (S[X] <= 0)
				return X;
			else
				// è®© X çš„çˆ¶èŠ‚ç‚¹ä¸º X åŸæ¥çˆ¶èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹ï¼Œè¿™æ ·çš„æœ€ç»ˆæ•ˆæœæ˜¯ï¼š
				// ä»æ ¹èŠ‚ç‚¹åˆ° X çš„è·¯å¾„ä¸Šï¼Œé™¤æ ¹èŠ‚ç‚¹å¤–çš„æ‰€æœ‰èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹å‡ä¸ºæ ¹èŠ‚ç‚¹ï¼Œå®ç°è·¯å¾„å‹ç¼©
				return S[X] = Find(S[X], S); 
		}
		```

	=== "è¿­ä»£ç‰ˆ"

		``` c
		// algorithm2--iteration
		SetType Find(ElementType X, DisSet S)
		{
			ElementType root, trail, lead;  // trail è¡¨ç¤ºå½“å‰å¤„ç†çš„èŠ‚ç‚¹ï¼Œlead è¡¨ç¤ºä¸‹ä¸€ä¸ªè¦å¤„ç†çš„èŠ‚ç‚¹
			for (root = X; S[root] > 0; root = S[root]); // find the root
			for (trail = X; trail != root; trail = lead) 
			// å°†è·¯å¾„ä¸Šçš„æ‰€æœ‰èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹éƒ½è®¾ä¸ºæ ¹èŠ‚ç‚¹
			{
				lead = S[trail];
				S[trail] = root;
			} // collapsing
			return root
		}
		```

+ è™½ç„¶è¿™ç§ç®—æ³•ç›¸è¾ƒäºä¸Šä¸€ç§ï¼ŒæŸ¥æ‰¾å•ä¸ªå…ƒç´ çš„é€Ÿåº¦å˜æ…¢ï¼ˆå› ä¸ºå¤šäº†ä¸€æ¬¡èµ‹å€¼ï¼‰ï¼›ä½†æ˜¯å¯¹äºæŸ¥æ‰¾æ•´ä¸ªåºåˆ—çš„å…ƒç´ ï¼Œè¿™ä¸ªç®—æ³•çš„é€Ÿåº¦æ›´å¿«ï¼ˆå› ä¸ºå¤šå‡ºæ¥çš„èµ‹å€¼**å‹ç¼©**äº†æ•´æ£µæ ‘ï¼Œå¯¹äºé¢‘ç¹çš„åˆå¹¶æ“ä½œæ˜¾ç„¶æ˜¯æœ‰åˆ©çš„ï¼‰
+ è¯¥æ–¹æ³•ä¸ union-by-height çš„æ–¹æ³•ä¸å…¼å®¹ï¼Œå› ä¸ºæ ‘çš„é«˜åº¦å‘ç”Ÿæ”¹å˜ã€‚æ‰€ä»¥æ¨èä½¿ç”¨ **union-by-size**

## Worst Case for Union-by-Rank and Path Compression

>å¹¶æŸ¥é›†çš„å®ç°è¾ƒä¸ºç®€å•ï¼Œä½†è¦åˆ†æå®ƒçš„æ—¶é—´å¤æ‚åº¦ç›¸å½“å›°éš¾ã€‚ä¸‹é¢çš„å†…å®¹ä»…ä¾›å‚è€ƒï¼Œè€ƒè¯•ä¸åšè¦æ±‚ã€‚

**å¼•ç†**ï¼šä»¤ $T(M, N)$ ä¸ºå¤„ç†æ··åˆè¿ç®— $M \ge N$ æŸ¥æ‰¾è¿ç®—å’Œ $N - 1$ æ¬¡åˆå¹¶è¿ç®—çš„æ‰€éœ€æœ€å¤§æ—¶é—´ï¼Œé‚£ä¹ˆå¯¹äºæ­£å¸¸æ•° $k_1, k_2$ï¼š
$$
k_1M \alpha(M, N) \le T(M, N) \le k_2M \alpha(M, N)
$$
å³å¹¶æŸ¥é›†æœ€åæƒ…å†µçš„æ—¶é—´å¤æ‚åº¦ä¸ºï¼š$\Theta(M\alpha (M, N))$

**é˜¿å…‹æ›¼å‡½æ•°(Ackermann's Function)**ï¼š$\alpha (M, N)$ 

$$
A(i, j) = 
\begin{cases}
2^j & i = 1 \text{ and } j \ge 1 \\
A(i - 1, 2) & i \ge 2 \text{ and } j = 1 \\
A(i - 1, A(i, j - 1)) & i \ge 2 \text{ and } j \ge 2
\end{cases}
$$


>æ³¨ï¼šå³ä½¿$i, j$æ•°å­—å¾ˆå°ï¼Œ$A(i, j)$ç»“æœå¯èƒ½ä¹Ÿéå¸¸å¤§ï¼Œæ¯”å¦‚$A(2, 4) = 2^{65536}$

$\alpha (M, N) = \min\{ i\ge 1 | A(i, \lfloor M / N \rfloor )> \log N\} \le O(\log^* N) \le 4$

å…¶ä¸­ $\log^*N$ æ˜¯é˜¿å…‹æ›¼å‡½æ•°çš„*åå‡½æ•°*ï¼Œä»£è¡¨ç”¨äº $N$ çš„å¯¹æ•°çš„æ¬¡æ•°ï¼Œä½¿å…¶æœ€ç»ˆç»“æœ $\le 1$ã€‚æ¯”å¦‚ä¸Šä¾‹ä¸­$\log^* 2^{65536} = 5$ï¼Œå› ä¸º $\log\log\log\log\log(2^{65536}) = 1$

>å‚è€ƒèµ„æ–™ï¼š[é˜¿å…‹æ›¼å‡½æ•°çš„è¯¦ç»†ä»‹ç»](http://mathworld.wolfram.com/AckermannFunction.html)


## An Application

åº”ç”¨ï¼šè®¡ç®—æœºç½‘ç»œä¸­çš„æ–‡ä»¶ä¼ è¾“ï¼ˆå…·ä½“å†…å®¹è§è¯¾æœ¬ $P_{279}$ï¼Œä¹Ÿå¯ä»¥çœ‹çœ‹ä¸‹é¢çš„ç¼–ç¨‹é¢˜ï¼‰

åç»­ç« èŠ‚ä¸­ä¼šæœ‰æ›´å¥½çš„åº”ç”¨