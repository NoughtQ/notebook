---
counter: True
---

# Chap 9: Graph Algorithm

??? abstract "æ ¸å¿ƒçŸ¥è¯†"

	+ å›¾çš„å®šä¹‰ã€æ€§è´¨ã€è¡¨ç¤ºæ³•
	+ æ‹“æ‰‘æ’åºï¼ˆAOVç½‘ï¼‰
	+ æœ€çŸ­è·¯é—®é¢˜
		+ æ— æƒ
		+ å¸¦æ­£è¾¹æƒï¼šDijkstra ç®—æ³•
		+ æœ‰è´Ÿè¾¹æƒ
		+ AOEç½‘
	+ ç½‘ç»œæµ
		+ è§£é¢˜ï¼šæµé‡å›¾ã€æ®‹é‡å›¾
	+ æœ€å°ç”Ÿæˆæ ‘(MST)
		+ Primç®—æ³•
		+ Kruskalç®—æ³•
	+ æ·±åº¦ä¼˜å…ˆæœç´¢(DFS)
		+ åŸºæœ¬ç®—æ³•
		+ å…³èŠ‚ç‚¹ï¼ˆå‰²ç‚¹ï¼‰ã€åŒè¿é€šåˆ†é‡
		+ æ¬§æ‹‰è·¯ã€æ¬§æ‹‰ç¯

>è¯¦ç»†çš„å›¾è®ºçŸ¥è¯†è§ç¦»æ•£æ•°å­¦[åŒåç« èŠ‚](../../math/dm/10.md)

## Definitions

+ **G(V, E)**ï¼š$G$ è¡¨ç¤º**å›¾(graph)**ï¼Œ$V = V(G)$ è¡¨ç¤ºå…³äº**é¡¶ç‚¹(vertices)**çš„æœ‰é™éç©ºé›†åˆï¼Œ$E = E(G)$ è¡¨ç¤ºå…³äº**è¾¹(edges/arcs)**çš„æœ‰é™é›†åˆ
+ **æ— å‘å›¾(undirected graph)**ï¼š$(v_i, v_j) = (v_j, v_i)$ è¡¨ç¤ºç›¸åŒçš„è¾¹
+ **æœ‰å‘å›¾(directed graph, digraph)**ï¼š$<v_i, v_j> \ne <v_j, v_i>$

???+ example "$<v_i, v_j>$"

	<div style="text-align: center; margin-top: 15px;">
	<img src="Images/C9/Quicker_20240417_200539.png" width="20%" style="margin: 0 auto;">
	</div>

???+ warning "é™åˆ¶"

	+ **è‡ªç¯(self loop)**æ˜¯éæ³•çš„

		<div style="text-align: center; margin-top: 15px;">
		<img src="Images/C9/Quicker_20240417_200725.png" width="20%" style="margin: 0 auto;">
		</div>

	+ ä¸è€ƒè™‘**å¤šé‡å›¾(multigraph)**ï¼ˆä¸¤ä¸ªèŠ‚ç‚¹é—´æœ‰å¤šæ¡è¾¹ï¼‰çš„æƒ…å†µ

		<div style="text-align: center; margin-top: 15px;">
		<img src="Images/C9/Quicker_20240417_200917.png" width="20%" style="margin: 0 auto;">
		</div>

+ **å®Œå…¨å›¾(complete graph)**ï¼šå›¾ä¸Šä»»æ„ä¸¤ç‚¹é—´éƒ½æœ‰ä¸€æ¡è¾¹

	+ æ— å‘å›¾ï¼š$V = n \quad E = C^2_n = \frac{n(n - 1)}{2}$

		<div style="text-align: center; margin-top: 15px;">
		<img src="Images/C9/Quicker_20240417_201101.png" width="20%" style="margin: 0 auto;">
		</div>

	+ æœ‰å‘å›¾ï¼š$V = n \quad E = P^2_n = n(n - 1)$

		<div style="text-align: center; margin-top: 15px;">
		<img src="Images/C9/Quicker_20240417_201159.png" width="20%" style="margin: 0 auto;">
		</div>	
		
+ **é‚»æ¥(adjacent)**

	+ æ— å‘å›¾ï¼šå¦‚æœ$(v_i, v_j)$å­˜åœ¨ï¼Œåˆ™ç§°$v_i, v_j$æ˜¯*é‚»æ¥çš„*

		<div style="text-align: center; margin-top: 15px;">
		<img src="Images/C9/Quicker_20240417_201534.png" width="20%" style="margin: 0 auto;">
		</div>	

	+ æœ‰å‘å›¾ï¼šå¦‚æœ$<v_i, v_j>$å­˜åœ¨ï¼Œåˆ™ç§°$v_i$ to $v_j$æ˜¯*é‚»æ¥çš„*ï¼Œæˆ–è€…è¯´$v_j$ from $v_i$æ˜¯*é‚»æ¥çš„*

		<div style="text-align: center; margin-top: 15px;">
		<img src="Images/C9/Quicker_20240417_201543.png" width="20%" style="margin: 0 auto;">
		</div>

+ **å­å›¾(subgraph)** $G' \subset G$ï¼Œ$V(G') \subseteq V(G)$ ä¸” $E(G') \subseteq E(G)$
+ ä»$v_p$åˆ°$v_q$çš„**è·¯å¾„(path)**($\subset G$)ï¼š$\{v_p, v_{i1}, v_{i2}, \dots, v_{in}, v_q\}$ï¼Œæ»¡è¶³ $(v_p, v_{i1}), (v_{i1}, v_{i2}), \dots, (v_{in}, v_q)$ æˆ–è€… $<v_p, v_{i1}>, <v_{i1}, v_{i2}>, \dots, <v_{in}, v_q> \subset E(G)$
+ è·¯å¾„çš„**é•¿åº¦(length)**ï¼šè·¯å¾„ä¸Šè¾¹çš„æ¡æ•°
+ **ç®€å•è·¯å¾„(simple path)**ï¼šå¯¹äºä¸Šè¿°è·¯å¾„ï¼Œ$v_{i1}, v_{i2}, \dots, v_{in}$ æ˜¯ä¸åŒçš„(ä¸ä¼šå¤šæ¬¡ç»è¿‡åŒä¸€é¡¶ç‚¹)
+ **ç¯(cycle)**ï¼šå¯¹äºä¸€æ¡ç®€å•è·¯å¾„ï¼Œèµ·ç‚¹ä¸ç»ˆç‚¹ç›¸åŒï¼Œå³ $v_p = v_q$
+ **è¿é€š(connected)**
	+ æ— å‘å›¾ï¼š
		+ å¯¹äºä¸¤ä¸ªé¡¶ç‚¹ $v_i, v_j$ è€Œè¨€ï¼Œå¦‚æœå®ƒä»¬ä¹‹é—´å­˜åœ¨ä¸€æ¡è·¯å¾„ï¼Œåˆ™ç§°å®ƒä»¬æ˜¯*è¿é€šçš„*
		+ å¯¹äºæ•´å¼ æ— å‘å›¾ $G$ è€Œè¨€ï¼Œå¦‚æœå›¾å†…ä»»æ„ä¸¤ç‚¹ä¹‹é—´ç›¸äº’è¿é€šï¼Œåˆ™ç§°æ•´å¼ å›¾æ˜¯*è¿é€šçš„*
		>å¯¹äº $n$ ä¸ªé¡¶ç‚¹çš„æ— å‘å›¾ï¼Œæœ€å°‘éœ€è¦ $n - 1$ æ¡è¾¹æ¥å®ç°æ•´å¼ å›¾çš„è¿é€š
		+ æ— å‘å›¾ $G$ çš„**ï¼ˆè¿é€šï¼‰åˆ†é‡(component)**ï¼šæå¤§è¿é€šå­å›¾ï¼ˆä¸€å¼ å›¾ä¸­å¯èƒ½æœ‰å¤šä¸ªè¿é€šåˆ†é‡ï¼‰
		+ **æ ‘**æ˜¯è¿é€šä¸”æ— ç¯(acyclic)çš„å›¾

	+ æœ‰å‘å›¾ï¼š
		+ **æœ‰å‘æ— ç¯å›¾(directed acyclic graph, DAG)**
		+ **å¼ºè¿é€š(strongly connected)**æœ‰å‘å›¾ $G$ï¼šå¯¹äº $V(G)$ ä¸­çš„æ¯å¯¹é¡¶ç‚¹ $v_i, v_j$ï¼Œå­˜åœ¨ä» $v_i$ åˆ° $v_j$ **ä»¥åŠ**ä» $v_j$ åˆ° $v_i$ çš„æœ‰å‘è·¯å¾„
		+ **å¼±è¿é€š(weakly connected)**æœ‰å‘å›¾ï¼šåœ¨ä¸è€ƒè™‘æ–¹å‘çš„æƒ…å†µä¸‹ï¼ˆå³æ— å‘å›¾ï¼‰ï¼Œæ•´å¼ å›¾æ˜¯è¿é€šçš„ï¼ˆå³å¯¹äº $V(G)$ ä¸­çš„æ¯å¯¹é¡¶ç‚¹ $v_i, v_j$ï¼Œå­˜åœ¨ä» $v_i$ åˆ° $v_j$** æˆ– **ä» $v_j$ åˆ° $v_i$ çš„æœ‰å‘è·¯å¾„ï¼‰
		>å¯¹äº $n$ ä¸ªé¡¶ç‚¹çš„*å¼±è¿é€šæœ‰å‘å›¾*ï¼Œæœ€å°‘éœ€è¦ $n - 1$ æ¡è¾¹æ¥å®ç°æ•´å¼ å›¾çš„è¿é€š

		+ **å¼ºè¿é€šåˆ†é‡(strongly connected component)**ï¼šæå¤§å¼ºè¿é€šå­å›¾
		+ **å¼±è¿é€šåˆ†é‡(weakly connected component)**ï¼šæå¤§å¼±è¿é€šå­å›¾

+ **åº¦(degree)**ï¼š$\mathrm{degree}(v)$ï¼Œä¸é¡¶ç‚¹vç›¸è¿çš„è¾¹æ•°

	å¯¹äºä¸€ä¸ªæœ‰å‘å›¾ $G$ è€Œè¨€ï¼Œåº¦åˆ†ä¸º**å…¥åº¦(in-degree)**å’Œ**å‡ºåº¦(out-degree)**ï¼Œä¾‹å¦‚ï¼š

	<div style="text-align: center; margin-top: 15px;">
	<img src="Images/C9/Quicker_20240417_203628.png" width="80%" style="margin: 0 auto;">
	</div>

	å‡å¦‚ $G$ æœ‰ $v$ ä¸ªé¡¶ç‚¹å’Œ $e$ æ¡è¾¹ï¼Œé‚£ä¹ˆ $e = \dfrac{\sum\limits_{i = 0}^{n - 1}d_i}{2}$ï¼Œå…¶ä¸­ $d_i = \text{degree}(v_i)$ï¼ˆ[æ¡æ‰‹å®šç†](../../math/dm/10.md#basic-terminology)ï¼‰
	
	å¯¹äºæœ‰å‘å›¾è€Œè¨€ï¼Œæ‰€æœ‰é¡¶ç‚¹å…¥åº¦ä¹‹å’Œ = æ‰€æœ‰é¡¶ç‚¹å‡ºåº¦ä¹‹å’Œ

### Representation of Graph

æ³•ä¸€ï¼š**é‚»æ¥çŸ©é˜µ(adjacency matrix)**

å¯¹äºä¸€å¼ å…·æœ‰ $n(n \ge 1)$ ä¸ªèŠ‚ç‚¹çš„å›¾ $G(V, E)$ï¼Œå®šä¹‰é‚»æ¥çŸ©é˜µ $adj\_mat [i] [j]$ä¸º

$$
adj\_mat[i][j] = \begin{cases}1 & \text{if } (v_i, v_j) \text{ or } <v_i, v_j> \in E(G) \\ 0 & \text{otherwise}\end{cases}
$$

æ‰€ä»¥ä¹Ÿå°±æœ‰ï¼š

$$
\text{degree}(i) = \begin{cases}\sum\limits_{j = 0}^{n - 1} adj\_mat[i][j] & \text{if G is undirected} \\ \sum\limits_{j = 0}^{n - 1} adj\_mat[i][j] + \sum\limits_{j = 0}^{n - 1}adj\_mat[j][i] & \text{if G is directed} \end{cases}
$$

ä¸éš¾çœ‹å‡ºï¼Œå¦‚æœ$G$æ˜¯æ— å‘çš„ï¼Œåˆ™è¯¥é‚»æ¥çŸ©é˜µæ˜¯å¯¹ç§°çš„ï¼Œå› æ­¤æµªè´¹äº†ä¸€åŠçš„ç©ºé—´å’Œæ—¶é—´ï¼ˆå¤æ‚åº¦ï¼š$\Theta(|V|^2)$ï¼‰ï¼Œä½†æ˜¯ç”¨åœ¨**ç¨ å¯†(dense)å›¾**ï¼ˆ$|E| = \Theta(|V|^2)$ï¼‰ä¸­æ˜¯æ¯”è¾ƒåˆé€‚çš„ã€‚

æ”¹è¿›æªæ–½ï¼šé€šè¿‡å°†**ä¸‹ä¸‰è§’çŸ©é˜µ**å­˜å…¥ä¸€ç»´æ•°ç»„ä¸­ï¼ŒèŠ‚çœäº†ä¸€åŠçš„ç©ºé—´

$adj\_mat[n(n+1)/2] = \{a_{11}, a_{21}, \dots, a_{n1}, \dots, a_{nn}\}$ï¼Œå…¶ä¸­ $a_{ij}$ çš„ç´¢å¼•ä¸º $\dfrac{i(i-1)}{2} + j$

---
æ³•äºŒï¼š**é‚»æ¥è¡¨(adjacency lists)**

???+ example "ä¾‹å­"

	å¦‚ä½•å­˜å‚¨è¿™å¼ å›¾ï¼Ÿ

	<div style="text-align: center; margin-top: 15px;">
	<img src="Images/C9/Quicker_20240417_205817.png" width="40%" style="margin: 0 auto;">
	</div>

	=== "é‚»æ¥çŸ©é˜µ"

		$$adj\_mat = \begin{bmatrix}0 & 1 & 0 \\ 1 & 0 & 1 \\ 0 & 0 & 0\end{bmatrix}$$

	=== "é‚»æ¥è¡¨"

		<div style="text-align: center; margin-top: 15px;">
		<img src="Images/C9/Quicker_20240417_210032.png" width="40%" style="margin: 0 auto;">
		</div>

		>æ³¨ï¼šèŠ‚ç‚¹çš„é¡ºåºå¹¶ä¸é‡è¦

å¯¹äºæ— å‘å›¾ $G$ï¼Œé‚»æ¥è¡¨çš„ç©ºé—´ $S = n$ ä¸ªå¤´ + $2e$ä¸ªèŠ‚ç‚¹ = $(n + 2e)$ä¸ªæŒ‡é’ˆ + $2e$ä¸ªæ•´å‹

æ—¶é—´å¤æ‚åº¦ $T = E(G) = O(|V| + |E|)$ï¼Œé€‚ç”¨äº**ç¨€ç–(sparse)å›¾**($|E| < \Theta(|V|^2)$)ä¸­

>æ³¨ï¼šäº‹å®ä¸Šï¼Œé‚»æ¥è¡¨å¯ä»¥èƒœä»»å„ç§å›¾çš„å­˜å‚¨

!!! note "å¦‚ä½•è®¡ç®—æŸä¸ªé¡¶ç‚¹çš„åº¦"

	=== "æ— å‘å›¾"

		Degree(i) = graph[i]ä¸­èŠ‚ç‚¹çš„ä¸ªæ•°

	=== "æœ‰å‘å›¾"

		æˆ‘ä»¬éœ€è¦æ‰¾åˆ°in-degree(i)

		+ æ³• 1ï¼šâ€œé€†è½¬â€é‚»æ¥é“¾è¡¨

			<div style="text-align: center; margin-top: 15px;">
			<img src="Images/C9/Quicker_20240417_210654.png" width="40%" style="margin: 0 auto;">
			</div>

		+ æ³• 2ï¼šç”¨[**å¤šé“¾è¡¨(multilist)**](3.md#multilists)è¡¨ç¤ºé‚»æ¥çŸ©é˜µ$adj\_mat[i][j]$

			<div style="text-align: center; margin-top: 15px;">
			<img src="Images/C9/Quicker_20240417_210838.png" width="40%" style="margin: 0 auto;">
			</div>

		ä¼—æ‰€å‘¨çŸ¥ï¼Œå¤šé“¾è¡¨å®ç°ç›¸å½“å¤æ‚ï¼Œå› æ­¤æ›´æ¨èæ³• 1

	???+ info "è¡¥å……"

		æœ‰æ—¶é¡¶ç‚¹çš„å€¼ä¸ä¸€å®šæ˜¯æ•´æ•°ï¼Œä¹Ÿæœ‰å¯èƒ½æ˜¯å­—ç¬¦ä¸²ï¼Œè¿™æ—¶éœ€è¦ç»´æŠ¤ä¸€å¼ ä»å­—ç¬¦ä¸²æ˜ å°„åˆ°æ•´æ•°ç´¢å¼•çš„è¡¨æ ¼ï¼Œåœ¨å›¾ä¸­ç”¨ç´¢å¼•ä»£æ›¿å­—ç¬¦ä¸²

---
æ³•ä¸‰ï¼šé‚»æ¥å¤šé‡è¡¨(adjacency multilist)
>æ³¨ï¼šè¿™ä¸ªä¸ä½œè¦æ±‚ï¼Œäº†è§£å³å¯

åœ¨ä¹‹å‰çš„é‚»æ¥è¡¨é‡Œï¼Œå¯¹äºæ¯æ¡è¾¹ $(v_i, v_j)$ï¼Œæˆ‘ä»¬ä¼šæœ‰ä¸¤ä¸ªèŠ‚ç‚¹ï¼š

<div style="text-align: center; margin-top: 15px;">
<img src="Images/C9/Quicker_20240417_211329.png" width="40%" style="margin: 0 auto;">
</div>

é€šè¿‡æ”¹è¿›ï¼Œå°†è¿™ä¸¤ä¸ªèŠ‚ç‚¹ç»“åˆåˆ°ä¸€èµ·ï¼š

<div style="text-align: center; margin-top: 15px;">
<img src="Images/C9/Quicker_20240417_211529.png" width="40%" style="margin: 0 auto;">
</div>

äºæ˜¯å°±æœ‰å¦‚ä¸‹è¡¨ç¤ºæ–¹æ³•ï¼ˆmark è¡¨ç¤ºæŸä¸€æ¡è¾¹ï¼‰ï¼š

<div style="text-align: center; margin-top: 15px;">
<img src="Images/C9/Quicker_20240417_211427.png" width="20%" style="margin: 0 auto;">
</div>

æœ€ç»ˆæ•ˆæœï¼š

<div style="text-align: center; margin-top: 15px;">
<img src="Images/C9/Quicker_20240417_211622.png" width="50%" style="margin: 0 auto;">
</div>

è§‚å¯Ÿå‘ç°ï¼Œåœ¨æ²¡æœ‰è€ƒè™‘ mark å­˜å‚¨çš„æƒ…å†µä¸‹ï¼Œè¿™ç§è¡¨ç¤ºæ³•çš„å ç”¨ç©ºé—´ä¸é‚»æ¥è¡¨å®Œå…¨ä¸€æ ·ã€‚è™½ç„¶å®ƒçš„ç©ºé—´å¤æ‚åº¦ç•¥å¾®é«˜äº†ç‚¹ï¼Œä½†æ˜¯åœ¨æŸäº›æƒ…å†µä¸‹ï¼ˆæ¯”å¦‚æ£€éªŒæŸæ¡è¾¹åè¿˜è¦æ£€éªŒä¸‹ä¸€æ¡è¾¹ï¼‰æ¯”è¾ƒæœ‰åˆ©ã€‚

---
æœ‰æ—¶ï¼Œæˆ‘ä»¬ä¼šé‡åˆ°**å¸¦æƒè¾¹(weighted edges)**çš„æƒ…å†µï¼Œå¤„ç†æ–¹å¼å¦‚ä¸‹ï¼š

+ é‚»æ¥çŸ©é˜µï¼š$adj\_mat[i][j] = \text{weight}$
+ é‚»æ¥è¡¨/é‚»æ¥å¤šé‡è¡¨ï¼šä¸ºæ¯ä¸ªèŠ‚ç‚¹æ·»åŠ æƒé‡çš„å­—æ®µ

## Topological Sort

**AOVç½‘(activity on vertex network)**ï¼šå¯¹äºæœ‰å‘å›¾ $G$ï¼Œ$V(G)$ è¡¨ç¤ºæ´»åŠ¨ï¼Œ$E(G)$ è¡¨ç¤ºä½æ¬¡å…³ç³»

:chestnut:ï¼ˆC1 æ˜¯ C3 çš„å‰ç½®æ´»åŠ¨ï¼‰

<div style="text-align: center; margin-top: 15px;">
<img src="Images/C9/Quicker_20240417_212653.png" width="20%" style="margin: 0 auto;">
</div>

+ å¦‚æœä» $i$ åˆ° $j$ æœ‰ä¸€æ¡è·¯å¾„ï¼Œåˆ™ç§° $i$ æ˜¯ $j$ çš„**å‰ä»»(predecessor)**
+ å¦‚æœ $<i, j> \in E(G)$ï¼Œåˆ™ç§° $i$ æ˜¯ $j$ çš„**ç›´æ¥å‰ä»»(immediate predecessor)**ã€‚ç§° $j$ æ˜¯ $i$ çš„ **ï¼ˆç›´æ¥ï¼‰åä»»((immediate) successor)**

å¯è¡Œçš„AOVç½‘å¿…é¡»æ˜¯ä¸€ä¸ª**æœ‰å‘æ— ç¯å›¾(DAG)**

>è¡¥å……é˜…è¯»ï¼š[AOEç½‘](https://oi-wiki.org/graph/topo/)

**ååº(partial order)**æ˜¯ä¸€ç§å…·æœ‰ä»¥ä¸‹æ€§è´¨çš„å…³ç³»

+ **åè‡ªåæ€§(irreflexive)**ï¼ˆä¸å­˜åœ¨ $i \rightarrow i$ï¼‰
+ **åå¯¹ç§°æ€§(anti-symmetric)**ï¼ˆ$(i \rightarrow j) \wedge (j \rightarrow i) \Rightarrow i = j$ï¼‰
+ **ä¼ é€’æ€§**ï¼ˆ$i \rightarrow j, j \rightarrow k \Rightarrow i \rightarrow k$ï¼‰

!!! info "è¯´æ˜"

	+ è¿™é‡Œçš„ååºæŒ‡çš„æ˜¯**ä¸¥æ ¼ååº**ï¼Œå› æ­¤å’Œç¦»æ•£æ•°å­¦å®šä¹‰çš„[ååº](../../math/dm/9.md#partial-orderings)ç•¥æœ‰åŒºåˆ«
	+ å¦‚æœå…·æœ‰è‡ªåæ€§ï¼Œå°±ä¼šå‡ºç°è¦åšä¸€ä»¶äº‹ $i$ ä¹‹å‰è¦å®Œæˆ $i$ çš„æ€ªåœˆï¼Œå› æ­¤âŒ

---
**æ‹“æ‰‘åº(topological order)**æ˜¯ä¸€å¼ å›¾çš„é¡¶ç‚¹çš„çº¿æ€§é¡ºåºï¼Œæ»¡è¶³ï¼šå¯¹äºä»»æ„ä¸¤ä¸ªé¡¶ç‚¹ $i, j$ï¼Œå¦‚æœ $i$ æ˜¯ $j$ çš„å‰ä»»ï¼Œåˆ™åœ¨çº¿æ€§é¡ºåºä¸­ $i$ è¦å‡ºç°åœ¨ $j$ ä¹‹å‰

æ³¨ï¼š

+ æ‹“æ‰‘åºä¸ä¸€å®šæ˜¯å”¯ä¸€çš„
+ å¦‚æœæ‹“æ‰‘åºä¸­ä¸€ä¸ªé¡¶ç‚¹å‡ºç°åœ¨å¦ä¸€ä¸ªé¡¶ç‚¹çš„å‰é¢ï¼Œå®ƒä»¬ä¹‹é—´ä¸ä¸€å®šå­˜åœ¨è·¯å¾„
+ å¯ä»¥ç”¨æ‹“æ‰‘åºæ£€éªŒæœ‰å‘å›¾æ˜¯å¦å­˜åœ¨ç¯

??? code "ä»£ç å®ç°"

	``` c
	// version 1
	void Topsort(Graph G)
	{
		int Counter;
		Vertex V, W;
		for (Counter = 0; Counter < NumVertex; Counter++)
		{
			V = FindNewVertexOfDegreeZero(); // O(|V|)
			if (V == NotAVertex)
			{
				Error("Graph has a cycle");
				break;
			}
			TopNum[V] = Counter; // or output V
			for (each W adjacent from V)
				indegreep[W]--;
		}
	}
	```

+ `FindNewVertexOfDegreeZero()`ï¼šæ‰«æ `Indegree[]` æ•°ç»„ï¼Œæ‰¾åˆ°å…¥åº¦ä¸º 0 ä¸”æœªèµ‹äºˆæ‹“æ‰‘åºçš„é¡¶ç‚¹ï¼Œå¦‚æœæ²¡æœ‰æ‰¾åˆ°é¡¶ç‚¹ï¼Œé‚£ä¹ˆè¡¨æ˜å›¾ä¸­å‡ºç°äº†ç¯
+ æ¯å¤„ç†å®Œä¸€ä¸ªé¡¶ç‚¹ V åï¼Œå°±éœ€è¦è®©ä» V å‡ºå‘ä¸ V é‚»æ¥çš„é¡¶ç‚¹çš„å…¥åº¦ -1ï¼Œç›¸å½“äºåœ¨å›¾ä¸Šç§»é™¤äº†é¡¶ç‚¹ V ä»¥åŠå®ƒçš„æ‰€æœ‰å‡ºè¾¹
+ æ—¶é—´å¤æ‚åº¦ï¼š$T = O(|V|^2)$ ğŸ‘

---
æ”¹è¿›æ–¹æ³•ï¼šå°†æ‰€æœ‰**æœªèµ‹äºˆæ‹“æ‰‘åºçš„ã€åº¦ä¸º 0 çš„é¡¶ç‚¹**æ”¾å…¥ç‰¹æ®Šçš„ç›’å­ï¼ˆæ¯”å¦‚**é˜Ÿåˆ—**æˆ–**æ ˆ*ï¼‰é‡Œ

??? play "åŠ¨ç”»æ¼”ç¤º"

	<div style="text-align: center; margin-top: 15px;">
	<img src="Images/C9/11.gif" width="30%" style="margin: 0 auto;">
	</div>

??? code "ä»£ç å®ç°"	

	``` c
	// version 2, using queue ADT
	void Topsort(Graph G)
	{
		Queue Q;
		int Counter = 0;
		Vertex V, W;
		
		Q = CreateQueue(NumVertex); 
		for (each vertex V)
			if (indegree[V] == 0) 
				Enqueue(V, Q);
		while (!isEmpty(Q))
		{
			V = Dequeue(Q);
			TopNum[V] = ++Counter;  // assign next
			for (each W adjacent from V)
				if (--indegree[W] == 0)
					Enqueue(W, Q);
		} // end-while
		if (Counter != NumVertex)
			Error("Graph has a cycle")
		DisposeQueue(Q); // free memery
	}
	```

æ—¶é—´å¤æ‚åº¦ï¼š$O(|E| + |V|)$

??? example "ä¾‹é¢˜"

	=== "é—®é¢˜"

		<div style="text-align: center; margin-top: 15px;">
		<img src="Images/C9/Quicker_20240417_214857.png" width="80%" style="margin: 0 auto;">
		</div>

	=== "ç­”æ¡ˆ"

		<div style="text-align: center; margin-top: 15px;">
		<img src="Images/C9/Quicker_20240417_214925.png" width="80%" style="margin: 0 auto;">
		</div>

## Shortest Path Algorithms

ç»™å®šä¸€å¼ æœ‰å‘å›¾ $G(V, E)$ï¼Œä»¥åŠæˆæœ¬å‡½æ•° $c(e)$ï¼Œ$e \in E(G)$ï¼Œä»**æº(source)**åˆ°**ç›®çš„åœ°(destination)**çš„è·¯å¾„ $P$ çš„é•¿åº¦(length)ä¸º $\sum\limits_{e_i \subset P}c(e_i)$ï¼ˆä¹Ÿè¢«ç§°ä¸º**å¸¦æƒè·¯å¾„é•¿åº¦(weighted path length)**ï¼‰

### Single-Source Shortest-Path Problem

!!! question "é—®é¢˜"

	ç»™å®šä¸€å¼ æƒé‡å›¾ $G(V, E)$ï¼Œä»¥åŠä¸€ä¸ªå¯åŒºåˆ†çš„é¡¶ç‚¹ $s$ï¼Œå¯»æ‰¾ä» $s$ åˆ° $G$ ä¸­æ‰€æœ‰å…¶ä»–é¡¶ç‚¹çš„æœ€çŸ­æƒé‡è·¯å¾„

:chestnut:ï¼š

<div style="text-align: center; margin-top: 15px;">
<img src="Images/C9/Quicker_20240424_131818.png" width="70%" style="margin: 0 auto;">
</div>

+ å³å›¾å­˜åœ¨è´Ÿçš„è¾¹ï¼Œè¿™æ ·æœ€çŸ­è·¯çš„é•¿åº¦å¯ä»¥æ˜¯æ— ç©·å°ã€‚å› æ­¤åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæœ€çŸ­è·¯æ˜¯æœªå®šä¹‰çš„ï¼Œå› ä¸ºé™·å…¥äº†æ­»å¾ªç¯ã€‚è¿™ç§å¾ªç¯è¢«ç§°ä¸º**è´Ÿå€¼ç¯(negative-cost cycle)**
+ ä» $s$ åˆ° $s$ çš„æœ€çŸ­è·¯å¾„è¢«å®šä¹‰ä¸º 0
+ ç°åœ¨ï¼Œè¿˜æ²¡æœ‰ä¸€ç§æœ€çŸ­è·¯ç®—æ³•çš„é€Ÿåº¦å¿«äºæ‰¾åˆ°ä» $s$ åˆ°æ‰€æœ‰é¡¶ç‚¹çš„è·¯å¾„çš„ç®—æ³•

#### Unweighted Shortest Paths

åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæ‰€æœ‰è¾¹çš„æƒé‡ = 1

<div style="text-align: center; margin-top: 15px;">
<img src="Images/C9/Quicker_20240424_132143.png" width="60%" style="margin: 0 auto;">
</div>

å¦‚å›¾æ‰€ç¤ºï¼Œä¸ºäº†æ‰¾åˆ°ä» $v_3$ å‡ºå‘åˆ°å…¶ä»–é¡¶ç‚¹çš„æ‰€æœ‰æœ€çŸ­è·¯å¾„ï¼š

+ å…ˆæ‰¾åˆ°ä¸ $v_3$ é‚»æ¥çš„é¡¶ç‚¹ï¼Œè®°ä» $v_3$ åˆ°è¿™äº›é¡¶ç‚¹çš„æœ€çŸ­è·¯å¾„ä¸º 1
+ ç„¶åå†ä»è¿™äº›é¡¶ç‚¹å‡ºå‘ï¼Œæ‰¾åˆ°ä¸å®ƒä»¬é‚»æ¥çš„é¡¶ç‚¹ã€‚å¦‚æœæ–°æ‰¾åˆ°çš„é¡¶ç‚¹è¿˜æ²¡æœ‰ç›¸åº”çš„æœ€çŸ­è·¯å¾„ï¼Œé‚£å°±è®°è¿™äº›é¡¶ç‚¹çš„æœ€çŸ­è·¯å¾„ä¸º 2
+ é‡å¤æ­¥éª¤ 2ï¼Œç›´è‡³æ‰€æœ‰é¡¶ç‚¹çš„æœ€çŸ­è·¯å¾„éƒ½å·²æ‰¾åˆ°

è¿™ç§æ–¹æ³•è¢«ç§°ä¸º**å®½åº¦ä¼˜å…ˆæœç´¢(breadth-first search, BFS)**ï¼šè¯¥æ–¹æ³•ä¸€å±‚å±‚åœ°å¤„ç†é¡¶ç‚¹ï¼šæœ€è¿‘çš„é¡¶ç‚¹æœ€å…ˆå¤„ç†ï¼Œæœ€è¿œçš„é¡¶ç‚¹æœ€åå¤„ç†ã€‚è¿™å’Œæ ‘ä¸­çš„[å±‚åºéå†](4.md#tree-traversals)ç±»ä¼¼

å®½åº¦ä¼˜å…ˆæœç´¢çš„ç¤ºæ„å›¾ï¼š

<div style="text-align: center; margin-top: 15px;">
<img src="Images/C9/13.png" width="60%" style="margin: 0 auto;">
</div>

!!! note "å®ç°"

	+ `Table[i].Dist` ::= ä»$s$åˆ°$v_i$çš„è·ç¦» $= \begin{cases}\infty & \text{if } v_i \ne s \\ 0 & \text{if } v_i = s\end{cases}$

	+ `Table[i].Known` ::= $\begin{cases}1 \quad \text{if } v_i \text{ is checked} \\ 0 \quad \text{if not}\end{cases}$

	>+ å…¶å®æ²¡æœ‰å¿…è¦è®¾è¿™ä¸ªå­—æ®µ(å› ä¸º `Table[i].Dist` åŒæ—¶å…·å¤‡**æ ‡è®°**åŠŸèƒ½)ï¼Œå†™åœ¨è¿™é‡Œåªæ˜¯æé†’ä¸€ä¸‹è¦åšä¸€ä¸‹æ ‡è®°
	>+ åœ¨åˆå§‹åŒ–ä¸­ï¼Œæ‰€æœ‰é¡¶ç‚¹çš„ `Table[i].Known = 0`ï¼ŒåŒ…æ‹¬èµ·å§‹é¡¶ç‚¹ï¼Œå› ä¸ºæ²¡æœ‰ä»»ä½•é¡¶ç‚¹è¢«å¤„ç†è¿‡

	+ `Table[i].Path` ::= è®°å½•è·¯å¾„ä¸Š $v_i$ çš„å‰ä¸€ä¸ªé¡¶ç‚¹ï¼Œä»¥ä¾¿æ‰“å°æ•´æ¡è·¯å¾„

??? code "ä»£ç å®ç°"

	``` c
	// version 1
	void Unweighted(Table T)
	{
		int CurrDist;
		Vertex V, W;
		for(CurrDist = 0; CurrDist < NumVertex; CurrDist++)
		{
			for (each vertex V)
				if (!T[V].Known && T[V].Dist == CurrDist)
				{
					T[V].Known = true;
					for (each W adjacent to V)
						if (T[W].Dist == infinity)
						{
							T[W].Dist = CurrDist + 1;
							T[W].Path = V;  // (*)
						}// end-if Dist == Infinity
				} // end-if !Known &&Dist == CurrDist
		} // end-for CurrDist
	}
	```

è¿™ä¸ªç®—æ³•æ˜¾ç„¶æ²¡ä»€ä¹ˆæ•ˆç‡ï¼Œå› ä¸ºå¤–å±‚å¾ªç¯è¦å¾ªç¯ `NumVertex - 1` æ¬¡æ‰ç»“æŸï¼Œå³ä½¿æ‰€æœ‰çš„é¡¶ç‚¹æ—©å°±å¤„ç†è¿‡äº†ã€‚è™½ç„¶å¯ä»¥å¢åŠ ä¸€ä¸ªé¢å¤–çš„åˆ¤æ–­æå‰ç»“æŸå¾ªç¯ï¼Œä½†è¿™å¹¶æ²¡æœ‰å½±å“æœ€åæƒ…å†µçš„è¿è¡Œæ—¶é—´ï¼Œæ¯”å¦‚ï¼š

<div style="text-align: center; margin-top: 15px;">
<img src="Images/C9/Quicker_20240424_134237.png" width="70%" style="margin: 0 auto;">
</div>

èµ·å§‹ç‚¹ä¸º $v_9$ï¼Œç¬¬ä¸€æ¬¡å¾ªç¯è¦æ‰¾ `CurrDist == 0` çš„é¡¶ç‚¹ï¼ˆå³ $v_9$ï¼‰ã€‚æˆ‘ä»¬ä¸€èˆ¬ä¼šæŒ‰ç…§èŠ‚ç‚¹ä¸‹æ ‡çš„é€’å¢é¡ºåºæŸ¥æ‰¾ï¼Œåˆ™è¦æ‰¾åˆ° $v_9$ éœ€è¦ä»å¤´éå†åˆ°å°¾ï¼›è€Œä¸”ä¸éš¾çœ‹å‡ºï¼Œæ¯æ¬¡å¾ªç¯å‡ä¼šä»å¤´éå†åˆ°å°¾ï¼ˆè¶Šæ¥è¶Šé å‰ï¼‰

æ—¶é—´å¤æ‚åº¦ $T = O(|V|^2)$ğŸ‘

---
å¯ä»¥å‘ç°ï¼Œå¦‚æœé¡¶ç‚¹ $V$ æœªè¢«æ ‡è®°ï¼Œä½† $d_v \ne \infty$ï¼Œé‚£ä¹ˆ $d_v = CurrDist$ æˆ– $d_v = CurrDist + 1$ï¼Œå› æ­¤æ²¡æœ‰å¿…è¦åƒä¸Šé¢é‚£ä¸ªç®—æ³•ä¸€æ ·æ‰«ææ•´ä¸ªè¡¨æ¥æ‰¾åˆ°åˆé€‚çš„é¡¶ç‚¹ã€‚

??? info "æ”¹è¿›æ€è·¯"

	ç”¨ä¸¤ä¸ªç®±å­ï¼Œä¸€ä¸ªç®±å­æ”¾æœªæ ‡è®°çš„ $d_v = CurrDist$ çš„é¡¶ç‚¹ï¼Œå¦ä¸€ä¸ªç®±å­æ”¾æœªæ ‡è®°çš„ä¸” $d_v = CurrDist + 1$ çš„é¡¶ç‚¹ã€‚é‚£ä¹ˆï¼ŒåŸæ¥æ‰«ææ•´å¼ è¡¨çš„æ“ä½œå¯ä»¥å˜æˆï¼šä»ç¬¬ 1 ä¸ªç®±å­æ‰¾ä»»ä¸€é¡¶ç‚¹ $V$ï¼Œç­‰åˆ° (\*) é‚£è¡Œä»£ç æ‰§è¡Œå®Œåï¼Œå°† $W$ æ”¾å…¥ç¬¬ 2 ä¸ªç®±å­ã€‚ç­‰åˆ°å¤–å±‚ `for` å¾ªç¯ä¸€è½®ç»“æŸåï¼Œç¬¬ 1 ä¸ªç®±å­ä¸ºç©ºï¼Œå°†ç¬¬ 2 ä¸ªç®±å­çš„é¡¶ç‚¹è½¬ç§»åˆ°ç¬¬ 1 ä¸ªç®±å­ï¼Œè¿›è¡Œä¸‹ä¸€è½®å¾ªç¯ã€‚

äº‹å®ä¸Šï¼Œæˆ‘ä»¬åªéœ€è¦ä¸€ä¸ª**é˜Ÿåˆ—**å°±èƒ½å®Œæˆä¸Šè¿°æ”¹è¿›æ€è·¯ï¼š
>è¿™é‡Œä¸ç”¨ `Known` å­—æ®µæ˜¯å› ä¸º `Dequeue` å°±ä»£è¡¨é¡¶ç‚¹å·²ç»è¢«å¤„ç†è¿‡äº†ï¼Œä¸ä¼šå†å›åˆ°é˜Ÿåˆ—é‡Œ

??? code "ä»£ç å®ç°"

	``` c
	// version 2
	void Unweighted(Table T)
	{
		// T is initialized with the source vertex S given
		Queue Q;
		Vertex V, W;
		Q = CreateQueue(NumVertex);
		MakeEmpty(Q);
		Enqueue(S, Q); // Enqueue the source vertex
		while (!IsEmpty(Q))
		{
			V = Dequeue(Q);
			T[V].Known = true;  // not really necessary
			for (each W adjacent to V)
				if (T[W].Dist == Infinity)
				{
					T[W].Dist = T[V].Dist + 1;
					T[W].Path = V;
					Enqueue(W, Q);
				} // end-if Dist == Infinity
		} // end-while
		DisposeQueue(Q); // free memory
	}
	```

>å¯ä»¥çœ‹åˆ°ï¼Œè¿™å’Œæ‹“æ‰‘æ’åºçš„ç®—æ³•å¾ˆåƒ

???+ play "åŠ¨ç”»æ¼”ç¤º"

	<div style="text-align: center; margin-top: 15px;">
	<img src="Images/C9/6.gif" width="30%" style="margin: 0 auto;">
	</div>

#### Dijkstra's Algorithm(for weighted shortest paths)

!!! note "Dijkstraç®—æ³•çš„æ€è·¯"

	ä»¤ $S =$ {$s$ å’Œå·²æ‰¾åˆ°æœ€çŸ­è·¯å¾„çš„é¡¶ç‚¹ $v_i$ çš„é›†åˆ}ã€‚å¯¹äº $\forall u \notin S$ï¼Œå®šä¹‰`distance[u]` = è·¯å¾„ $\{s \rightarrow (v_i \in S) \rightarrow u\}$ çš„æœ€å°é•¿åº¦

	+ Dijkstra ç®—æ³•æŒ‰é˜¶æ®µæ‰§è¡Œï¼Œåœ¨æ¯ä¸ªé˜¶æ®µä¸­ï¼ŒæŒ‘é€‰ä¸€ä¸ªé¡¶ç‚¹$v$ï¼Œä¿è¯å®ƒæ˜¯æ‰€æœ‰**æœªè¢«æ ‡è®°**çš„é¡¶ç‚¹ä¸­è·¯å¾„é•¿åº¦$d_v$**æœ€çŸ­**çš„é‚£ä¸ªé¡¶ç‚¹ï¼ˆå¦‚æœæœ‰å¤šä¸ªæœ€çŸ­è·¯å¾„é•¿åº¦ï¼Œåˆ™ä»»æ„æŒ‘é€‰é¡¶ç‚¹ï¼‰
	+ å¯¹äºä»é¡¶ç‚¹ $v$ å‡ºå‘çš„é‚»æ¥é¡¶ç‚¹ $w$ï¼Œ$d_w = \min(d_w, d_v + c_{v, w})$
	+ æ ‡è®°é¡¶ç‚¹ $v$ï¼Œå³ä»¤ $v \in S$
	+ ç„¶åå¯¹äºå‰©ä½™æœªè¢«æ ‡è®°çš„é¡¶ç‚¹ï¼Œé‡å¤ä¸Šè¿°æ“ä½œï¼Œç›´è‡³æ‰€æœ‰é¡¶ç‚¹å‡è¢«æ ‡è®°

	ä¸éš¾å‘ç°ï¼Œè¿™æ˜¯ä¸€ç§**è´ªå¿ƒç®—æ³•**

??? code "é¢„å¤‡å·¥ä½œ"

	``` c
	// Declarations for Dijkstra's algorithm
	typedef int Vertex

	struct TableEntry
	{
		List Header; // Adjacency list
		int Known;
		DistType Dist;
		Vertex Path;
	};

	// Vertices are numbered from 0
	#define NotAVerTex (-1)
	typedef struct TableEntry Table[NumVertex];

	// Initialization
	void InitTable(Vertex Start, Graph G, Table T)
	{
		int i;

		ReadGraph(G, T);
		for (i = 0; i < NumVertex; i++)
		{
			T[i].Known = False;
			T[i].Dist = Infinity;
			T[i].Path = NotAVerTex;
		}
		T[Start].dist = 0;
	}

	// Print shortest path to V after Dijkstra has run
	// Assume that the path exists
	void PrintPath(Vertex V, Table T)
	{
		if(T[V].Path != NotAVertex)
		{
			PrintPath(T[V].Path, T);
			printf(" to");
		}
		printf("%v", V) // %v is pseudocode
	}
	```

??? code "ä»£ç å®ç°"

	``` c
	void Dijkstra(Table T)
	{
		Vertex V, W;
		for(;;)  // O(|V|)
		{
			V = smallest unknown distance vertex;
			if (V == NotAVertex)
				break;
			T[V].Known = true;
			for (each W adjacent to V)
				if (!T[W].Known)
					if(T[V].Dist + Cvw < T[W].Dist) // è¿™æ­¥æ“ä½œè¢«ç§°ä¸ºâ€œæ¾å¼›â€
					{
						Decrease(T[W].Dist to T[V].Dist + Cvw); 
						T[W].Path = V;
					} // end-if update W
		} // end-for(;;)
	} // now work for edge with negative cost
	```

???+ play "åŠ¨ç”»æ¼”ç¤º"

	<div style="text-align: center; margin-top: 15px;">
	<img src="Images/C9/7.gif" width="30%" style="margin: 0 auto;">
	</div>

Dijkstra ç®—æ³•çš„è¿è¡Œæ—¶é—´å–å†³äºæˆ‘ä»¬<u>å¦‚ä½•å¯»æ‰¾è·ç¦»æœ€çŸ­ä¸”æœªè¢«æ ‡è®°çš„é¡¶ç‚¹</u>

!!! note "æ–¹æ³•"

	=== "æ–¹æ³•1"

		+ ä»…ä»…ç®€å•æ‰«æä¸€éæ•´å¼ è¡¨æ¥æ‰¾åˆ° $d_v$ æœ€å°çš„é¡¶ç‚¹ $v \rightarrow O(|V|)$ï¼›è€Œä¸”å¤–å±‚å¾ªç¯éå†æ‰€æœ‰é¡¶ç‚¹ï¼Œå› æ­¤æ—¶é—´å¤æ‚åº¦ä¸º $O(|V|^2)$
		+ æ¯æ¡è¾¹æœ€å¤šä¼šæ›´æ–°ä¸€æ¬¡ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º $O(|E|)$ï¼Œè€Œä¸”ä¸é¡¶ç‚¹çš„éå†æ˜¯*ç‹¬ç«‹*çš„
		+ å› æ­¤ $T = O(|V|^2 + |E|)$ï¼Œé€‚ç”¨äº*ç¨ å¯†å›¾*ï¼ˆæ­¤æ—¶å¤æ‚åº¦ç›¸å½“äºçº¿æ€§å¤æ‚åº¦ï¼‰

	=== "æ–¹æ³•2"

		å°†è·ç¦»ä¿å­˜åœ¨**å †**é‡Œï¼Œè°ƒç”¨ `DeleteMin` æ¥æ‰¾åˆ°æœªæ ‡è®°çš„æœ€å°é¡¶ç‚¹ï¼Œå¹¶ä¸”ä¹‹åä¸å»ç®¡å®ƒã€‚
		
		é‚£ä¹ˆå¦‚ä½•å®ç°ç®—æ³•ä¸­çš„ `Decrease(T[W].Dist to T[V].Dist + Cvw);` å‘¢ï¼Ÿ
		
		=== "æ³•1"
		
			`DecreaseKey()` $\rightarrow O(\log |V|)$ï¼Œå› æ­¤$T = O(|V|\log |V| + |E| \log |V|) = O(|E|\log |V|)$ï¼Œé€‚ç”¨äº*ç¨€ç–å›¾*
			
			ä½†æ˜¯ï¼Œå› ä¸ºå †ä¸èƒ½æœ‰æ•ˆæ”¯æŒ `Find` æ“ä½œï¼Œå½“ $d_i$ çš„å€¼å‘ç”Ÿæ”¹å˜æ—¶ï¼Œå®ƒçš„ä½ç½®éœ€è¦ç»´æŠ¤å’Œæ›´æ–°ï¼Œç”¨äºŒå‰å †å®ç°èµ·æ¥æœ‰äº›éº»çƒ¦ã€‚
			
			>å¦‚æœç”¨åˆ°[**é…å¯¹å †(pairing heap)**](https://oi-wiki.org/ds/pairing-heap/)ï¼Œæƒ…å†µå°±ä¼šæ”¹å–„ï¼Œè¿™ç§æ”¹è¿›ä¸åšè¦æ±‚


		=== "æ³•2"
		
			å°†æ›´æ–°åçš„ $d_w$ æ’å…¥å †ä¸­ï¼Œè¿™æ ·çš„è¯å †å†…å°±ä¼šå‡ºç°å¤šä¸ªè¡¨ç¤ºåŒä¸€é¡¶ç‚¹çš„è·ç¦»ã€‚å› æ­¤åœ¨ `V = smallest unknown distance vertex;` è¿™ä¸€å¥ä¸­ï¼Œè¦é‡å¤ä½¿ç”¨ `DeleteMin`ï¼Œç›´åˆ°æœªæ ‡è®°çš„ç‚¹å‡ºç°ï¼ˆæ ‡è®°è¿‡çš„ç‚¹å°±æ‰”æ‰ä¸ç”¨ï¼‰ã€‚è™½ç„¶è¿™ç§æ–¹æ³•ä¼šæ‰©å¤§å †çš„è§„æ¨¡ï¼ˆ$O(|E|)$ï¼‰ï¼Œä½†æ˜¯å› ä¸º $|E| \le |V|^2$ã€‚æ‰€ä»¥ $\log |E| \le 2\log |V|$ï¼Œå› æ­¤ $T = O(|E| \log |V|)$ã€‚ä½†å®ƒå ç”¨ç©ºé—´å¤§äºæ³• 1 éœ€è¦ $|E|$ æ¬¡ `DeleteMin` æ“ä½œï¼Œå› æ­¤åœ¨å®é™…è¿è¡Œä¸­å¯èƒ½ä¼šå˜æ…¢ã€‚

			>å…¶ä»–æ”¹è¿›æ–¹æ³•ï¼š[æ–æ³¢é‚£å¥‘å †(Fibonacci heap)](https://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%A0%86)

??? code "å…·ä½“å®ç°"

	``` c
	void Dijkstra(VType s, Table T, int n)   // Finding all the shortest paths  
	{
		VType V, W;           // V: the current vertex; W: the vertex adjacent to V
		Heap H;               // A heap maintaining the shortest unknown vertex
		Vertex cur, tmp;      // cur: obtaining the information of all adjacent vertice regarding V; tmp: containing new previous vertex adjacent to W
		int len, cnt = n;     // len: the distance of T[V].dist + the distance between V and W; cnt: used to terminate the loop

		H = InitHeap(n, s);   // Initialization of the heap

		while (cnt > 0)
		{
			V = DeleteMin(H); // Obtaining the shortest unknown vertex
			T[V].Known = 1;   // Marking it
			cnt--;
			cur = G[V];       // Getting all adjacent successors
			while (cur != NULL)  // Traversing all successors
			{
				W = cur->vertex;  // The current successor
				if (!T[W].Known)  // If W isn't marked, then try to update it
				{
					len = T[V].Dist + cur->length;   // New distance
					if (len < T[W].Dist)  // If the new distance is shorter than the previous one, then update it
					{
						T[W].Dist = len;
						if (pos[W] == 0)  // If W hasn't been in the heap, then insert it into the heap
							Insert(W, len, H);
						else  // If W is in the heap, then update the distance of W and update the whole heap
							DecreaseKey(pos[W], len, H);

						T[W].Path = NULL;    // Clearing out all previous vertice, because we find the new optimal one
						tmp = (Vertex)malloc(sizeof(struct node));    // Insert the new one into the T[W].Path
						tmp->vertex = V;
						tmp->next = T[W].Path;
						T[W].Path = tmp;
					}
					else if (len == T[W].Dist)  // If the new distance is equal to the old one, then just involve the new solution
					{        
						tmp = (Vertex)malloc(sizeof(struct node));    // The same operations 
						tmp->vertex = V;
						tmp->next = T[W].Path;
						T[W].Path = tmp;    
					}
				}
				cur = cur->next;     // Finding the next one
			}
		}
	}
	```

#### Graphs with Negative Edge Costs

å¦‚æœå‡ºç°è´Ÿçš„è¾¹æˆæœ¬ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±ä¸èƒ½åœ¨ä½¿ç”¨`Known`å­—æ®µæ ‡è®°æ˜¯å¦å·²ç»å¤„ç†è¿‡æŸä¸ªé¡¶ç‚¹ï¼Œå› ä¸ºæœ‰å¯èƒ½åœ¨ç¬¬ä¸€æ¬¡å¤„ç†è¯¥é¡¶ç‚¹ä¹‹åï¼Œåˆå‘ç°æ›´å°çš„è·¯å¾„é•¿åº¦ï¼ˆå› ä¸ºè´Ÿçš„è¾¹ï¼‰ï¼Œéœ€è¦é‡å¤å¤„ç†æŸä¸ªé¡¶ç‚¹

???+ info "ä¸€ç§å°è¯•âŒ"

	ç»™æ‰€æœ‰è¾¹<u>åŠ ä¸Šä¸€ä¸ªç›¸åŒçš„æ­£å¸¸æ•°</u>ï¼Œä½¿å¾—æ‰€æœ‰è¾¹çš„æˆæœ¬ä¸ºæ­£æ•°

	åˆ†æï¼šè¿™æ ·åšçš„è¯ï¼ŒåŸæœ¬åŒ…å«è¾¹æ•°è¾ƒå¤šçš„è·¯å¾„ï¼Œå®ƒçš„æˆæœ¬å¢é•¿å°±æ˜æ˜¾å¤šäºè¾¹æ•°è¾ƒå°‘çš„è·¯å¾„ï¼Œè¿™å°±æœ‰å¯èƒ½æ”¹å˜æœ€çŸ­è·¯å¾„çš„å–æ³•ã€‚

	>ç„¶è€Œï¼Œè‹¥æ‰€æœ‰è¾¹çš„æƒé‡éƒ½<u>ä¹˜ä¸Šä¸€ä¸ªç›¸åŒçš„æ­£å¸¸æ•°</u>ï¼Œè¿™ä¸å½±å“æœ€çŸ­è·¯çš„ç»“æœ

æˆ‘ä»¬ç”¨â€œæ— æƒé‡æœ€çŸ­è·¯ç®—æ³• + Dijkstraç®—æ³•â€æ¥è§£å†³è¿™ä¸€é—®é¢˜ï¼š

??? code "ä»£ç å®ç°"

	``` c
	void WeightedNegative(Table T)
	{
		Queue Q;
		Vertex V, W;
		Q = CreateQueue(NumVertex);
		MakeEmpty(Q);
		Enqueue(S, Q); // Enqueue the source vertex
		while (!IsEmpty(Q)) // each vertex can dequeue at most |V| times
		{
			V = Dequeue(Q);
			for (each W adjacent to V)
				if (T[V].Dist + Cvw < T[W].Dist) // no longer once per edge
				{
					T[W].Dist = T[V].Dist + Cvw;
					T[W].Path = V;
					if (W is not already in Q)
						Enqueue(W, Q);
				} // end-if update
		} // end-while
		DisposeQueue(Q); // free memory
	} // negative-cost cycle will cause indefinite loop
	```

+ æ—¶é—´å¤æ‚åº¦ï¼š$O(|E| \cdot |V|)$
+ å¦‚æœå‡ºç°[**è´Ÿå€¼ç¯**](#single-source-shortest-path-problem)ï¼Œè¯¥ç®—æ³•å°†ä¼šé™·å…¥æ— é™å¾ªç¯ã€‚å› æ­¤ï¼Œè®°å½•æ¯ä¸ªé¡¶ç‚¹çš„å‡ºé˜Ÿæ¬¡æ•°ï¼Œå‘ç°æœ‰é¡¶ç‚¹å‡ºé˜Ÿæ¬¡æ•°å¤šäº $|V|$ æ¬¡æ—¶ï¼Œå°±ç»ˆæ­¢ç¨‹åºï¼Œè¿™æ ·å¯ä»¥é¿å…è¿™ä¸€é—®é¢˜

#### Acyclic Graphs

å¦‚æœå›¾æ˜¯*æ— ç¯(acyclic)*ï¼Œæˆ‘ä»¬å¯ä»¥æŒ‰ç…§æ‹“æ‰‘åºé€‰æ‹©é¡¶ç‚¹ï¼Œå› ä¸ºå½“é€‰æ‹©æŸä¸ªé¡¶ç‚¹åï¼Œå®ƒçš„è·ç¦»ä¸å¯èƒ½å› ä¸ºå®ƒå‰é¢é¡¶ç‚¹çš„å…¥è¾¹è€Œå‡å°‘ï¼Œè¿™æ ·åªéœ€æ‰§è¡Œä¸€è¶Ÿç®—æ³•å³å¯ã€‚

æ—¶é—´å¤æ‚åº¦$T = O(|E| + |V|)$ï¼Œä¸éœ€è¦ä¼˜å…ˆé˜Ÿåˆ—

---
åº”ç”¨ï¼š**å…³é”®è·¯å¾„åˆ†æ(critical path analysis)**

+ AOVç½‘ï¼šæ¯ä¸ªé¡¶ç‚¹è¡¨ç¤ºä¸€ä¸ªæ´»åŠ¨ï¼Œä¸”åŒ…æ‹¬éœ€è¦å®Œæˆè¯¥æ´»åŠ¨çš„æ—¶é—´ã€‚è¾¹(v, w) è¡¨ç¤º w å®Œæˆä¹‹å‰ï¼Œvå¿…é¡»å®Œæˆ

<div style="text-align: center; margin-top: 15px;">
<img src="Images/C9/Quicker_20240508_152235.png" width="70%" style="margin: 0 auto;">
</div>

+ **AOEç½‘(activity on edges networks)**

	<div style="text-align: center; margin-top: 15px;">
	<img src="Images/C9/Quicker_20240508_152702.png" width="70%" style="margin: 0 auto;">
	</div>

	è¡¨ç¤ºæ–¹æ³•ï¼š

	<div style="text-align: center; margin-top: 15px;">
	<img src="Images/C9/Quicker_20240508_140200.png" width="70%" style="margin: 0 auto;">
	</div>

	>æ³¨ï¼šå¿…è¦æ—¶éœ€è¦æ·»åŠ dummy edgeså’Œdummy nodesï¼Œé¿å…é”™è¯¯æˆ–ç¼ºå°‘çš„ä¾èµ–å…³ç³»äº§ç”Ÿ

<div style="text-align: center; margin-top: 15px;">
<img src="Images/C9/Quicker_20240508_140331.png" width="50%" style="margin: 0 auto;">
</div>

+ $EC[j]$ï¼šèŠ‚ç‚¹$v_j$ **æœ€æ—©**çš„å®Œæˆæ—¶é—´
+ $LC[j]$ï¼šèŠ‚ç‚¹$v_j$ **æœ€æ™š**çš„å®Œæˆæ—¶é—´

ğŸŒ°

<div style="text-align: center; margin-top: 15px;">
<img src="Images/C9/Quicker_20240508_140626.png" width="80%" style="margin: 0 auto;">
</div>

>æ³¨ï¼šè“å­—è¡¨ç¤ºECï¼Œçº¢å­—è¡¨ç¤ºLCï¼Œç»¿å­—è¡¨ç¤º*ç©ºé—²æ—¶é—´*ï¼ˆåé¢ä¼šè®²åˆ°ï¼‰

+ è®¡ç®—ECï¼šæ‰¾åˆ°ç¬¬ä¸€ä¸ªäº‹ä»¶åˆ°æœ€åä¸€ä¸ªäº‹ä»¶ä¹‹é—´*æœ€é•¿*çš„è·¯

	>æ³¨ï¼š å›¾å¦‚æœæ˜¯æœ‰ç¯çš„ï¼Œå› ä¸º**æ­£æˆæœ¬ç¯(positive-cost cycles)**çš„å­˜åœ¨ï¼Œè¿™ç§ç®—æ³•æ— æ³•å®ç°ã€‚ç„¶è€Œè¿™é‡Œå·²ç»è§„å®šæ˜¯æ— ç¯å›¾ï¼Œæ‰€ä»¥æ— éœ€æ‹…å¿ƒ

	ä»èµ·ç‚¹ $v_0$ å¼€å§‹ï¼Œå¯¹äºä»»æ„çš„ $a_i = <v, w>$ï¼Œæˆ‘ä»¬æœ‰

	$$
	EC[0] = 0 \quad EC[w] = \max\limits_{(v,w) \in E} \{EC[v] + C_{v, w}\}
	$$

	>æŒ‰**æ‹“æ‰‘åº**è®¡ç®—

+ è®¡ç®— LCï¼šä»ç»ˆç‚¹ $v_8$ å¼€å§‹ï¼Œå¯¹äºä»»æ„çš„ $a_i = <v, w>$ï¼Œæˆ‘ä»¬æœ‰

	$$
	LC[8] = EC[8] \quad LC[v] = \min\limits_{(v,w) \in E} \{LC[v] - C_{v, w}\}
	$$

	>æŒ‰**é€†å‘æ‹“æ‰‘åº**è®¡ç®—

+ $<v, w>$ çš„**ç©ºé—²æ—¶é—´(slack time)** = $LC[w] - EC[v] - C_{v, w}$
+ **å…³é”®æ´»åŠ¨(critical activity)**ï¼šç©ºé—²æ—¶é—´ä¸º0çš„æ´»åŠ¨
+ **å…³é”®è·¯å¾„(critical path)**ï¼šæ‰€æœ‰è¾¹çš„ç©ºé—²æ—¶é—´å‡ä¸º0çš„è·¯å¾„

### All-pairs Shortest Path Problem

å¯¹å›¾ä¸­ä»»æ„ä¸€å¯¹é¡¶ç‚¹ $v_i, v_j(i \ne j)$ï¼Œè¦æ±‚å®ƒä»¬çš„æœ€çŸ­è·¯å¾„ï¼Œæœ‰ä»¥ä¸‹æ–¹æ³•ï¼š

+ ä½¿ç”¨ $|V|$ æ¬¡**å•æºç®—æ³•**ï¼ˆæ¯”å¦‚ Dijkstraï¼‰ï¼Œæ—¶é—´å¤æ‚åº¦ $T = O(|V|^3)$ï¼Œåœ¨*ç¨€ç–å›¾*ä¸­è¿è¡Œè¾ƒå¿«
+ ç”¨ Chap 10 ç»™å‡ºçš„ç®—æ³•ï¼Œæ—¶é—´å¤æ‚åº¦ $T = O(|V|^3)$ï¼Œåœ¨*ç¨ å¯†å›¾*ä¸­è¿è¡Œè¾ƒå¿«ï¼Œè¿™é‡Œå°±ç•¥è¿‡äº†<span class="heimu">æˆ‘ä¹Ÿä¸çŸ¥é“æ˜¯ä»€ä¹ˆç®—æ³•(doge)</span>

## Network Flow Problems

è€ƒè™‘ä¸‹é¢çš„ç®¡é“ç½‘ç»œï¼š

<div style="text-align: center; margin-top: 15px;">
<img src="Images/C9/Quicker_20240508_142217.png" width="30%" style="margin: 0 auto;">
</div>

+ è¿™æ˜¯ä¸€ä¸ªæœ‰å‘å›¾ $G(V, E)$ï¼Œæ¯æ¡è¾¹çš„**å®¹é‡(capacity)**ä¸º $c_{v, w}$ï¼Œç»è¿‡è¯¥è¾¹çš„**æµé‡(flow)**ä¸å¾—è¶…è¿‡å®ƒçš„å®¹é‡
+ æˆ‘ä»¬ç§°èµ·ç‚¹ s ä¸º**æºç‚¹(source)**ï¼Œç»ˆç‚¹ t ä¸º**æ±‡ç‚¹(sink)**
+ å¯¹äºæ‰€æœ‰é¡¶ç‚¹ $v \notin \{s, t\}$ï¼Œæ€»æµå…¥ = æ€»æµå‡ºï¼Œå³ $\text{Total coming in}(v) \equiv \text{Total going out}(v)$ï¼Œä¹Ÿå°±æ˜¯è¯´é¡¶ç‚¹**ä¸å…·å¤‡å­˜å‚¨çš„èƒ½åŠ›**

ğŸ¯ï¼šç¡®å®šä» s åˆ° t çš„**æœ€å¤§æµ(maximum-flow)**

### Simple Algorithm

<div style="text-align: center; margin-top: 15px;">
<img src="Images/C9/Quicker_20240625_170820.png" width="70%" style="margin: 0 auto;">
</div>

æ³¨ï¼šä½¿ç”¨è¿™ä¸ªç®—æ³•æ—¶ï¼Œæˆ‘ä»¬éœ€è¦3å¼ å›¾ï¼š

+ åŸå›¾ $G$
+ **æµé‡(flow)å›¾** $G_f$ï¼šè¡¨ç¤ºç®—æ³•è¿è¡Œçš„æ¯ä¸ªé˜¶æ®µä¸­å·²ç»å¾—åˆ°çš„æµé‡ï¼Œåˆå§‹æƒ…å†µä¸‹æ¯æ¡è¾¹çš„æµé‡å‡ä¸º 0
+ **æ®‹é‡(residual)å›¾** $G_r$ï¼šè¡¨ç¤ºå¯¹äºå›¾ä¸­çš„æ¯æ¡è¾¹ï¼Œè¿˜å‰©ä¸‹å¤šå°‘æµé‡å¯ä»¥è¢«æ·»åŠ 

!!! note "æ­¥éª¤"

	1.  åœ¨**æ®‹é‡å›¾(residual graph)** $G_r$ ä¸­æ‰¾ä¸€æ¡ $s \rightarrow t$ çš„ç®€å•è·¯å¾„ï¼Œè¯¥è·¯å¾„è¢«ç§°ä¸º**å¢å¹¿è·¯å¾„(augmenting path)**
	2. å¢å¹¿è·¯å¾„çš„æµé‡ä¸ºè·¯å¾„ä¸Šçš„æ‰€æœ‰è¾¹ä¸­æœ€å°çš„æµé‡ï¼Œç”¨è¯¥æµé‡æ›´æ–°**æµé‡å›¾(flow graph)** $G_f$
	3. æ›´æ–° $G_r$ï¼Œå¹¶ç§»é™¤æµé‡ä¸º0çš„è¾¹
	4. å¦‚æœ $G_r$ä¸­è¿˜å­˜åœ¨ $s \rightarrow t$ çš„è·¯å¾„ï¼Œå›åˆ°æ­¥éª¤ 1ï¼Œå¦åˆ™ç»ˆæ­¢ç¨‹åº

???+ play "åŠ¨ç”»æ¼”ç¤º"

	<div style="text-align: center; margin-top: 15px;">
	<img src="Images/C9/8.gif" width="70%" style="margin: 0 auto;">
	</div>

!!! warning "é—®é¢˜"

	å¦‚æœæˆ‘ä»¬é‡‡ç”¨**è´ªå¿ƒ**çš„ç­–ç•¥ï¼Œå¯¹äºä¸Šå›¾ï¼Œæˆ‘ä»¬ä¼šå…ˆé€‰æ‹©$s \rightarrow a \rightarrow d \rightarrow t$ï¼Œè¿™æ ·å¾—åˆ°çš„æµé‡ä¸º 3ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºã€‚ç„¶è€Œï¼Œè¿™æ ·åšçš„è¯æˆ‘ä»¬å°±æ— æ³•å†æ‰¾åˆ°ç¬¬ 2 æ¡è·¯å¾„ï¼Œå› æ­¤æ€»æµé‡ä¸º3ï¼Œä¸æ»¡è¶³è¦æ±‚ã€‚å› æ­¤æˆ‘ä»¬éœ€è¦æ”¹è¿›ä¸Šè¿°ç®—æ³•ã€‚

	<div style="text-align: center; margin-top: 15px;">
	<img src="Images/C9/Quicker_20240508_154736.png" width="80%" style="margin: 0 auto;">
	</div>

### Solution

!!! info "æ”¹è¿›"

	è®©ç®—æ³•å…·å¤‡**æ’¤é”€(undo)**å†³ç­–çš„èƒ½åŠ›ï¼šå¯¹äºæµé‡å›¾ $G_f$ ä¸­çš„æ¯æ¡è¾¹ (v, w)ï¼Œå®ƒçš„æµé‡ä¸º $f_{v, w}$ï¼Œåœ¨**æ®‹é‡å›¾**ä¸­æ·»åŠ ä¸€æ¡åå‘çš„è¾¹ (w, v)ï¼Œå®ƒçš„æµé‡ä¹Ÿä¸º $f_{v, w}$

ä»¤ $f$ è¡¨ç¤ºå›¾ $G = (V, E)$ çš„æµé‡ï¼Œåˆ™æ®‹å·®å›¾çš„è¾¹çš„æƒé‡ä¸ºï¼š

$$
r(u, v) = \begin{cases}r(u, v) - f(u, v) & \text{if }(u, v) \in E \\ f(v, u) & \text{if }(v, u) \in E \\ 0 & \text{otherwise}\end{cases}
$$

???+ play "åŠ¨ç”»æ¼”ç¤º"

	<div style="text-align: center; margin-top: 15px;">
	<img src="Images/C9/9.gif" width="80%" style="margin: 0 auto;">
	</div>

æœ€ç»ˆæ•ˆæœï¼š

<div style="text-align: center; margin-top: 15px;">
<img src="Images/C9/Quicker_20240625_171232.png" width="80%" style="margin: 0 auto;">
</div>

>æ³¨ï¼šå¦‚æœè¾¹çš„å®¹é‡æ˜¯*æœ‰ç†æ•°*ï¼Œé‚£ä¹ˆè¯¥ç®—æ³•åœ¨ç»ˆæ­¢æ—¶æ€»èƒ½å¾—åˆ°ä¸€ä¸ªæœ€å¤§æµï¼ˆå›¾æœ‰**ç¯**çš„è¯ä¹Ÿå¯ä»¥ï¼‰

### Analysis

>å‰æï¼šæ‰€æœ‰è¾¹çš„å®¹é‡ä¸ºæ•´æ•°

æˆ‘ä»¬å¯ä»¥åˆ©ç”¨[**æ— æƒæœ€çŸ­è·¯å¾„ç®—æ³•**](#unweighted-shortest-paths)æ¥æ‰¾åˆ°**å¢å¹¿è·¯å¾„**
>æ—¶é—´å¤æ‚åº¦ $T = O(f \cdot |E|)$ï¼Œ$f$è¡¨ç¤ºæœ€å¤§æµé‡

ä½†å¯¹äºä»¥ä¸‹ç‰¹æ®Šæƒ…å†µï¼š

<div style="text-align: center; margin-top: 15px;">
<img src="Images/C9/Quicker_20240508_145431.png" width="60%" style="margin: 0 auto;">
</div>

å¦‚æœæˆ‘ä»¬éšæœºæŒ‘é€‰å¢å¹¿è·¯å¾„ï¼ŒæŒ‘åˆ°ä¸€æ¡åŒ…æ‹¬ $a \rightarrow b$ çš„è·¯å¾„ï¼Œå°±ä¼šäº§ç”Ÿé—®é¢˜ï¼š

>Random augmentations could continually augment along a path that includes the edge connected by a and b. If this were to occur repeatedly, 2,000,000 augmentations would be required, when we could get by with only 2.

!!! note "è§£å†³æ–¹æ³•"

	=== "æ³•1"

		åœ¨é€‰æ‹©å¢å¹¿è·¯å¾„æ—¶ï¼Œæ€»æ˜¯æŒ‘é€‰**å¯¹æµé‡æå‡æœ€å¤§**çš„è·¯å¾„
		
		å¦‚ä½•å®ç°ï¼šç¨å¾®æ”¹å˜ä¸€ä¸‹ Dijkstra ç®—æ³•

		æ—¶é—´å¤æ‚åº¦ï¼š
		
		$$
		\begin{align}
		T = & T_{augmentation} \cdot T_{find\ a\ path} \notag \\
		= & O(|E| \log cap_{max}) \cdot O(|E|\log |V|) \notag \\ 
		= & O(|E|^2 \log |V|) (\text{if } cap_{max} \text{ is a small integer}) \notag
		\end{align}
		$$

	=== "æ³•2"

		åœ¨é€‰æ‹©å¢å¹¿è·¯å¾„æ—¶ï¼ŒæŒ‘é€‰**è¾¹æœ€å°‘**çš„å¢å¹¿è·¯å¾„
		
		æ—¶é—´å¤æ‚åº¦ï¼š
		
		$$
		\begin{align}
		T = & T_{augmentation} \cdot T_{find\ a\ path} \notag \\ 
		= & O(|E|) \cdot O(|E| \cdot |V|)\quad (\text{unweighted shortest path algorithm}) \notag \\
		= & O(|E|^2 |V|) \notag
		\end{align}
		$$

### Supplements

+ æ›´ä¼˜çš„ç®—æ³•ï¼Œæ—¶é—´å¤æ‚åº¦å¯ä»¥å°†è‡³ $O(|E||V|\log(|V|^2/|E|))$å’Œ$O(|E||V| + |V|^{2 + \epsilon})$
+ å¯¹äºæŸäº›ç‰¹æ®Šæƒ…å†µï¼Œæ—¶é—´å¤æ‚åº¦è¿˜å¯ä»¥é™ä½ï¼šå¦‚æœé™¤äº†æºç‚¹å’Œæ±‡ç‚¹å¤–çš„æ‰€æœ‰é¡¶ç‚¹çš„å…¥è¾¹å®¹é‡ä¸º1ï¼Œæˆ–è€…å‡ºè¾¹å®¹é‡ä¸º 1ï¼Œé‚£ä¹ˆæœ€ä¼˜ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(|E||V|^{\frac{1}{2}})$
+ æ›´å¤æ‚çš„é—®é¢˜ï¼š*æœ€å°è´¹ç”¨æµé—®é¢˜(min-cost flow problem)*â€”â€”æ¯æ¡è¾¹ä¸ä»…æœ‰å®¹é‡ï¼Œè¿˜è¦è€ƒè™‘å•ä½æµé‡çš„è´¹ç”¨ã€‚ğŸ¯ï¼šè¦æ‰¾åˆ°æ‰€æœ‰æœ€å¤§æµé‡ä¸­çš„æœ€å°æˆæœ¬

## Minimum Spanning Tree

å®šä¹‰ï¼šå›¾ $G$ çš„**ç”Ÿæˆæ ‘(spanning tree)**æ˜¯ä¸€æ£µåŒ…å«æ‰€æœ‰é¡¶ç‚¹ $V(G)$ï¼ˆä½†ä¸ä¸€å®šåŒ…å«æ‰€æœ‰è¾¹ï¼‰çš„æ ‘

ğŸŒ°ï¼š

<div style="text-align: center; margin-top: 15px;">
<img src="Images/C9/Quicker_20240508_150633.png" width="60%" style="margin: 0 auto;">
</div>


å¦‚ä½•ç†è§£**æœ€å°ç”Ÿæˆæ ‘(minimum spanning tree)**ï¼Ÿ

+ â€œæ ‘â€ï¼šæ— ç¯ä¸”è¾¹çš„æ•°é‡ä¸º |V| - 1
>å› æ­¤å½“å›¾çš„è¾¹æ•° < |V| - 1æ—¶ï¼Œè¯¥å›¾ä¸å­˜åœ¨æœ€å°ç”Ÿæˆæ ‘

+ â€œæœ€å°â€ï¼šä¿è¯ç”Ÿæˆæ ‘çš„æ‰€æœ‰è¾¹çš„æƒé‡å’Œæœ€å°
+ â€œç”Ÿæˆâ€ï¼šè¦†ç›–æ‰€æœ‰çš„é¡¶ç‚¹
+ æœ€å°ç”Ÿæˆæ ‘å­˜åœ¨çš„**å……è¦æ¡ä»¶**æ˜¯å›¾$G$æ˜¯**è¿é€šçš„**
+ å¦‚æœåœ¨ç”Ÿæˆæ ‘ä¸­æ·»åŠ ä¸€æ¡è¾¹ï¼Œå°±ä¼šå½¢æˆä¸€ä¸ª*ç¯*
+ æœ€å°ç”Ÿæˆæ ‘æ˜¯å¹¶ä¸ä¸€å®šæ˜¯å”¯ä¸€çš„ï¼Œä½†æœ€å°ç”Ÿæˆæ ‘çš„**æ€»æƒé‡æ˜¯å”¯ä¸€çš„**

å¦‚ä½•æ±‚è§£ï¼Ÿâ€”â€”**è´ªå¿ƒç®—æ³•(greedy algorithm)**ï¼Œæ¯ä¸€æ­¥éƒ½é‡‡å–æœ€ä¼˜ç­–ç•¥ï¼Œä½†æœ‰ä»¥ä¸‹é™åˆ¶ï¼š

+ å¿…é¡»ä½¿ç”¨å›¾é‡Œé¢çš„è¾¹
+ å¿…é¡»ç”¨åˆ° $|V| - 1$ æ¡è¾¹
+ ä¸èƒ½å‡ºç°ç¯

### Prim's Algorithm

æ–¹æ³•ï¼šç”Ÿæˆä¸€æ£µæ ‘ï¼Œä¸ Dijkstra ç®—æ³•éå¸¸ç›¸ä¼¼ï¼Œé€‚ç”¨äº**ç¨ å¯†å›¾**ä¸­

+ åˆå§‹æƒ…å†µä¸‹ï¼Œå…ˆå°†ä¸€ä¸ªé¡¶ç‚¹ä½œä¸ºæ ‘çš„**æ ¹**æ”¾å…¥æ ‘å†…
+ åœ¨æ¯ä¸ªé˜¶æ®µï¼Œæ·»åŠ è¾¹(u, v)ï¼Œæ»¡è¶³ (u, v) çš„æƒé‡æ˜¯æ¥è‡ªå·²æœ‰ç”Ÿæˆæ ‘çš„é¡¶ç‚¹ u å’Œæ¥è‡ªç”Ÿæˆæ ‘å¤–çš„ v ä¹‹é—´çš„æ‰€æœ‰è¾¹ä¸­æƒé‡æœ€å°çš„é‚£æ¡ï¼Œä¸”ä¸äº§ç”Ÿç¯ï¼Œç„¶åå°†æ–°çš„é¡¶ç‚¹ væ·»åŠ è‡³æ ‘é‡Œ
+ é‡å¤ä¸Šè¿°æ­¥éª¤ï¼Œç›´è‡³æ‰€æœ‰é¡¶ç‚¹å‡åœ¨ç”Ÿæˆæ ‘å†…

???+ play "åŠ¨ç”»æ¼”ç¤º"

	<div style="text-align: center; margin-top: 15px;">
	<img src="Images/C9/10.gif" width="60%" style="margin: 0 auto;">
	</div>

ä¸Dijkstraä¸åŒä¹‹å¤„åœ¨äºï¼š

+ è¦ä¿å­˜ä¸¤ç±»å€¼ $d_v$ å’Œ $p_v$ï¼š
	+ $d_v$ï¼šè¿æ¥ $v$ å’Œå·²çŸ¥é¡¶ç‚¹çš„æœ€çŸ­è·¯çš„æƒé‡
	+ $p_v$ï¼šæœ€åä¸€ä¸ªå¯¼è‡´ $d_v$ æ”¹å˜çš„é¡¶ç‚¹

+ æ›´æ–°è§„åˆ™æ›´åŠ ç®€å•ï¼šå¯¹äºå·²ç»é€‰å…¥æ ‘å†…çš„é¡¶ç‚¹ $v$ï¼Œå®ƒçš„é‚»æ¥é¡¶ç‚¹ $w$ æ»¡è¶³ $d_w = \min(d_w, c_{w, v})$

>æ³¨ï¼šç”±äºè¿™æ˜¯æ— å‘å›¾ï¼Œå› æ­¤éœ€è¦ç”¨åˆ°<u>ä¸¤å¼ é‚»æ¥è¡¨</u>å­˜å‚¨å›¾

æ—¶é—´å¤æ‚åº¦ï¼š

+ ä¸ç”¨å †ï¼ˆé€‚ç”¨äº*ç¨ å¯†å›¾*ï¼‰ï¼š$O(|V|^2)$
+ *äºŒå‰å †*ï¼ˆé€‚ç”¨äº*ç¨€ç–å›¾*ï¼‰ï¼š$O(E\log|V|)$

??? code "ä»£ç å®ç°"

	``` c
	/*
	* Function: prim
	* --------------
	*   Find a minimum spanning tree for the given undirected
	*   graph by using Prim's algorithm
	*
	*   w_adj_mat: the weighted adjacency matrix
	*   n: the number of vertices
	* 
	*   returns: the total edge weights of the MST
	*/
	int prim(int w_adj_mat[MAX][MAX], int n)
	{
	int dist[MAX]; // distance from vertex i to the known part
	int prev[MAX]; // for tracing the edges of MST
	int known[MAX]; // 1 if the vertex i is checked, 0 if not

	// initialization
	for (int i = 0; i < n; i++)
	{
		dist[i] = INFINITY;
		prev[i] = -1;
		known[i] = 0;
	}

	dist[0] = 0; // start from vertex 0
	for (int k = 0; k < n; ++k)
	{
		// choose the vertex closest to the known part
		int min_d = INFINITY;
		int min_v = -1;
		for (int i = 0; i < n; i++)
		{
		if (!known[i] && dist[i] < min_d)
		{
			min_d = dist[i];
			min_v = i;
		}
		}

		// relaxation of vertices adjacent to the chosen one
		known[min_v] = 1;
		for (int i = 0; i < n; i++)
		{
		if (!known[i])
		{
			if (w_adj_mat[min_v][i] && dist[i] > w_adj_mat[min_v][i])
			{
			dist[i] = w_adj_mat[min_v][i];
			prev[i] = min_v;
			}
		}
		}
	}

	// total edge weights
	int total_w = 0;
	for (int i = 1; i < n; ++i)
		total_w += dist[i];
	return total_w;
	}
	```

### Kruskal's Algorithm

æ–¹æ³•ï¼šç»´æŒä¸€ç‰‡æ£®æ—ï¼ˆä¸€ç»„æ ‘ï¼‰ï¼Œé€‚ç”¨äº**ç¨€ç–å›¾**ä¸­

+ åˆå§‹æƒ…å†µä¸‹ï¼Œæœ‰ $|V|$ æ£µå•ä¸ªèŠ‚ç‚¹æ„æˆçš„æ ‘
+ æ·»åŠ ä¸€æ¡è¾¹ï¼Œå¯ä»¥åˆå¹¶ä¸¤æ£µæ ‘ã€‚å½“ç®—æ³•ç»“æŸæ—¶ï¼Œåº”å½“åªå‰©ä¸‹ä¸€æ£µæ ‘ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¾ˆè‡ªç„¶åœ°æƒ³åˆ°ä½¿ç”¨**å¹¶æŸ¥é›†**çš„ç®—æ³•
+ æŒ‘é€‰è¾¹ï¼ˆè¿™é‡Œå‡è®¾æŒ‘é€‰è¾¹ $(u, v)$ ï¼‰æ—¶è¦æ³¨æ„çš„ç»†èŠ‚ï¼š

	+ å¦‚æœ u, v åœ¨åŒä¸€ä¸ªé›†åˆå†…ï¼Œåˆ™ä¸èƒ½æ·»åŠ è¿™æ¡è¾¹ï¼ˆå¦åˆ™ä¼šå‡ºç°ç¯ï¼‰
	+ å¦åˆ™åŠ å…¥è¿™æ¡è¾¹ï¼Œä½¿ç”¨ `Union` ç®—æ³•å°†ä¸¤ä¸ªé›†åˆåˆå¹¶èµ·æ¥
+ ç”¨**å †**ç»´æŠ¤æœªè¢«æ£€éªŒè¿‡çš„æœ€å°çš„è¾¹ï¼Œæ¯å½“æ£€éªŒä¸€æ¡è¾¹æ—¶ï¼Œä½¿ç”¨ `DeleteMin` ç®—æ³•

å›¾ç¤ºï¼š

<div style="text-align: center; margin-top: 15px;">
<img src="Images/C9/Quicker_20240508_194123.png" width="80%" style="margin: 0 auto;">
</div>

ä¼ªä»£ç å®ç°ï¼š

``` c
void Kruskal(Graph G)
{
	T = { };
	while (T contains less than [V] - 1 edges && E is not empty)
	{
		choose a least cost edge(v, w) from E; // DeleteMin
		delete(v, w) from E;
		if ((v, w) does not create a cycle in T)
			add(v, w) to T; // Union/Find
		else
			discard(v, w);
	}
	if (T contains fewer than [V] - 1 edges)
		Error("No spanning tree");
}
```

??? code "æ­£å¼ä»£ç å®ç°"

	``` c
	void Kruskal(Graph G)
	{
		int EdgesAccepted;
		DisjSet S;
		PriorityQueue H;
		Vertex U, V;
		SetType Uset, Vset;
		Edge E;

		Initialize(S);
		ReadGraphIntoHeapArray(G, H);
		BuildHeap(H);

		EdgeAccepted = 0;
		while (EdgesAccepted < NumVertex - 1)
		{
			E = DeleteMin(H);  // E = (U, V)
			Uset = Find(U, S);
			Vset = Find(V, S);
			if (Uset != Vset)
			{
				// Accept the edge
				EdgesAccepted++;
				SetUnion(S, Uset, Vset);
			}
		}
	}
	```

ç”±äºæ¯æ¡è¾¹è¦å­˜ 3 ä¸ªå­—æ®µï¼Œå› æ­¤ç”¨*æŒ‡é’ˆæ•°ç»„*å­˜å‚¨è¾¹å¯èƒ½æ›´åŠ é«˜æ•ˆã€‚

æ—¶é—´å¤æ‚åº¦ï¼š$T = O(|E|\log |E|) = O(|E| \log |V|) \quad (|E| = O(|V|^2))$

## Applications of Depth-First Search

**æ·±åº¦ä¼˜å…ˆæœç´¢(depth-first search, DFS)**æ˜¯ä¸€ç§<u>å‰åºéå†</u>çš„æ³›åŒ–

+ æ ‘ï¼šæ—¶é—´å¤æ‚åº¦ $T = O(|E|)\ (|E| = \Theta(|V|))$
+ å›¾ï¼šæ³¨æ„è¦é¿å…ç¯(cycles)ï¼Œæ‰€ä»¥è®¿é—®è¿‡çš„é¡¶ç‚¹å°±è¦å¯¹å…¶**æ ‡è®°**ï¼Œç„¶åæ¥ç€è®¿é—®æœªè®¿é—®è¿‡çš„é¡¶ç‚¹ã€‚
+ å¦‚æœæ— å‘å›¾ä¸è¿é€šï¼Œæˆ–è€…æœ‰å‘å›¾ä¸æ˜¯å¼ºè¿é€šçš„ï¼Œé‚£ä¹ˆç”¨ä¸€æ¬¡ DFS æ— æ³•è®¿é—®æ‰€æœ‰é¡¶ç‚¹ï¼Œéœ€è¦å¯¹æœªæ ‡è®°çš„é¡¶ç‚¹å†ç”¨ä¸€æ¬¡ DFSï¼Œç›´è‡³æ‰€æœ‰é¡¶ç‚¹éƒ½è¢«æ ‡è®°ã€‚å› æ­¤ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º $O(|E| + |V|)$

ç¤ºæ„å›¾ï¼š

<div style="text-align: center; margin-top: 15px;">
	<img src="Images/C9/12.png" width="60%" style="margin: 0 auto;">
</div>

!!! code "ä»£ç æ¨¡æ¿ï¼ˆ**é€’å½’**ç‰ˆï¼‰"

	``` c
	void DFS(Vertex V)
	{
		visited[V] = true; // mark this vertex to void cycles
		for (each W adjacent to V)
			if (!visited[W])
				DFS(W);
	}
	```

!!! info "æ³¨"

	DFSä¹Ÿå¯ä»¥ç”¨**è¿­ä»£**æ–¹æ³•å®ç°ï¼Œå…·ä½“æ¥è¯´æˆ‘ä»¬å¯ä»¥ç”¨ä¸€ä¸ª**æ ˆ**æ¥å­˜æ”¾æ­£åœ¨æ¢ç´¢çš„è·¯å¾„ä¸Šçš„é¡¶ç‚¹ï¼Œå½“è¦æ¢ç´¢å¦ä¸€æ¡è·¯å¾„æ—¶ï¼Œå°±æŠŠä¸åœ¨è¯¥è·¯å¾„ä¸Šçš„èŠ‚ç‚¹ä»æ ˆå†…å¼¹å‡ºï¼Œç„¶åæ”¾å…¥åœ¨è¯¥è·¯å¾„ä¸Šçš„èŠ‚ç‚¹ã€‚


### Undirected Graphs

å½“ä¸”ä»…å½“ 1 æ¬¡ DFS èƒ½å¤Ÿéå†æ‰€æœ‰é¡¶ç‚¹æ—¶ï¼Œæ— å‘å›¾æ˜¯è¿é€šçš„

<div style="text-align: center; margin-top: 15px;">
<img src="Images/C9/2.gif" width="60%" style="margin: 0 auto;">
</div>

æˆ‘ä»¬å¯ä»¥ä½¿ç”¨**æ·±åº¦ä¼˜å…ˆç”Ÿæˆæ ‘(depth-first spanning tree)**æ¥å½¢è±¡å±•ç¤º DFS çš„è¿‡ç¨‹ã€‚å½“æˆ‘ä»¬å‘ç°æŸæ¡è¾¹(v, w) ä¸­çš„ w å·²è¢«æ ‡è®°è¿‡ï¼Œç”¨è™šçº¿ç”»å‡ºè¿™æ¡è¾¹ï¼Œç§°ä½œâ€œ**å›è¾¹(back edge)**â€ï¼Œè¡¨ç¤ºè¿™æ¡è¾¹ä¸åŒ…å«äºç”Ÿæˆæ ‘é‡Œï¼Œå¦‚å›¾æ‰€ç¤ºï¼š

<div style="text-align: center; margin-top: 15px;">
<img src="Images/C9/2.png" width="80%" style="margin: 0 auto;">
</div>

å¦‚æœæ— å‘å›¾ä¸è¿é€šï¼Œåˆ™å¯ä»¥ç”Ÿæˆ*æ·±åº¦ä¼˜å…ˆç”Ÿæˆæ£®æ—(depth-first spanning forest)*

ä»£ç å®ç°ï¼š
``` c
void ListComponents(Graph G)
{
	for (each V in G)
	{
		if (!visited[V])
			DFS(V);
			printf("\n");
	}
}
```

### Biconnectivity

+ å½“`G' = DeleteVertex(G, v)`è‡³å°‘æœ‰ 2 ä¸ªè¿é€šåˆ†é‡æ—¶ï¼Œç§°`v`ä¸º**å…³èŠ‚ç‚¹(articulation point)**æˆ–è€…**å‰²ç‚¹(cut vertex)**
>æ¢å¥è¯è¯´ï¼Œå…³èŠ‚ç‚¹çš„ç§»é™¤èƒ½å¤Ÿç ´åå›¾çš„è¿é€šæ€§

+ æ²¡æœ‰å…³èŠ‚ç‚¹çš„è¿é€šå›¾ `G` è¢«ç§°ä¸º**åŒè¿é€šå›¾(biconnected graph)**
>æ³¨ï¼šä¹‹æ‰€ä»¥è¢«ç§°ä¸ºåŒè¿é€šå›¾ï¼Œæ˜¯å› ä¸ºè‡³å°‘éœ€è¦ç§»é™¤ä¸¤ä¸ªåŠä»¥ä¸Šçš„é¡¶ç‚¹ï¼Œæ‰èƒ½å½¢æˆæœ‰å¤šä¸ªè¿é€šåˆ†é‡çš„å­å›¾

+ **åŒè¿é€šåˆ†é‡(biconnected component)**ï¼šæå¤§åŒè¿é€šå­å›¾

<div style="text-align: center; margin-top: 15px;">
<img src="Images/C9/Quicker_20240515_150434.png" width="80%" style="margin: 0 auto;">
</div>

>æ³¨ï¼šæ²¡æœ‰ä¸€æ¡è¾¹ä¼šåŒæ—¶å‡ºç°åœ¨å¤šä¸ªåŒè¿é€šåˆ†é‡ä¸­ã€‚å› æ­¤ E(G) è¢«åŒè¿é€šåˆ†é‡åˆ’åˆ†ï¼Œè€ŒåŒè¿é€šåˆ†é‡åˆè¢«å…³èŠ‚ç‚¹åˆ’åˆ†

!!! question "é—®é¢˜"

	å¯»æ‰¾æ— å‘è¿é€šå›¾ G ä¸­çš„**åŒè¿é€šåˆ†é‡çš„ä¸ªæ•° = å…³èŠ‚ç‚¹çš„ä¸ªæ•° + 1**


!!! note "è§£å†³æ–¹æ³•"

	å¦‚æœé¢˜ç›®ç»™å‡ºä¸€å¼ å›¾ï¼Œå«æˆ‘ä»¬æ‰¾å‡ºæ‰€æœ‰å…³èŠ‚ç‚¹ï¼Œè¿™åªè¦å¯¹æ¯ä¸ªé¡¶ç‚¹è¿›è¡Œåˆ¤æ–­ï¼ˆå‡è®¾ç§»é™¤æŸä¸ªé¡¶ç‚¹åï¼Œä¼šä¸ä¼šå¤šä¸€äº›è¿é€šåˆ†é‡ï¼‰ï¼Œå¾ˆå®¹æ˜“åœ°æ‰¾åˆ°æ‰€æœ‰å…³èŠ‚ç‚¹ã€‚ä½†ä¸‹é¢æˆ‘ä»¬è¦ç”¨ç¨‹åºæ¥è§£å†³è¿™ä¸€é—®é¢˜

	ç”¨åˆ°çš„å˜é‡ï¼š

	+ `Num(v)`ï¼šé¡¶ç‚¹ v çš„ DFS åºå·
	+ `Low(v)`ï¼šç”Ÿæˆæ ‘ä¸­é¡¶ç‚¹ v çš„æ‰€æœ‰å­©å­èŠ‚ç‚¹ä»¥åŠ v å›è¾¹ä¸Šçš„é¡¶ç‚¹ä¸­ `Num` çš„æœ€å°å€¼($\min(Num(w_i))$)ï¼ˆç”¨åˆ°**ååºéå†**ï¼‰

	---
	+ ä½¿ç”¨**æ·±åº¦ä¼˜å…ˆæœç´¢(depth first search)**å¾—åˆ°Gçš„ç”Ÿæˆæ ‘

		???+ play "åŠ¨ç”»æ¼”ç¤º"

			<div style="text-align: center; margin-top: 15px;">
			<img src="Images/C9/3.gif" width="70%" style="margin: 0 auto;">
			</div>

		æˆ‘ä»¬å¾—åˆ°ï¼š

		<div style="text-align: center; margin-top: 15px;">
		<img src="Images/C9/Quicker_20240515_152220.png" width="40%" style="margin: 0 auto;">
		</div>

		**å›è¾¹(back edges)**(u, v)ï¼šåœ¨å›¾ä¸­è€Œä¸åœ¨ç”Ÿæˆæ ‘å†…çš„è¾¹(u, v)ï¼Œå®ƒåæ˜ äº† u å’Œ v ä¹‹é—´æœ‰ç¥–è¾ˆå’Œåè¾ˆçš„å…³ç³»ã€‚å¦‚æœ u æ˜¯ v çš„ç¥–å…ˆï¼Œåˆ™ `Num(u) < Num(v)`ï¼›åä¹‹ `Num(u) > Num(v)`


		`Low(u)` çš„è®¡ç®—å…¬å¼ï¼š

		$$
		\begin{align}
		Low(u) = & \min\{Num(u), \min\{Low(w)\ |\ w \text{ is a child of }u\} \notag \\
		& , \min\{Num(w)\ |\ (u, w) \text{ is a back edge}\}\} \notag
		\end{align}
		$$

		è¡¨æ ¼ï¼ˆè®°å½•äº†`Num(v)`å’Œ`Low(v)`ï¼‰ï¼š

		<div style="text-align: center; margin-top: 15px;">
		<img src="Images/C9/Quicker_20240515_153001.png" width="70%" style="margin: 0 auto;">
		</div>

	+ æ‰¾åˆ°Gå†…çš„**å…³èŠ‚ç‚¹**

		+ å½“ä¸”ä»…å½“**æ ¹èŠ‚ç‚¹**è‡³å°‘æœ‰ 2 ä¸ªå­©å­æ—¶ï¼Œæ ¹èŠ‚ç‚¹ä¸ºå…³èŠ‚ç‚¹
		+ å½“ä¸”ä»…å½“**é™¤æ ¹èŠ‚ç‚¹å¤–çš„é¡¶ç‚¹u**è‡³å°‘æœ‰ 1 ä¸ªå­©å­ï¼Œä¸”è¯¥å­©å­ä¸å®ƒçš„ç¥–å…ˆä¹‹é—´æ²¡æœ‰å›è¾¹ï¼ˆå³`Low(child) >= Num(u)`ï¼‰æ—¶ï¼Œu ä¸ºå…³èŠ‚ç‚¹

??? code "ä»£ç å®ç°"

	``` c
	// Assign Num and compute Parents
	void AssignNum(Vertex V)
	{
		Vertex W;

		Num[V] = Counter++;
		Visited[V] = ture;
		for each W adjacent to V
			if (!Visited[W])
			{
				Parent[W] = V;
				AssignNum(W);
			}
	}

	// Assign Low; also check for articulation points
	void AssignLow(Vertex V)
	{
		Vertex W;

		Low[V] = Num[V]; // Rule 1
		for each W adjacent to V
		{
			if (Num[W] > Num[V])
			{
				AssignLow(W);
				if (Low[W] >= Num[V])
					printf("%v is an articulation point\n", v);
				Low[V] = Min(Low[V], Low[W]);  // Rule 3
			}
			else if (Parent[V] != W)
				Low[V] = Min(Low[V], Num[W]);  // Rule 2
		}
	}

	// Testing for articulation points in one depth-first search
	void FindArt(Vertex V)
	{
		Vertex W;

		Visited[V] = True
		Low[V] = Num[V] = Counter; // Rule 1
		for each W adjacent to V
		{
			if (!Visited[W])
			{
				Parent[W] = V;
				FindArt(W);
				if (Low[W] >= Num[V])
					printf("%v is an articulation point\n", v);
				Low[V] = Min(Low[V], Low[W]);  // Rule 3
			}
			else if (Parent[V] != W)
				Low[V] = Min(Low[V], Num[W]);  // Rule 2
		}
	}
	```

### Euler Circuits

+ **æ¬§æ‹‰è·¯(Euler tour)**ï¼šåœ¨ç¬”ä¸ç¦»çº¸çš„æƒ…å†µä¸‹ï¼Œå›¾ä¸Šçš„æ¯æ¡è¾¹å‡è¢«éå†ä¸€éï¼ˆä¸€ç¬”ç”»ï¼‰
+ **æ¬§æ‹‰ç¯(Euler circuit)**ï¼šåœ¨ç¬”ä¸ç¦»çº¸çš„æƒ…å†µä¸‹ï¼Œå›¾ä¸Šçš„æ¯æ¡è¾¹å‡è¢«éå†ä¸€éï¼Œä¸”æœ€åå›åˆ°èµ·ç‚¹çš„ä½ç½®

??? play "åŠ¨ç”»æ¼”ç¤º"

	<div style="text-align: center; margin-top: 15px;">
	<img src="Images/C9/4.gif" width="70%" style="margin: 0 auto;">
	</div>

åˆ¤æ–­æ–¹æ³•ï¼š

+ æ— å‘å›¾ï¼š
	+ å½“ä¸”ä»…å½“å›¾æ˜¯è¿é€šçš„ï¼Œä¸”**æ¯ä¸ªé¡¶ç‚¹çš„åº¦ä¸ºå¶æ•°**æ—¶ï¼Œå­˜åœ¨**æ¬§æ‹‰ç¯**
	+ å½“ä¸”ä»…å½“å›¾æ˜¯è¿é€šçš„ï¼Œä¸”**ä»…æœ‰ä¸¤ä¸ªé¡¶ç‚¹çš„åº¦ä¸ºå¥‡æ•°**æ—¶ï¼Œå­˜åœ¨**æ¬§æ‹‰è·¯**
+ æœ‰å‘å›¾ï¼š
	+ å½“ä¸”ä»…å½“å›¾æ˜¯å¼±è¿é€šçš„ï¼Œä¸”æ¯ä¸ªé¡¶ç‚¹çš„**å‡ºåº¦ = å…¥åº¦**æ—¶ï¼Œå­˜åœ¨**æ¬§æ‹‰ç¯**
	+ å½“ä¸”ä»…å½“å›¾æ˜¯å¼±è¿é€šçš„ï¼Œä¸”æœ‰ä¸”ä»…æœ‰**ä¸€ä¸ª**é¡¶ç‚¹çš„<u>å‡ºåº¦ = å…¥åº¦ + 1</u>ï¼Œæœ‰ä¸”ä»…æœ‰**ä¸€ä¸ª**é¡¶ç‚¹çš„<u>å…¥åº¦ = å‡ºåº¦ + 1</u>ï¼Œå…¶ä½™é¡¶ç‚¹çš„<u>å‡ºåº¦ = å…¥åº¦</u>æ—¶ï¼Œå­˜åœ¨**æ¬§æ‹‰è·¯**

åˆ©ç”¨**DFS**å¯»æ‰¾æ¬§æ‹‰ç¯ï¼š

???+ play "åŠ¨ç”»æ¼”ç¤º"

	<div style="text-align: center; margin-top: 15px;">
	<img src="Images/C9/5.gif" width="80%" style="margin: 0 auto;">
	</div>

+ ç”¨*é“¾è¡¨*ç»´æŠ¤è·¯å¾„
+ å¯¹äºæ¯ä¸ªé‚»æ¥è¡¨ï¼Œç»´æŠ¤ä¸€ä¸ªæŒ‡å‘æœ€åè¢«æ‰«æçš„è¾¹
+ æ—¶é—´å¤æ‚åº¦ $T = O(|E| + |V|)$

??? info "è¡¥å……ï¼š[**å“ˆå¯†é¡¿ç¯(Hamilton cycle)**](https://zh.wikipedia.org/wiki/%E5%93%88%E5%AF%86%E9%A1%BF%E5%9B%BE)"

	æ— å‘å›¾ä¸­èƒ½å¤Ÿè®¿é—®æ‰€æœ‰**é¡¶ç‚¹**çš„ç¯ã€‚

	??? code "ä»£ç å®ç°"

		``` c
		#include <stdio.h>
		#include <stdlib.h>

		#define SIZE 201
		#define PSIZE 2001

		typedef struct AdjVNode *PtrToAdjVNode; 
		struct AdjVNode{
			int AdjV;
			PtrToAdjVNode Next;
		};

		typedef struct Vnode{
			PtrToAdjVNode FirstEdge;
		} AdjList[SIZE];

		typedef struct GNode *PtrToGNode;
		struct GNode{  
			int Nv;
			int Ne;
			AdjList G;
		};
		typedef PtrToGNode LGraph;

		void HCycle(LGraph g, int p[ ]);

		int main()
		{
			int n, m, k, q;
			int i, j;
			int v1, v2;
			int path[PSIZE];
			LGraph Graph;
			PtrToAdjVNode cur1, cur2;

			Graph = (PtrToGNode)malloc(sizeof(struct GNode));
			scanf("%d%d", &n, &m);
			Graph->Nv = n;
			Graph->Ne = m;
			for (i = 0; i < n; i++)
			{
				Graph->G[i].FirstEdge = NULL;
			}

			for (i = 0; i < m; i++)
			{
				scanf("%d%d", &v1, &v2);
				cur1 = (PtrToAdjVNode)malloc(sizeof(struct AdjVNode));
				cur1->AdjV = v2;
				cur1->Next = Graph->G[v1 - 1].FirstEdge;
				Graph->G[v1 - 1].FirstEdge = cur1;
				cur2 = (PtrToAdjVNode)malloc(sizeof(struct AdjVNode));
				cur2->AdjV = v1;
				cur2->Next = Graph->G[v2 - 1].FirstEdge;
				Graph->G[v2 - 1].FirstEdge = cur2;
			}

			scanf("%d", &k);
			for (i = 0; i < k; i++)
			{
				scanf("%d", &q);
				for (j = 0; j < q; j++)
					scanf("%d", &path[j]);
				if (q != Graph->Nv + 1)
					printf("NO\n");
				else
					HCycle(Graph, path);
			}

			return 0;

		}

		void HCycle(LGraph g, int p[ ])
		{
			int i;
			int flag[SIZE];
			PtrToAdjVNode cur;

			if (p[0] != p[g->Nv])
			{
				printf("NO\n");
			}
			else
			{
				for (i = 0; i < g->Nv; i++)
					flag[i] = 0;
				for (i = 1; i < g->Nv + 1; i++)
				{
					if (flag[p[i - 1] - 1] == 1)
					{
						printf("NO\n");
						return;
					}
					cur = g->G[p[i - 1] - 1].FirstEdge;
					while (cur != NULL && cur->AdjV != p[i])
						cur = cur->Next;
					if (cur == NULL)
					{
						printf("NO\n");
						return;
					}
					flag[p[i - 1] - 1] = 1;
				}
				printf("YES\n");
			}
		} 
		```
