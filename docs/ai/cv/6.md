---
counter: true
---

# Image Stitching

??? example "例子"

    === "例1：全景图"

        <div style="text-align: center">
            <img src="images/lec6/1.png" width=40% />
        </div>

    === "例2：360° VR"

        <div style="text-align: center">
            <img src="images/lec6/2.png" width=60% />
        </div>


## Image Warping

之前介绍的图像过滤是改变图像的强度值(intensity)，而**图像扭曲**(image warping)旨在改变图像的**形状**(shape)。

<div style="text-align: center">
    <img src="images/lec6/3.png" width=50% />
</div>

**参数化**(parametric)（**全局**(global)）**扭曲**：

<div style="text-align: center">
    <img src="images/lec6/4.png" width=50% />
</div>

- 变换(transformation) $T$ 是一种坐标变换：$p' = T(p)$
- 例子：

    <div style="text-align: center">
        <img src="images/lec6/5.png" width=50% />
    </div>

各种变换的知识在[前面](2.md#primitives-and-transformations)（以及 [CG](../../software/cg/3.md) 中）介绍过了，如有遗忘可点击链接回顾。下面仅介绍**投影变换**（因为比较重要）。


### Projective Transformation

投影变换的**单应性**(homography)：

$$
\begin{bmatrix}x_i^{\prime}\\y_i^{\prime}\\1\end{bmatrix}\cong\begin{bmatrix}h_{00}&h_{01}&h_{02}\\h_{10}&h_{11}&h_{12}\\h_{20}&h_{21}&h_{22}\end{bmatrix}\begin{bmatrix}x_i\\y_i\\1\end{bmatrix}
$$

解得：

$$
\begin{gathered}x_{i}^{\prime}\begin{aligned}=\frac{h_{00}x_i+h_{01}y_i+h_{02}}{h_{20}x_i+h_{21}y_i+h_{22}}\end{aligned}\\y_i^\prime=\frac{h_{10}x_i+h_{11}y_i+h_{12}}{h_{20}x_i+h_{21}y_i+h_{22}}\end{gathered}
$$

- 单应性矩阵具有尺度不确定性（可以乘以任意标量），这意味着其自由度为 8
- 我们通常将向量 $\begin{bmatrix}h_{00} & h_{01} & \dots & h_{22}\end{bmatrix}$ 的长度限制为 1

通过改变投影平面，可以生成任意的合成相机视角（只要确保有**相同的投影中心**）。

<div style="text-align: center">
    <img src="images/lec6/6.png" width=40% />
</div>

???+ example "例子"

    <div style="text-align: center">
        <img src="images/lec6/7.png" width=60% />
    </div>

对于以下情况，两幅图像的变换是单应性：

- 相机围绕其固定中心旋转
- 相机中心移动且场景为一张平面


### Implementing the Warping

对于给定的坐标变换 $(x', y') = T(x, y)$ 和源图像 $f(x, y)$，如何计算变换后的图像 $g(x', y') = T(f(x, y))$？我们有以下几种方法：

<div style="text-align: center">
    <img src="images/lec6/8.png" width=50% />
</div>

- **前向扭曲**(forward warping)：将 $f(x, y)$ 的每个像素发送至对应在 $g(x', y')$ 上的位置 $(x', y') = T(x, y)$

    <div style="text-align: center">
        <img src="images/lec6/9.png" width=50% />
    </div>

- **逆向扭曲**(inverse warping)：从对应 $f(x, y)$ 上的位置 $(x, y) = T^{-1}(x, y)$ 上获取 $g(x', y')$ 的每个像素

    <div style="text-align: center">
        <img src="images/lec6/10.png" width=50% />
    </div>

无论何种采用方法，都会遇到一个问题：如果对应于另一张图像上的像素落在一些像素的中间而非某一个像素上，那么该如何处理呢？答案是根据邻居像素**插值**(interpolate)得到颜色值。


### Interpolation

插值方法有：

- 最近邻居：拷贝来自最近整数坐标上的像素值

    <div style="text-align: center">
        <img src="images/lec6/11.png" width=40% />
    </div>

- 四个邻居像素的加权和

    <div style="text-align: center">
        <img src="images/lec6/12.png" width=40% />
    </div>

- 双线性(bilinear)
- 双三次(bicubic)
- sinc


## Image Stitching

知识背景：

- 仿射变换和投影变换
- 异常点(outliers)：

    <div style="text-align: center">
        <img src="images/lec6/13.png" width=50% />
    </div>


### RANSAC

**RANSAC** 的思路是：

- 所有内点将在平移向量上达成一致
- 异常点之间彼此不一致
    - RANSAC 只保证存在 < 50% 的异常点

>“幸福的家庭都是相似的，不幸的家庭各有各的不幸。”
><div align=right>——列夫·托尔斯泰</div>

具体过程如下：

1. 选择 s 个样本点（通常 s 为拟合模型所需的最小采样点数）
2. 将模型（例如变换矩阵）拟合到这些样本点上
3. 计算大致拟合模型的内点数量
4. 重复 N 次
5. 选择拥有最多内点数量的模型

???+ example "例子"

    图中每个箭头表示一种模型：

    <div style="text-align: center">
        <img src="images/lec6/14.png" width=50% />
    </div>

最后一步：**最小二乘拟合**(least square fit)。对于上述例子就是：

<div style="text-align: center">
    <img src="images/lec6/15.png" width=50% />
</div>

???+ example "例子"

    === "例1"

        <div style="text-align: center">
            <img src="images/lec6/16.png" width=50% />
        </div>

    === "例2"

        <div style="text-align: center">
            <img src="images/lec6/17.png" width=50% />
        </div>

    === "例3"

        <div style="text-align: center">
            <img src="images/lec6/18.png" width=50% />
        </div>

    === "例4"

        <div style="text-align: center">
            <img src="images/lec6/19.png" width=40% />
        </div>


### Panoramas

创建全景图的步骤：

1. 将所有图像扭曲至参考图像
2. 将它们合并起来

<div style="text-align: center">
    <img src="images/lec6/20.png" width=50% />
</div>

然而，我们是否一定要将所有图像投影到一个平面上吗？

<div style="text-align: center">
    <img src="images/lec6/21.png" width=40% />
</div>

有时，我们可能希望构建 360° 的视野范围（完整的全景图），那么前面介绍的方法就失效了。

<div style="text-align: center">
    <img src="images/lec6/22.png" width=40% />
</div>

为此，我们引入一种新方法——**圆柱投影**(cylinderical projection)

<div style="text-align: center">
    <img src="images/lec6/23.png" width=40% />
</div>

$$
\begin{aligned}&x^{\prime}=rtan^{-1}(\frac{x}{f})\\&y^{\prime}=\frac{ry}{\sqrt{x^2+f^2}}\end{aligned}
$$

其中 $(x', y')$ 为圆柱坐标，$(x, y)$ 为图像坐标（原点位于图像中心），$r$ 是圆柱半径，$f$ 是焦距。

???+ example "例子"

    <div style="text-align: center">
        <img src="images/lec6/24.png" width=50% />
    </div>

圆柱全景图的创建步骤如下：

1. 将图像重新投影到圆柱上
2. 混合(blend)

<div style="text-align: center">
    <img src="images/lec6/25.png" width=30% />
</div>

那么如何计算圆柱上的变换呢？一个重要发现是：相机的旋转就是在圆柱上的**平移**。

组装全景图：将配对缝合在一起，混合，然后裁剪。

<div style="text-align: center">
    <img src="images/lec6/26.png" width=50% />
</div>

这一过程存在**漂移**(drift)的问题：

<div style="text-align: center">
    <img src="images/lec6/27.png" width=50% />
</div>

- 小误差会随时间积累
- 应用纠正，使得总和 = 0（对于 360° 全景图）

???+ example "例子：360° 全景图"

    === "例1"

        <div style="text-align: center">
            <img src="images/lec6/28.png" width=70% />
        </div>

    === "例2"

        <div style="text-align: center">
            <img src="images/lec6/29.png" width=60% />
        </div>