# Chap 4 Trees

## Preliminaries

### Definitions

+ **æ ‘(Trees)**ï¼šå®ƒæ˜¯ä¸€ç»„èŠ‚ç‚¹ï¼Œå¯ä»¥ä¸ºç©ºï¼Œå¦‚æœä¸ä¸ºç©ºï¼š
	+ åŒ…å«1ä¸ª**æ ¹èŠ‚ç‚¹(root)**$r$
	+ æœ‰0ä¸ªæˆ–å¤šä¸ª**å­æ ‘(subtrees)**$T_1, \dots, T_k$ï¼Œæ¯ä¸ªå­æ ‘çš„æ ¹èŠ‚ç‚¹éƒ½å’Œ$r$é€šè¿‡ä¸€æ¡**è¾¹(edge)** è¿æ¥
> æ³¨ï¼š
> + å­æ ‘ä¹‹é—´ä¸ä¼šç›¸äº’è¿æ¥ï¼Œå› æ­¤æ¯ä¸ªèŠ‚ç‚¹éƒ½æ˜¯æŸä¸ªå­æ ‘çš„æ ¹èŠ‚ç‚¹
> + å¯¹äºä¸€æ£µæœ‰$N$ä¸ªèŠ‚ç‚¹çš„æ ‘ï¼Œå®ƒæœ‰$N - 1$æ¡è¾¹
+ **åº¦(degree)**ï¼š
	+ ä¸€ä¸ª*èŠ‚ç‚¹*çš„åº¦æŒ‡çš„æ˜¯å®ƒ<u>æ‰€æœ‰å­æ ‘çš„ä¸ªæ•°</u>
	+ ä¸€æ£µ*æ ‘*çš„åº¦ä¸º$\max\limits_{\text{node } \in \text{ tree}}\{\text{degree(node)}\}$
+ **çˆ¶èŠ‚ç‚¹(parent)**ï¼šæœ‰å­æ ‘çš„èŠ‚ç‚¹ï¼Œ**å­©å­èŠ‚ç‚¹(children)**ï¼šçˆ¶èŠ‚ç‚¹å­æ ‘çš„æ ¹èŠ‚ç‚¹
+ **å…„å¼ŸèŠ‚ç‚¹(siblings)**ï¼šæœ‰ç›¸åŒçˆ¶èŠ‚ç‚¹çš„å­©å­èŠ‚ç‚¹
+ **å¶å­èŠ‚ç‚¹(leaf)**ï¼šåº¦ä¸º0çš„èŠ‚ç‚¹
+ ä»$n_1$åˆ°$n_k$**è·¯å¾„(path)**ï¼šä¸€ä¸ªåŒ…å«èŠ‚ç‚¹$n_1, n_2, \dots, n_k$==å”¯ä¸€==çš„åºåˆ—ï¼Œä½¿å¾—$n_i$æ˜¯$n_{i+1}$çš„çˆ¶èŠ‚ç‚¹($1 \le i < k$)
+ è·¯å¾„**é•¿åº¦(length)**ï¼šè·¯å¾„ä¸Š*è¾¹*çš„æ¡æ•°
+ **æ·±åº¦(depth)** of $n_i$ï¼šä»æ ¹èŠ‚ç‚¹å‡ºå‘çš„å”¯ä¸€çš„è·¯å¾„é•¿åº¦ï¼Œè§„å®š$Depth(root) = 0$
+ **é«˜åº¦(height)** of $n_i$ï¼šä»$n_i$åˆ°å¶å­ç»“ç‚¹çš„*æœ€é•¿*è·¯å¾„é•¿åº¦ï¼Œè§„å®š$Height(leaf) = 0$
$$\therefore height(root) = depth(deepest\text{ }leaf)$$
+ **ç¥–å…ˆ(ancestor)**ï¼šä»è¯¥èŠ‚ç‚¹åˆ°æ ¹èŠ‚ç‚¹çš„è·¯å¾„ä¸Šæ‰€æœ‰çš„èŠ‚ç‚¹
+ **åä»£(descendant)**ï¼šè¯¥èŠ‚ç‚¹æ‰€æœ‰å­æ ‘çš„èŠ‚ç‚¹
+ **å†…éƒ¨é¡¶ç‚¹(internal vertices)**ï¼šæœ‰å­©å­èŠ‚ç‚¹çš„é¡¶ç‚¹

### Implementation
#### List Representation

![](Quicker_20240320_173619.png)
> é—®é¢˜ï¼šæ¯ä¸ªèŠ‚ç‚¹çš„ç©ºé—´å¤§å°å–å†³äºå®ƒæœ‰å¤šå°‘ä¸ªå­æ ‘ï¼Œè¿™æ ·å®ç°èµ·æ¥å°±å¾ˆéº»çƒ¦

#### FirstChild-NextSibling Representation

![](./Images/C4/Quicker_20240421_204417.png)
> æ³¨ï¼šå¯¹äºåŒä¸€æ£µæ ‘ï¼Œè¿™ç§è¡¨ç¤ºå¹¶ä¸å”¯ä¸€ï¼Œå› ä¸ºæ ‘ä¸­å­©å­çš„é¡ºåºå¯ä»¥æ˜¯ä»»æ„çš„

### Application(File System)

*Directory listing in a hierarchical file system*
+ Unix ç³»ç»Ÿ
	![](Quicker_20240320_184217.png)
+ DOS ç³»ç»Ÿ
	![](Quicker_20240320_184308.png)
	> æ³¨æ„ï¼šåœ¨UNIXç³»ç»Ÿä¸­ä½äºæ·±åº¦$d_i$çš„æ–‡ä»¶ï¼Œåœ¨è½¬åŒ–ä¸ºDOSç³»ç»Ÿçš„è¡¨ç¤ºæ³•æ—¶éœ€è¦å°†å®ƒä»¬çš„åå­—ç¼©è¿›$d_i$ä¸ª`tab`é”®
	
ä»£ç å®ç°ï¼ˆ==å‰åºéå†==ï¼‰ï¼š
``` c 
static void ListDir(DirOfFile D, int Depth)
{
	if (D is legitimate entry)
	{
		PrintName(D, Depth);
		if (D is a directory)
			for (each child C of D)
				ListDir(C, Depth + 1);
	}
}
```
> æ³¨æ„ï¼š`Depth`å˜é‡æ˜¯ä¸åº”è¯¥è¢«ç”¨æˆ·çœ‹åˆ°çš„**å†…éƒ¨å˜é‡**ï¼Œéœ€è¦éšè—èµ·æ¥ã€‚ä¸€ç§è§£å†³æ–¹æ³•æ˜¯åƒä¸‹é¢é‚£æ ·å®šä¹‰å¦å¤–ä¸€ä¸ªå‡½æ•°

``` c
void ListDirectory(DirOfFile D)
{
	ListDir(D, 0);
}
```

*Calculating the size of a directory*
![](Quicker_20240320_185012.png)
ä»£ç å®ç°ï¼ˆ==ååºéå†==ï¼Œæ—¶é—´å¤æ‚åº¦$O(N)$ï¼‰
``` c
static int SizeDir(DirOrFile D)
{
	int TotalSize;
	TotalSize = 0;
	if (D is a legitimate entry)
	{
		TotalSize = FileSize(D);
		if (D is a directory)
			for (each child C of D)
				TotalSize += SizeDir(C);
	} // end if D is legal
	return TotalSize;
}
```

## Binary Trees

**Binary Tree(äºŒå‰æ ‘)**ï¼šæ¯ä¸ªèŠ‚ç‚¹æ‹¥æœ‰ä¸è¶…è¿‡ä¸¤ä¸ªå­©å­çš„æ ‘
![](Quicker_20240320_174545.png)

### Expression Trees(syntax trees)

^fc61a7
+ å…ˆå°†[[Chap 3 Lists, Stacks, and Queues#^01bb22|ä¸­ç¼€->åç¼€]]
+ ç„¶åç±»ä¼¼[[Chap 3 Lists, Stacks, and Queues#^f00de4|åç¼€è¡¨è¾¾å¼æ±‚è§£]]çš„æ–¹æ³•ï¼Œ==é‡åˆ°è¿ç®—ç¬¦æ—¶ï¼Œå°†å †æ ˆå†…çš„ä¸¤ä¸ªæ“ä½œæ•°å¼¹å‡ºï¼Œä¸è¿ç®—ç¬¦æ„å»ºä¸€æ£µæ ‘==ï¼Œå¯¹åº”å…³ç³»å¦‚ä¸‹ï¼š
	+ å·¦å­æ ‘ï¼šæ ˆé¡¶ä¸‹é¢çš„å…ƒç´ 
	+ æ ¹èŠ‚ç‚¹ï¼šè¿ç®—ç¬¦
	+ å³å­æ ‘ï¼šæ ˆé¡¶å…ƒç´ 
	å°†è¿™æ£µæ ‘å‹å…¥å †æ ˆä¸­ï¼Œé‡å¤ä¸Šè¿°æ­¥éª¤ç›´åˆ°éå†å®Œæ•´ä¸ªè¡¨è¾¾å¼

ç¤ºæ„å›¾ï¼š
![](./Images/C4/1.png)

ä»£ç å®ç°ï¼š
``` c
// from my work of project 2
Tree ExpTree(Queue q)
{
Â  Â  Tree ans; Â  // The final expression tree
Â  Â  Stack s; Â  Â // The stack for tree construction, containing the nodes or the trees
Â  Â  PtrToNode node, op1, op2, new; Â // node for all element in the queue; op1 and op2 are operands;and new is a new tree
Â  Â  PtrToQueue cur = q->front->next; Â // Starting from the second element, for the queue has a dummy header

Â  Â  s = CreateStack(); Â // Initialization
Â  Â  while (cur != NULL) Â // Traversing all the element in the queue
Â  Â  {
Â  Â  Â  Â  node = CreateNode(cur->var); Â // Creating node for every element in the queue
Â  Â  Â  Â  if(isalnum(cur->var[0]) || cur->var[0] == '-' && isalnum(cur->var[1])) Â // If it's a operand, push it into the stack
Â  Â  Â  Â  {
Â  Â  Â  Â  Â  Â  Push1(node, s);
Â  Â  Â  Â  Â  Â  // printf("%s\n", str);
Â  Â  Â  Â  }
Â  Â  Â  Â  else Â // If it's a operator,
Â  Â  Â  Â  {

Â  Â  Â  Â  Â  Â  op2 = Top1(s); Â // Obtaining the top two operands from the stack
Â  Â  Â  Â  Â  Â  Pop(s);
Â  Â  Â  Â  Â  Â  op1 = Top1(s);
Â  Â  Â  Â  Â  Â  Pop(s);
Â  Â  Â  Â  Â  Â  new = CreateTree(node, op1, op2); Â // Creating an expression (sub)tree
Â  Â  Â  Â  Â  Â  Push1(new, s);
Â  Â  Â  Â  }
Â  Â  Â  Â  cur = cur->next;
Â  Â  }
Â  Â  ans = Top1(s); // The remaining tree in the stack is the answer

Â  Â  return ans;

}
```

### Tree Traversals

> **æ ‘çš„éå†(tree traversals)**ï¼šå¯¹æ ‘çš„æ¯ä¸ªèŠ‚ç‚¹éƒ½è®¿é—®ä¸€æ¬¡ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º$O(N)$

![](Quicker_20240320_184009.png)

**å‰åºéå†(Preorder Traversal)**
``` c
void preorder(tree_ptr tree)
{
	if (tree)
	{
		visit(tree);
		for (each child C of tree)
			preorder(C);
	}
}
```

**ååºéå†(Postorder Traversal)**
``` c
void postorder(tree_ptr tree)
{
	if (tree)
	{
		for (each child C of tree)
			postorder(C);
		visit(tree);
	}
}
```

**å±‚åºéå†(Levelorder Traversal)** ^770ab3
``` c
void levelorder(tree_ptr tree)
{
	enqueue(tree);
	while (queue is not empty)
	{
		visit(T = dequeue());
		for (each child C of T)
			enqueue(C);
	}
}
```

**ä¸­åºéå†(Inorder Traversal)**
``` c
// Recursion
void inorder(tree_ptr tree)
{
	if (tree)
	{
		inorder(tree->Left);
		visit(tree->Element);
		inorder(tree->Right);
	}
}

// Iteration(using stack)
void iter_inorder(tree_ptr tree)
{
	Stack S = CreateStack(MAX_SIZE);
	for (;;)
	{
		for (; tree; tree = tree->left)
			Push(tree, S);
		tree = Top(S);
		Pop(S);
		if (!tree)
			break;
		visit(tree->Element);
		tree = tree->Right;
	}
}
```
>æ³¨ï¼šå…¥æ ˆé¡ºåºè²Œä¼¼æ˜¯å‰åºéå†ï¼ŸğŸ¤” æˆ‘è¿˜æ²¡éªŒè¯è¿‡â€¦â€¦

### Threaded Binary Trees

> å¯¹äºä¸€èˆ¬çš„äºŒå‰æ ‘ï¼Œå®ƒçš„å¶å­èŠ‚ç‚¹çš„å·¦å³æŒ‡é’ˆæŒ‡å‘`NULL`ï¼Œè¿™æµªè´¹äº†å¾ˆå¤šç©ºé—´ã€‚è€Œ**çº¿ç´¢äºŒå‰æ ‘(Threaded Binary Trees)** å¾ˆå¥½åœ°åˆ©ç”¨äº†é—²ç½®çš„èŠ‚ç‚¹ï¼Œå…·ä½“è§„åˆ™å¦‚ä¸‹ï¼š

+ å¦‚æœ`Tree->Left`ä¸ºç©ºï¼Œå°†å®ƒæŒ‡å‘**ä¸­åº**éå†ä¸­çš„==å‰ä¸€ä¸ªèŠ‚ç‚¹==
+ å¦‚æœ`Tree->Right`ä¸ºç©ºï¼Œå°†å®ƒæŒ‡å‘**ä¸­åº**éå†ä¸­çš„==åä¸€ä¸ªèŠ‚ç‚¹==
+ æœ‰ä¸€ä¸ª**å¤´èŠ‚ç‚¹**(dummy node)ï¼Œä½¿å¾—*æœ€å·¦è¾¹*å’Œ*æœ€å³è¾¹*å­©å­åˆ†åˆ«æŒ‡å‘è¿™ä¸ªèŠ‚ç‚¹çš„å·¦å³å­©å­

``` c
// ç»“æ„å£°æ˜
typedef struct ThreadedTreeNode *PtrTo ThreadedNode;
typedef struct PtrToThreadedNode ThreadedTree;
struct ThreadedTreeNode
{
	int LeftThread;      // if it is True, then Left
	TreadedTree Left;    // is a thread, not a child ptr
	ElementType Element;
	int RightThread;     // if it is True, then Right
	ThreadedTree Right;  // is a thread, not a child ptr
}
```

ğŸŒ°
![](Quicker_20240320_190628.png)

>æ³¨ï¼šè™½ç„¶è¿™é‡Œé»˜è®¤ä½¿ç”¨ä¸­åºéå†çš„å®šä¹‰ï¼Œä½†æˆ‘ä»¬ä¹Ÿå¯ä»¥å°†å…¶ä¿®æ”¹æˆ*å‰åº*æˆ–è€…*ååº*éå†çš„ç‰ˆæœ¬(æ¯”å¦‚å¯¹äºååºéå†ç‰ˆçš„çº¿ç´¢äºŒå‰æ ‘ï¼ŒæŸä¸ªèŠ‚ç‚¹ç©ºå‡ºæ¥çš„å·¦å­æ ‘æŒ‡å‘å®ƒåœ¨ååºéå†ä¸­çš„å‰ä¸€ä¸ªèŠ‚ç‚¹ï¼Œç©ºå‡ºæ¥çš„å³å­æ ‘æŒ‡å‘å®ƒåœ¨ååºéå†ä¸­çš„åä¸€ä¸ªèŠ‚ç‚¹)
### Special Cases

+ **æ­ªæ–œäºŒå‰æ ‘(Skewed Binary Trees)**ï¼š
![](./Images/C4/Quicker_20240327_190541.png)
+ **å®Œå…¨äºŒå‰æ ‘(Complete Binart Trees)**ï¼š
![](./Images/C4/Quicker_20240327_190602.png)
### Properties

+ ç¬¬$i$å±‚($i \ge 1$)æœ€å¤šæ‹¥æœ‰$2^{i - 1}$ä¸ªèŠ‚ç‚¹ï¼›æ·±åº¦ä¸º$k$çš„äºŒå‰æ ‘æœ€å¤šæœ‰$2^k - 1$ä¸ªèŠ‚ç‚¹($k \ge 1$)

+ å¯¹äºéç©ºçš„äºŒå‰æ ‘ï¼Œ$n_0 = n_2 + 1$ï¼Œå…¶ä¸­$n_0$æ˜¯å¶å­èŠ‚ç‚¹ä¸ªæ•°ï¼Œ$n_2$æ˜¯åº¦ä¸º2çš„èŠ‚ç‚¹ä¸ªæ•°

>ğŸŒŸè¯æ˜(å¯æ¨å¹¿è‡³nå‰æ ‘)ï¼š
>+ ä»¤$n_1$ä¸ºåº¦ä¸º1çš„èŠ‚ç‚¹ï¼Œ$n$ä¸ºèŠ‚ç‚¹æ€»æ•°ï¼Œåˆ™$n = n_0 + n_1 + n_2$
>+ ä»¤$B$ä¸ºè¾¹çš„æ¡æ•°ï¼Œåˆ™$n = B + 1$ï¼Œè€Œä¸”ä¸éš¾å‘ç°$B = n_1 + 2n_2$
>+ è”ç«‹ä¸Šè¿°ä¸‰ä¸ªæ–¹ç¨‹ï¼Œå¯ä»¥å¾—åˆ°$n_0 = n_2 + 1$($n_1$è¢«æ¶ˆæ‰äº†)

>â—é‡è¦æ¨è®ºï¼š$n$å‰æ ‘çš„å¶å­èŠ‚ç‚¹ä¸ªæ•°ä¸$n_1$æ— å…³ï¼š$n_0 = \sum\limits_{i = 2}^n (i - 1)n_i + 1$

>æ¨è®ºï¼šå¯¹äºä¸€æ£µå®Œå…¨äºŒå‰æ ‘ï¼Œæ˜“çŸ¥$n_1 = 0$æˆ–$1$ã€‚ç”±$n_0 = n_2 + 1$çŸ¥:
>+ å®Œå…¨äºŒå‰æ ‘æœ‰å¥‡æ•°ä¸ªèŠ‚ç‚¹æ—¶ï¼Œ$n_1 = 0$
>+ å®Œå…¨äºŒå‰æ ‘æœ‰å¶æ•°ä¸ªèŠ‚ç‚¹æ—¶ï¼Œ$n_1 = 1$

## The Search Tree ADT -- Binary Search Tree

### Definition

**äºŒå‰æœç´¢æ ‘(Binary Search Tree)** æ˜¯ä¸€æ£µäºŒå‰æ ‘ï¼Œå®ƒå¯ä»¥æ˜¯ç©ºæ ‘ï¼Œå¦‚æœéç©ºï¼Œåˆ™éµå¾ªä»¥ä¸‹è§„åˆ™ï¼š
+ æ¯ä¸ªèŠ‚ç‚¹æœ‰ä¸€ä¸ªæ•´æ•°çš„**é”®(key)**ï¼Œæ¯ä¸ªé”®äº’ä¸ç›¸åŒ
>è¿™é‡Œè¿™ä¹ˆå®šä¹‰æ˜¯ä¸ºäº†æ–¹ä¾¿åé¢çš„æ“ä½œï¼Œå®é™…ä¸Šé”®ä¸å¿…æ˜¯æ•´æ•°ï¼Œé”®ä¹Ÿå¯ä»¥ç›¸åŒ
+ éç©º**å·¦**å­æ ‘çš„é”®å¿…é¡»**å°äº**æ ¹ä¸Šçš„é”®
+ éç©º**å³**å­æ ‘çš„é”®å¿…é¡»**å¤§äº**æ ¹ä¸Šçš„é”®
+ å·¦å³å­æ ‘ä¹Ÿæ˜¯äºŒå‰æœç´¢æ ‘

>æ³¨ï¼š
>+ å¯¹äºäºŒå‰æœç´¢æ ‘çš„*åŒä¸€å±‚*ä»å·¦å¾€å³éå†ï¼Œè¿™äº›èŠ‚ç‚¹å¾—åˆ°å€¼ä¸€å®šæ˜¯*æœ‰åº*çš„
>+ äºŒå‰æœç´¢æ ‘çš„**ä¸­åºéå†**çš„ç»“æœæ˜¯**éé€’å‡**çš„
>+ ç»™å‡ºä¸€æ£µäºŒå‰æœç´¢æ ‘çš„**å‰åº***æˆ–è€…***ååº**éå†ï¼Œæ ¹æ®äºŒå‰æœç´¢æ ‘çš„å®šä¹‰ï¼Œæˆ‘ä»¬åº”å½“å¯ä»¥è¿˜åŸå‡ºè¿™æ£µæ ‘
>+ å¯¹äºä¸€æ£µ*å®Œå…¨*çš„äºŒå‰æœç´¢æ ‘ï¼Œå®ƒ**æœ€å°**çš„èŠ‚ç‚¹ä¸€å®šæ˜¯**å¶å­èŠ‚ç‚¹**ï¼Œæœ€å¤§çš„å°±ä¸ä¸€å®šäº†

### ADT

å¯¹è±¡ï¼šæ‹¥æœ‰0ä¸ªæˆ–å¤šä¸ªå…ƒç´ çš„æœ‰é™æœ‰åºè¡¨
è¿ç®—ï¼š
+ `SearchTree MakeEmpty(SearchTree T);`
+ `Position Find(ElementType X, SearchTree T);`
+ `Position FindMin(SearchTree T);`
+ `Position FindMax(SearchTree T);`
+ `SearchTree Insert(ElementType X, SearchTree T);`
+ `SearchTree Delete(ElementType X, SearchTree T);`
+ `ElementType Retrieve(Position P);`

### Implementations

``` c
// å£°æ˜éƒ¨åˆ†
#ifndef _Tree_H

struct TreeNode;
typedef struct TreeNode *Position;
typedef struct TreeNode *SearchTree;

SearchTree MakeEmpty(SearchTree T);
Position Find(ElementType X, SearchTree T);
Position FindMin(SearchTree T);
Position FindMax(SearchTree T);
SearchTree Insert(ElementType X, SearchTree T);
SearchTree Delete(ElementType X, SearchTree T);
ElementType Retrieve(Position P);

#endif // _Tree_H

// å†™åœ¨æ‰§è¡Œæ–‡ä»¶éƒ¨åˆ†
struct TreeNode
{
	ElementType Element;
	SearchTree Left;
	SearchTree Right;
}

// åˆå§‹åŒ–å¤„ç†ï¼Œæ—¶é—´å¤æ‚åº¦O(logN)
SearchTree MakeEmpty(SearchTree T)
{
	if (T != NULL)
	{
		MakeEmpty(T->Left);
		MakeEmpty(T->Right);
		free(T);
	}
	return NULL;
}
```

#### `Find`

``` c
Position Find(ElementType X, SearchTree T)
{
	if (T == NULL)
		return NULL; // not found in an empty tree
	if (X < T->Element)  // if smaller than root
		return Find(X, T->Left);  // search left subtree
	else if (X > T->Element)  // if larger than root
		return Find(X, T->Right);  // search right subtree
	else  // if X == root
		return T;  // found
}
```
>æ³¨ï¼š
>1. æ—¶é—´å¤æ‚åº¦$T(N)$å’Œç©ºé—´å¤æ‚åº¦$S(N)$éƒ½ç­‰äº$O(d)$ï¼Œå…¶ä¸­$d$ä¸ºæ ‘$X$çš„æ·±åº¦
>2. å‡½æ•°å¼€å§‹åº”å…ˆåˆ¤æ–­æ ‘æ˜¯å¦ä¸ºç©ºï¼Œå¦‚æœå°‘äº†è¿™å¥ï¼Œåé¢å°±ä¼šå‘ç”Ÿæ®µé”™è¯¯ï¼ˆåœ¨ä¸å­˜åœ¨çš„æ ‘ä¸­è·å–å…ƒç´ ï¼Œè¿™æ˜¯æœªå®šä¹‰çš„ï¼‰
>3. è¿™é‡Œçš„é€’å½’å‡½æ•°æ˜¯**å°¾é€’å½’(tail recursions)**ï¼Œå› æ­¤ç³»ç»Ÿä¼šè‡ªåŠ¨å°†é€’å½’ä¼˜åŒ–ä¸ºå¾ªç¯

``` c
// è¿­ä»£ç‰ˆFind()
Position Iter_Find(ElementType X, SearchTree T)
{
	while (T)
	{
		if (X == T->Element)
			return T;  // found
		if (X < T->Element)
			T = T->Left;  // move down along left path
		else
			T = T->Right;  // move down along right path
	} // end while-loop
	return NULL;  // not found
}
```

#### `FindMin`

``` c
Position FindMin(SearchTree T)
{
	if (T == NULL)
		return NULL;  // not found in an empty tree
	else if (T->Left == NULL)  // found left most
		return T;
	else
		return FindMin(T->Left); // keep moving to left
}
```


#### `FindMax`

``` c
Position FindMax(SearchTree T)
{
	if (T != NULL)
		while (T->Right != NULL)
			T = T->Right;  // keep moving to find right most
	return T;  // return NULL or the right most
}
```
>è¿™ä¸¤ä¸ªå‡½æ•°çš„æ—¶é—´å¤æ‚åº¦å‡ä¸º$O(d)$ï¼Œ$d$ä¸ºæ ‘çš„æ·±åº¦

#### `Insert`

>æ€æƒ³ï¼šæ‰§è¡Œè¿‡ç¨‹ç±»ä¼¼`Find`ï¼Œ
>+ å¦‚æœæ‰¾åˆ°äº†è¯¥èŠ‚ç‚¹ï¼Œå¯ä»¥ä¸åšä»»ä½•å¤„ç†ï¼Œä¹Ÿå¯ä»¥ç»™å®ƒçš„è®¡æ•°å™¨+1ï¼ˆå¦‚æœèŠ‚ç‚¹æœ‰è®¡æ•°å­—æ®µçš„è¯ï¼‰
>+ å¦åˆ™å°†æœ€åé‡åˆ°çš„**éç©ºèŠ‚ç‚¹** è§†ä¸ºæ–°èŠ‚ç‚¹çš„parentï¼Œç„¶åå°†æ–°èŠ‚ç‚¹æ’å…¥`NULL`çš„ä½ç½®ä¸Š

``` c
SearchTree Insert(ElementType X, SearchTree T)
{
	if (T == NULL)  // Create and return a one-node tree
	{
		T = (SearchTree)malloc(sizeof(struct TreeNode));
		if (T == NULL)
			 FatalError("Out of space!!!");
		else
		{
			T->Element = X;
			T->Left = T->Right = NULL;
		}
	}  // End create a one-node tree
	else
	{
		if (X < T->Element)
			T->Left = Insert(X, T->Left);
		else if (X > T->Element)
			T->Right = Insert(X, T->Right);
		// Else X is in the tree already, we'll do nothing
	}
	return T; // Don't forget this line!!
}
```
>æ—¶é—´å¤æ‚åº¦ï¼š$O(d),d$çš„æ„æ€åŒå‰

>ğŸ¤”æ€è€ƒï¼šå¯ä¸å¯ä»¥è¿™æ ·ç®€åŒ–ä¸€ä¸‹æ’å…¥å‡½æ•°â€”â€”å°†å‡½æ•°è¿”å›ç±»å‹æ”¹ä¸º`void`ï¼Œç„¶ååœ¨ç¬¬ä¸€ä¸ª`else`ä¸­ä¸é‡‡ç”¨èµ‹å€¼è¯­å¥ï¼Œæœ€åä¹Ÿä¸è¿”å›`T`
>
>ç­”æ¡ˆï¼šæ˜¾ç„¶ä¸å¯ä»¥ã€‚å¦‚æœæœ€åæ²¡æœ‰åœ¨æ ‘ä¸­æ‰¾åˆ°è¦æ’å…¥çš„èŠ‚ç‚¹ï¼Œé‚£ä¹ˆå°±éœ€è¦æ–°å»ºä¸€æ£µå­æ ‘ã€‚å¦‚æœå»ºå®Œè¿™æ£µæ ‘åæ—¢ä¸è¿”å›å®ƒï¼Œä¹Ÿæ²¡æœ‰å°†å®ƒèµ‹å›å»ï¼Œé‚£ä¹ˆè¿™æ£µå­æ ‘çš„çˆ¶èŠ‚ç‚¹æ— æ³•ä¸å®ƒå»ºç«‹è”ç³»ï¼Œå› æ­¤å»ºäº†ä¹Ÿç­‰äºç™½å»ºã€‚


#### ğŸŒŸ`Delete`

è¿™æ˜¯äºŒåˆ†æœç´¢æ ‘ä¸­æœ€éš¾å¤„ç†çš„éƒ¨åˆ†ã€‚æˆ‘ä»¬è¦å¤„ç†æœ‰ä¸‰ç§æƒ…å†µï¼š
+ å¶å­ç»“ç‚¹
+ æœ‰ä¸€ä¸ªå­©å­
+ ==æœ‰ä¸¤ä¸ªå­©å­==

å…¶ä¸­å‰ä¸¤ç§æƒ…å†µçš„å®ç°è¾ƒä¸ºç®€å•ï¼Œæœ€åçš„æƒ…å†µè¾ƒä¸ºå¤æ‚ï¼Œå…·ä½“åˆ†æå¦‚ä¸‹ï¼š

+ åˆ é™¤**å¶å­èŠ‚ç‚¹**ï¼šç›´æ¥å°†å®ƒçš„çˆ¶è¾ˆèŠ‚ç‚¹è¿æ¥åˆ°ç©ºèŠ‚ç‚¹ä¸Š
+ åˆ é™¤**åº¦ä¸º1**çš„èŠ‚ç‚¹ï¼šç”¨è¯¥èŠ‚ç‚¹çš„å­èŠ‚ç‚¹æ›¿æ¢å®ƒè‡ªèº«
+ åˆ é™¤**åº¦ä¸º2**çš„èŠ‚ç‚¹ï¼š
	+ ç”¨è¯¥èŠ‚ç‚¹**å·¦å­æ ‘çš„æœ€å¤§èŠ‚ç‚¹**æˆ–**å³å­æ ‘çš„æœ€å°èŠ‚ç‚¹** ï¼ˆæŒ‘ä¸€ç§ï¼‰æ›¿æ¢å®ƒè‡ªèº«
	>è§£é‡Šï¼šä»¥å³å­æ ‘æœ€å°èŠ‚ç‚¹ä¸ºä¾‹ï¼Œå°†å…¶ä½œä¸ºæ–°çš„çˆ¶èŠ‚ç‚¹ï¼Œå› ä¸ºå®ƒæ—¢æ»¡è¶³æ¯”å·¦å­æ ‘æ‰€æœ‰èŠ‚ç‚¹å¤§ï¼ˆå³å­æ ‘çš„èŠ‚ç‚¹>å·¦å­æ ‘çš„èŠ‚ç‚¹ï¼‰ï¼Œåˆæ»¡è¶³æ¯”æ–°çš„å³å­æ ‘æ‰€æœ‰èŠ‚ç‚¹å°ï¼ˆå®ƒåŸæœ¬å°±æ˜¯å³å­æ ‘æœ€å°çš„èŠ‚ç‚¹ï¼‰
	
	+ ä»å­æ ‘ä¸­åˆ é™¤ç”¨æ¥æ›¿æ¢çš„èŠ‚ç‚¹
	>æ³¨æ„ç”¨æ¥æ›¿æ¢çš„èŠ‚ç‚¹çš„åº¦ä¸è¶…è¿‡1

``` c
// è¿™é‡Œåˆ é™¤åº¦ä¸º2çš„èŠ‚ç‚¹æ—¶é‡‡ç”¨æ‹¿å³å­æ ‘æœ€å°èŠ‚ç‚¹æ›¿æ¢çš„æ–¹æ³•
SearchTree Delete(ElementType X, SearchTree T)
{
	Position TmpCell;
	if (T == NULL)
		Error("Element not found");
	else
	{
		if (X < T->ELement)  // Go left
			T->Left = Delete(X, T->Left);
		else if (X > T->Element)  // Go right
			T->Right = Delete(X, T->Right);
		else  // Found element to be deleted
		{
			if (T->Left && T->Right)  // Two children
			{  // Replace with smallest in right subtree
				TmpCell = FindMin(T->Right);
				T->Element = TmpCell->Element;
				T->Right = Delete(T->Element, T->Right);
			}  // End if 
			else  // One or zero child
			{
				TmpCell = T;
				if (T->Left == NULL)  // Also handles 0 child
					T = T->Right;
				else if (T->Right == NULL)
					T = T->Left;
				free(TmpCell);  // End else 1 or 0 child
			}
		}
	} 
	return T;
}
```
>æ—¶é—´å¤æ‚åº¦ï¼š$O(h), h$æ˜¯æ ‘çš„é«˜åº¦

>æ˜¾ç„¶ï¼Œè¿™ç§åˆ é™¤çš„æ“ä½œæ•ˆç‡ä¸é«˜
>
>æ”¹è¿›æ–¹æ³•ï¼šå¦‚æœåˆ é™¤æ“ä½œç”¨çš„ä¸å¤šï¼Œå¯ä»¥é‡‡ç”¨**lazy deletion**çš„æ–¹æ³•â€”â€”ä¸ºæ¯ä¸ªèŠ‚ç‚¹æ·»åŠ ä¸€ä¸ª`flag`å­—æ®µï¼Œæ¥æ ‡è®°èŠ‚ç‚¹æ˜¯å¦è¢«åˆ é™¤ã€‚å› æ­¤æˆ‘ä»¬å¯ä»¥ä¸å¿…é€šè¿‡é‡Šæ”¾èŠ‚ç‚¹çš„ç©ºé—´çš„æ–¹å¼æ¥åˆ é™¤èŠ‚ç‚¹ï¼›è€Œä¸”å¦‚æœæˆ‘ä»¬é‡æ–°æ’å…¥å·²ç»åˆ é™¤çš„èŠ‚ç‚¹ï¼Œåˆ™ä¸å¿…ä½¿ç”¨`malloc()`åˆ†é…å†…å­˜,å› è€Œèƒ½å¤Ÿæé«˜ç¨‹åºçš„æ•ˆç‡ã€‚å¾ˆå¤šæ•°æ®åº“éƒ½æ˜¯è¿™ä¹ˆåšçš„ã€‚

### Average-Case Analysis

é€šè¿‡è®¡ç®—å‘ç°ï¼Œæ ‘çš„æ‰€æœ‰èŠ‚ç‚¹çš„å¹³å‡æ·±åº¦ä¸º$O(logN)$ï¼Œè¯æ˜è¿‡ç¨‹è§æ•™æ$P_{108}$

 äºŒåˆ†æœç´¢æ ‘çš„å¤§å°å–å†³äº==æ’å…¥çš„é¡ºåº==å’Œ==åˆ é™¤==æ“ä½œ
+ æ’å…¥ï¼šå¦‚æœé¡ºåºä¸å¤Ÿéšæœºï¼ˆæœ€åçš„æƒ…å†µï¼šå‡åºï¼‰ï¼Œåˆ™æ ‘ä¼š**é€€åŒ–**æˆä¸€ä¸ªé“¾è¡¨
+ åˆ é™¤ï¼šä»¥æ›¿æ¢ä¸ºå³å­æ ‘æœ€å°èŠ‚ç‚¹ä¸ºä¾‹ï¼Œè¿‡å¤šçš„åˆ é™¤æ“ä½œä¼šå¯¼è‡´å³å­æ ‘ä¸æ–­ç¼©å°ï¼Œå·¦å­æ ‘çš„è§„æ¨¡ä¼šå¤§äºå³å­æ ‘ï¼Œç ´åäº†æ ‘çš„å¹³è¡¡

è§£å†³æ–¹æ¡ˆï¼ˆä¸‹å­¦æœŸADSä¼šè®²ï¼‰ï¼š
+ AVLæ ‘
+ splayæ ‘

## Problems


> 1-2. In a binary search tree which contains several integer keys including 4, 5, and 6, if 4 and 6 are on the same level, then 5 must be their parent.

**F**
5ä¸ä¸€å®šæ˜¯4, 6çš„ç›´æ¥çˆ¶èŠ‚ç‚¹ï¼Œå®ƒå¯èƒ½æ˜¯4, 6çš„ç¥–å…ˆï¼Œæ¯”å¦‚5å’Œ4ä¸­é—´æ”¾ä¸ª3ï¼Œ5å’Œ6ä¸­é—´æ”¾ä¸ª7ï¼Œæ­¤æ—¶4, 6è¿˜æ˜¯å¤„åœ¨åŒä¸€å±‚ï¼Œä½†å®ƒä»¬çš„çˆ¶èŠ‚ç‚¹ä¸æ˜¯5

---
>2-2. If a general treeÂ TÂ is converted into a binary treeÂ BT, then which of the followingÂ BTÂ traversals gives the same sequence as that of the post-order traversal ofÂ T?
>A. Pre-order traversal
>B. In-order traversal
>C. Post-order traversal
>D. Level-order traversal

**B**
è¿™ä¸ªå…‰æƒ³æˆ‘ä¹Ÿæƒ³ä¸å¥½ï¼Œè¦ç”»ä¸€ä¸‹å›¾æ‰çŸ¥é“ã€‚ä½†ä¸ºäº†è§£é¢˜é€Ÿåº¦ï¼Œè¿™ä¸ªå¯ä»¥å…ˆæ­»è®°ã€‚

>è¡¥å……ï¼šæ™®é€šæ ‘çš„å‰åº = è½¬åŒ–æˆäºŒå‰æ ‘çš„å‰åº
>æ™®é€šæ ‘æ²¡æœ‰ä¸­åºâ€¦â€¦

---
>quiz3-R1-1. The worst cast time complexity of Binary Search is alwaysÂ O(logn)Â whereÂ nÂ is the number of sorted integers.

**F**
==è¦è€ƒè™‘å­˜å‚¨æ–¹å¼==ï¼šå‡è®¾æˆ‘ç”¨**é“¾è¡¨**å­˜å‚¨äºŒåˆ†æŸ¥æ‰¾æ ‘ï¼Œé‚£ä¹ˆæŸ¥æ‰¾çš„æ—¶é—´å¤æ‚åº¦å°±ä¸å¯èƒ½æ˜¯$O(\log n)$äº†


---
**6-1 Isomorphic**

Two trees,Â `T1`Â andÂ `T2`, areÂ **isomorphic**Â ifÂ `T1`Â can be transformed intoÂ `T2`Â by swapping left and right children of (some of the) nodes inÂ `T1`. For instance, the two trees in Figure 1 are isomorphic because they are the same if the children of A, B, and G, but not the other nodes, are swapped. Give a polynomial time algorithm to decide if two trees are isomorphic.

![](https://images.ptausercontent.com/37)  
Figure 1

Format of functions:

```c++
int Isomorphic( Tree T1, Tree T2 );
```

whereÂ `Tree`Â is defined as the following:

```c++
typedef struct TreeNode *Tree;
struct TreeNode {
    ElementType Element;
    Tree  Left;
    Tree  Right;
};
```

The function is supposed to return 1 ifÂ `T1`Â andÂ `T2`Â are indeed isomorphic, or 0 if not.

**Sample program of judge:**

```c++
#include <stdio.h>
#include <stdlib.h>

typedef char ElementType;

typedef struct TreeNode *Tree;
struct TreeNode {
    ElementType Element;
    Tree  Left;
    Tree  Right;
};

Tree BuildTree(); /* details omitted */

int Isomorphic( Tree T1, Tree T2 );

int main()
{
    Tree T1, T2;
    T1 = BuildTree();
    T2 = BuildTree();
    printf(â€œ%d\nâ€, Isomorphic(T1, T2));
    return 0;
}

/* Your function will be put here */
```

**Sample Output 1 (for the trees shown in Figure 1):**

```out
1
```

**Sample Output 2 (for the trees shown in Figure 2):**

```
0
```

![](https://images.ptausercontent.com/38)  
Figure2

my code
``` c
int Isomorphic( Tree T1, Tree T2 )
{
    int cnt[4];

    if (T1 == NULL && T2 == NULL)
        return 1;
    else if (T1 == NULL || T2 == NULL)
        return 0;
    else if (T1->Element == T2->Element)
    {
        cnt[0] = Isomorphic(T1->Left, T2->Left);
        cnt[1] = Isomorphic(T1->Right, T2->Right);
        cnt[2] = Isomorphic(T1->Left, T2->Right);
        cnt[3] = Isomorphic(T1->Right, T2->Left);
        if (cnt[0] && cnt[1] || cnt[2] && cnt[3])
            return 1;
    }
        
    return 0;
}
```

---
**7-1 ZigZagging on a Tree**

Suppose that all the keys in a binary tree are distinct positive integers. A unique binary tree can be determined by a given pair of postorder and inorder traversal sequences. And it is a simple standard routine to print the numbers in level-order. However, if you think the problem is too simple, then you are too naive. This time you are supposed to print the numbers in "zigzagging order" -- that is, starting from the root, print the numbers level-by-level, alternating between left to right and right to left. For example, for the following tree you must output: 1 11 5 8 17 12 20 15.

![zigzag.jpg](https://images.ptausercontent.com/337cbfb0-a7b2-4500-9664-318e9ffc870e.jpg)

Input Specification:

Each input file contains one test case. For each case, the first line gives a positive integer N (â‰¤30), the total number of nodes in the binary tree. The second line gives the inorder sequence and the third line gives the postorder sequence. All the numbers in a line are separated by a space.

Output Specification:

For each test case, print the zigzagging sequence of the tree in a line. All the numbers in a line must be separated by exactly one space, and there must be no extra space at the end of the line.

Sample Input:

```in
8
12 11 20 17 1 15 8 5
12 20 17 11 15 8 5 1
```

Sample Output:

```out
1 11 5 8 17 12 20 15
```

my code(revised)
``` c
#include <stdio.h>
#include <stdlib.h>

#define SIZE 31

typedef struct node * PtrToNode;
typedef PtrToNode tree;
struct node
{
    int data;
    PtrToNode left;
    PtrToNode right;
};

int inorder[SIZE], postorder[SIZE];

tree CreateTree(int in[], int post[], int n);
void Traversal(tree t);

int main()
{
    int n;
    int i, j;
    tree tree;

    scanf("%d", &n);
    for (i = 0; i < n; i++)
        scanf("%d", &inorder[i]);
    for (i = 0; i < n; i++)
        scanf("%d", &postorder[i]);
        
    tree = CreateTree(0, n - 1, n - 1);
    Traversal(tree);

    return 0;
}

// çŸ¥é“ä¸­åºå’Œååºéå†æ„é€ ä¸€æ£µæ ‘
tree CreateTree(int in[], int post[], int n)
{
    PtrToNode node;
    int root;
    int i;

	if (!n)
		return NULL;

	root = post[n - 1];
	for (i = 0; i < n && in[i] != root; i++);

	node = (PtrToNode)malloc(sizeof(struct node));
	node->data = root;
	node->left = CreateTree(in, post, i);
	node->right = CreateTree(in + i + 1, post + i, n - i - 1);
	

    return node;
}

// æ€è·¯ï¼šä½¿ç”¨ä¸¤ä¸ªå †æ ˆ(å †æ ˆå¯ä»¥æ”¹å˜é¡ºåº)ï¼Œä¸€ä¸ªå­˜ä»å³å¾€å·¦éå†çš„é‚£å±‚èŠ‚ç‚¹(stack1)ï¼Œå¦ä¸€ä¸ªå­˜ä»å·¦å¾€å³éå†çš„é‚£å±‚èŠ‚ç‚¹(stack2)ï¼Œäº¤æ›¿è¿›è¡Œï¼Œç›´åˆ°ä¸¤ä¸ªå †æ ˆå‡ä¸ºç©ºç»“æŸ
void Traversal(tree t)
{
    PtrToNode stack1[SIZE], stack2[SIZE];
    int cnt = 0, flag = 1;
    int top1, top2;

    top1 = top2 = -1;
    stack1[++top1] = (PtrToNode)malloc(sizeof(struct node));
    stack1[top1] = t;
    while (top1 != -1 || top2 != -1)
    {   
        if (cnt % 2 == 0)
        {
            while (top1 != -1)
            {
                if (flag)
                {
                    printf("%d", stack1[top1]->data);
                    flag = 0;
                }
                else
                    printf(" %d", stack1[top1]->data);
                if (stack1[top1]->right != NULL)
                {
                    stack2[++top2] = (PtrToNode)malloc(sizeof(struct node));
                    stack2[top2] = stack1[top1]->right;
                }
                if (stack1[top1]->left != NULL)
                {
                    stack2[++top2] = (PtrToNode)malloc(sizeof(struct node));       
                    stack2[top2] = stack1[top1]->left;
                }
                free(stack1[top1--]);
            }
        }
        else
        {
            while (top2 != -1)
            {
                printf(" %d", stack2[top2]->data);
                if (stack2[top2]->left != NULL)
                {
                    stack1[++top1] = (PtrToNode)malloc(sizeof(struct node));
                    stack1[top1] = stack2[top2]->left;
                }

                if (stack2[top2]->right != NULL)
                {
                    stack1[++top1] = (PtrToNode)malloc(sizeof(struct node));                    
                    stack1[top1] = stack2[top2]->right;
                }
                free(stack2[top2--]);
            }
        }
        cnt++;
    }
    printf("\n");
}
```
>æˆ‘æ„Ÿè§‰å¥½åƒæ²¡æœ‰å¿…è¦åœ¨`Traversal()`å‡½æ•°é‡Œä½¿ç”¨`malloc()`ï¼Œå› ä¸ºæˆ‘å·²ç»å¼€äº†å¤§å°ç¡®å®šçš„æ•°ç»„äº†ğŸ¤”