# Chap 9 Graph Algorithm

## Definitions

+ **G(V, E)**ï¼š*G*è¡¨ç¤º**å›¾**(graph)ï¼Œ*V = V(G)* è¡¨ç¤ºå…³äº**é¡¶ç‚¹(vertices)** çš„æœ‰é™éç©ºé›†åˆï¼Œ*E = E(G)* è¡¨ç¤ºå…³äº**è¾¹(edges/arcs)** çš„æœ‰é™é›†åˆ
+ **æ— å‘å›¾(undirected graph)**ï¼š$(v_i, v_j) = (v_j, v_i)$è¡¨ç¤ºç›¸åŒçš„è¾¹
+ **æœ‰å‘å›¾(directed graph, digraph)**ï¼š$<v_i, v_j> \ne <v_j, v_i>$
	>$<v_i, v_j>$ï¼š![](./Images/C9/Quicker_20240417_200539.png)

>é™åˆ¶ï¼š
>+ **è‡ªç¯(self loop)** æ˜¯éæ³•çš„ï¼š![](./Images/C9/Quicker_20240417_200725.png)
>+ ä¸è€ƒè™‘**å¤šé‡å›¾(multigraph)** ï¼ˆä¸¤ä¸ªèŠ‚ç‚¹é—´æœ‰å¤šæ¡è¾¹ï¼‰çš„æƒ…å†µ![](./Images/C9/Quicker_20240417_200917.png)

+ **å®Œå…¨å›¾(complete graph)**ï¼šæœ‰æœ€å¤§æ•°é‡çš„è¾¹çš„å›¾ï¼ˆæ¯å¯¹é¡¶ç‚¹éƒ½æœ‰ç›´æ¥ç›¸è¿çš„è¾¹ï¼‰
	+ æ— å‘å›¾ï¼š$V = n \quad E = C^2_n = \frac{n(n - 1)}{2}$
		![](./Images/C9/Quicker_20240417_201101.png)
	+ æœ‰å‘å›¾ï¼š$V = n \quad E = P^2_n = n(n - 1)$
		![](./Images/C9/Quicker_20240417_201159.png)
+ **é‚»æ¥(adjacent)**
	+ æ— å‘å›¾ï¼šå¦‚æœ$(v_i, v_j)$å­˜åœ¨ï¼Œåˆ™ç§°$v_i, v_j$æ˜¯*é‚»æ¥çš„*![](./Images/C9/Quicker_20240417_201534.png)
	+ æœ‰å‘å›¾ï¼šå¦‚æœ$<v_i, v_j>$å­˜åœ¨ï¼Œåˆ™ç§°$v_i$==åˆ°==$v_j$æ˜¯*é‚»æ¥çš„*ï¼Œæˆ–è€…è¯´$v_j$==æ¥è‡ª==$v_i$æ˜¯*é‚»æ¥çš„*
		![](./Images/C9/Quicker_20240417_201543.png)
+ **å­å›¾(subgraph)**$G' \subset G$ï¼Œ$V(G') \subseteq V(G) \wedge E(G') \subseteq E(G)$
+ ä»$v_p$åˆ°$v_q$çš„**è·¯å¾„(path)**($\subset G$)ï¼š$\{v_p, v_{i1}, v_{i2}, \dots, v_{in}, v_q\}$ï¼Œä½¿å¾—$(v_p, v_{i1}), (v_{i1}, v_{i2}), \dots, (v_{in}, v_q)$æˆ–è€…$<v_p, v_{i1}>, <v_{i1}, v_{i2}>, \dots, <v_{in}, v_q> \subset E(G)$
+ è·¯å¾„çš„**é•¿åº¦(length)**ï¼šè·¯å¾„ä¸Šè¾¹çš„æ¡æ•°
+ **ç®€å•è·¯å¾„(simple path)**ï¼šå¯¹äºä¸Šè¿°è·¯å¾„ï¼Œ$v_{i1}, v_{i2}, \dots, v_{in}$æ˜¯ä¸åŒçš„(ä¸ä¼šå¤šæ¬¡ç»è¿‡åŒä¸€é¡¶ç‚¹)
+ **ç¯(cycle)**ï¼šå¯¹äºä¸€æ¡ç®€å•è·¯å¾„ï¼Œèµ·ç‚¹ä¸ç»ˆç‚¹ç›¸åŒï¼Œå³$v_p = v_q$
+ **è¿é€š(connected)**
	+ æ— å‘å›¾ï¼š
		+ å¯¹äºä¸¤ä¸ªé¡¶ç‚¹$v_i, v_j$è€Œè¨€ï¼Œå¦‚æœå®ƒä»¬ä¹‹é—´å­˜åœ¨ä¸€æ¡è·¯å¾„ï¼Œåˆ™ç§°å®ƒä»¬æ˜¯*è¿é€šçš„*
		+ å¯¹äºæ•´å¼ æ— å‘å›¾$G$è€Œè¨€ï¼Œå¦‚æœå›¾å†…ä¸¤ä¸ªä¸åŒçš„èŠ‚ç‚¹ä¹‹é—´ç›¸äº’è¿é€šï¼Œåˆ™ç§°æ•´å¼ å›¾æ˜¯*è¿é€šçš„*
		>å¯¹äº$n$ä¸ªé¡¶ç‚¹çš„æ— å‘å›¾ï¼Œæœ€å°‘éœ€è¦$n - 1$æ¡è¾¹æ¥å®ç°æ•´å¼ å›¾çš„è¿é€š
		+ æ— å‘å›¾$G$çš„(è¿é€š)**åˆ†é‡(component)**ï¼š*æå¤§*è¿é€šå­å›¾(ä¸€å¼ å›¾ä¸­ä»…æœ‰1ä¸ª)
		+ *æ ‘(tree)* æ˜¯è¿é€šä¸” *æ— ç¯(acyclic)* çš„å›¾

	+ æœ‰å‘å›¾ï¼š
		+ **æœ‰å‘æ— ç¯å›¾(directed acyclic graph, DAG)**
		+ **å¼ºè¿é€š(strongly connected)** æœ‰å‘å›¾$G$ï¼šå¯¹äº$V(G)$ä¸­çš„æ¯å¯¹é¡¶ç‚¹$v_i, v_j$ï¼Œå­˜åœ¨ä»$v_i$åˆ°$v_j$==å’Œ==ä»$v_j$åˆ°$v_i$çš„æœ‰å‘è·¯å¾„
		+ **å¼±è¿é€š(weakly connected)** æœ‰å‘å›¾ï¼šåœ¨ä¸è€ƒè™‘æ–¹å‘çš„æƒ…å†µä¸‹(å³æ— å‘å›¾)ï¼Œæ•´å¼ å›¾æ˜¯è¿é€šçš„(å³å¯¹äº$V(G)$ä¸­çš„æ¯å¯¹é¡¶ç‚¹$v_i, v_j$ï¼Œå­˜åœ¨ä»$v_i$åˆ°$v_j$==æˆ–==ä»$v_j$åˆ°$v_i$çš„æœ‰å‘è·¯å¾„)
		>å¯¹äº$n$ä¸ªé¡¶ç‚¹çš„*å¼±è¿é€šæœ‰å‘å›¾*ï¼Œæœ€å°‘éœ€è¦$n - 1$æ¡è¾¹æ¥å®ç°æ•´å¼ å›¾çš„è¿é€š
		+ **å¼ºè¿é€šåˆ†é‡(strongly connected component)** ï¼š*æå¤§*å¼ºè¿é€šå­å›¾
		+ **å¼±è¿é€šåˆ†é‡(weakly connected component)** ï¼š*æå¤§*å¼±è¿é€šå­å›¾

	>æ³¨ï¼šå¯¹äºä¸€ä¸ªä»…æœ‰ä¸€ä¸ªé¡¶ç‚¹çš„å›¾ï¼Œå®ƒè‡ªèº«å°±æ˜¯è¿é€šåˆ†é‡
+ **åº¦(degree)**ï¼š*Degree(v)*ï¼Œä¸é¡¶ç‚¹vç›¸è¿çš„è¾¹æ•°
	å¯¹äºä¸€ä¸ªæœ‰å‘å›¾$G$è€Œè¨€ï¼Œåº¦åˆ†ä¸º**å…¥åº¦(in-degree)** å’Œ**å‡ºåº¦(out-degree)**ï¼Œä¾‹å¦‚ï¼š
	![](./Images/C9/Quicker_20240417_203628.png)
	å‡å¦‚$G$æœ‰$v$ä¸ªé¡¶ç‚¹å’Œ$e$æ¡è¾¹ï¼Œé‚£ä¹ˆ$e = \dfrac{\sum\limits_{i = 0}^{n - 1}d_i}{2}$ï¼Œå…¶ä¸­$d_i = \text{degree}(v_i)$
	>æ³¨ï¼šå¯¹äºæœ‰å‘å›¾è€Œè¨€ï¼Œ==æ‰€æœ‰é¡¶ç‚¹å…¥åº¦ä¹‹å’Œ = æ‰€æœ‰é¡¶ç‚¹å‡ºåº¦ä¹‹å’Œ==

### Representation of Graph

>æ³¨ï¼šæœ‰æˆåƒä¸Šä¸‡ä¸­è¡¨ç¤ºå›¾çš„æ–¹æ³•ï¼Œè¿™é‡Œåªåˆ—å‡ºæœ€å¸¸ç”¨çš„å‡ ç§ã€‚å¯ä»¥æ ¹æ®å…·ä½“æƒ…å†µè®¾è®¡å‡ºç›¸åº”çš„è¡¨ç¤ºæ³•

æ³•ä¸€ï¼š**é‚»æ¥çŸ©é˜µ(adjacency matrix)**

å¯¹äºä¸€å¼ å…·æœ‰$n(n \ge 1)$ä¸ªèŠ‚ç‚¹çš„å›¾$G(V, E)$ï¼Œå®šä¹‰é‚»æ¥çŸ©é˜µ$adj\_mat [i] [j]$ä¸º
$$
adj\_mat[i][j] = \begin{cases}1 & \text{if } (v_i, v_j) \text{ or } <v_i, v_j> \in E(G) \\ 0 & \text{otherwise}\end{cases}
$$
æ‰€ä»¥ä¹Ÿå°±æœ‰ï¼š
$$
\text{degree}(i) = \begin{cases}\sum\limits_{j = 0}^{n - 1} adj\_mat[i][j] & \text{if G is undirected} \\ \sum\limits_{j = 0}^{n - 1} adj\_mat[i][j] + \sum\limits_{j = 0}^{n - 1}adj\_mat[j][i] & \text{if G is directed} \end{cases}
$$

ä¸éš¾çœ‹å‡ºï¼Œå¦‚æœ$G$æ˜¯æ— å‘çš„ï¼Œåˆ™è¯¥é‚»æ¥çŸ©é˜µæ˜¯å¯¹ç§°çš„ï¼Œå› æ­¤æµªè´¹äº†ä¸€åŠçš„ç©ºé—´å’Œæ—¶é—´ï¼ˆå¤æ‚åº¦ï¼š$\Theta(|V|^2)$ï¼‰
>ä½†æ˜¯ç”¨åœ¨*ç¨ å¯†(dense)* å›¾($|E| = \Theta(|V|^2)$)ä¸­æ˜¯æ¯”è¾ƒåˆé€‚çš„

æˆ‘ä»¬å¯ä»¥é€šè¿‡ä¸‹é¢è¿™ç§æ–¹æ³•æ¥èŠ‚çœä¸€åŠçš„ç©ºé—´(å°†*ä¸‹ä¸‰è§’çŸ©é˜µ*å­˜å…¥ä¸€ç»´æ•°ç»„ä¸­)ğŸ‘‡
$adj\_mat[n(n+1)/2] = \{a_{11}, a_{21}, \dots, a_{n1}, \dots, a_{nn}\}$ï¼Œå…¶ä¸­$a_{ij}$çš„ç´¢å¼•ä¸º$\frac{i(i-1)}{2} + j$

---
æ³•äºŒï¼š**é‚»æ¥è¡¨(adjacency lists)**

æ¥çœ‹ä¸ªğŸŒ°ï¼š
å¦‚ä½•å­˜å‚¨è¿™å¼ å›¾ï¼Ÿ![](./Images/C9/Quicker_20240417_205817.png)
+ é‚»æ¥çŸ©é˜µï¼š$adj\_mat = \begin{bmatrix}0 & 1 & 0 \\ 1 & 0 & 1 \\ 0 & 0 & 0\end{bmatrix}$
+ é‚»æ¥è¡¨ï¼š![](./Images/C9/Quicker_20240417_210032.png)
>æ³¨ï¼šèŠ‚ç‚¹çš„é¡ºåºå¹¶ä¸é‡è¦

$\therefore$ å¯¹äºæ— å‘å›¾$G$ï¼Œç©ºé—´$S = n$ä¸ªå¤´ + $2e$ä¸ªèŠ‚ç‚¹ = $(n + 2e)$ä¸ªæŒ‡é’ˆ + $2e$ä¸ªæ•´å‹

æ—¶é—´å¤æ‚åº¦$T = E(G) = O(|V| + |E|)$ï¼Œé€‚åˆç”¨äº*ç¨€ç–(sparse)* å›¾($|E| < \Theta(|V|^2)$)
>æ³¨ï¼šäº‹å®ä¸Šï¼Œé‚»æ¥è¡¨å¯ä»¥èƒœä»»å„ç§å›¾çš„å­˜å‚¨

å¯¹äºæ— å‘å›¾ï¼ŒDegree(i) = graph[i] ä¸­èŠ‚ç‚¹çš„ä¸ªæ•°

è€Œå¦‚æœ$G$æ˜¯æœ‰å‘çš„ï¼Œæˆ‘ä»¬éœ€è¦æ‰¾åˆ°in-degree(i)
	+ æ³•1ï¼šé€†è½¬é‚»æ¥é“¾è¡¨çš„åšæ³•
		![](./Images/C9/Quicker_20240417_210654.png)
	+ æ³•2ï¼šç”¨*å¤šé“¾è¡¨(multilist)* è¡¨ç¤ºé‚»æ¥çŸ©é˜µ$adj\_mat[i][j]$
		![](./Images/C9/Quicker_20240417_210838.png)
> å°½ç®¡å¤šé“¾è¡¨çš„è¡¨ç¤ºçœ‹èµ·æ¥æŒºä¼˜é›…ï¼Œä½†å®ç°èµ·æ¥ç›¸å½“å¤æ‚ï¼ˆå›å¿†[[Chap 3 Lists, Stacks, and Queues#^222af4|ä¹‹å‰çš„ä¾‹å­]]ï¼‰ï¼Œå› æ­¤æ›´æ¨èæ³•1

>è¡¥å……ï¼šæœ‰æ—¶é¡¶ç‚¹çš„å€¼ä¸ä¸€å®šæ˜¯æ•´æ•°ï¼Œä¹Ÿæœ‰å¯èƒ½æ˜¯å­—ç¬¦ä¸²ï¼Œè¿™æ—¶éœ€è¦ç»´æŠ¤ä¸€å¼ ä»å­—ç¬¦ä¸²æ˜ å°„åˆ°æ•´æ•°ç´¢å¼•çš„è¡¨æ ¼ï¼Œåœ¨å›¾ä¸­ç”¨ç´¢å¼•ä»£æ›¿å­—ç¬¦ä¸²

---
æ³•ä¸‰ï¼šé‚»æ¥å¤šé‡è¡¨(adjacency multilist)
>æ³¨ï¼šè¿™ä¸ªä¸ä½œè¦æ±‚ï¼Œè®¤è¯†å³å¯

åœ¨ä¹‹å‰çš„é‚»æ¥è¡¨é‡Œï¼Œå¯¹äºæ¯æ¡è¾¹$(v_i, v_j)$ï¼Œæˆ‘ä»¬ä¼šæœ‰ä¸¤ä¸ªèŠ‚ç‚¹ï¼š
![](./Images/C9/Quicker_20240417_211329.png)

é€šè¿‡æ”¹è¿›ï¼Œå°†è¿™ä¸¤ä¸ªèŠ‚ç‚¹ç»“åˆåˆ°ä¸€èµ·ï¼Œ![](./Images/C9/Quicker_20240417_211529.png)

äºæ˜¯å°±æœ‰å¦‚ä¸‹è¡¨ç¤ºæ–¹æ³•ï¼š
![](./Images/C9/Quicker_20240417_211427.png)
>markè¡¨ç¤ºæŸä¸€æ¡è¾¹

ğŸŒ°
![](./Images/C9/Quicker_20240417_211622.png)

>è§‚å¯Ÿå‘ç°ï¼Œåœ¨æ²¡æœ‰è€ƒè™‘markå­˜å‚¨çš„æƒ…å†µä¸‹ï¼Œè¿™ç§è¡¨ç¤ºæ³•çš„å ç”¨ç©ºé—´ä¸é‚»æ¥è¡¨å®Œå…¨ä¸€æ ·ã€‚è™½ç„¶å®ƒçš„ç©ºé—´å¤æ‚åº¦ç•¥å¾®é«˜äº†ç‚¹ï¼Œä½†æ˜¯åœ¨æŸäº›æƒ…å†µä¸‹(æ¯”å¦‚æ£€éªŒæŸæ¡è¾¹åè¿˜è¦æ£€éªŒä¸‹ä¸€æ¡è¾¹)æ¯”è¾ƒæœ‰åˆ©

---
æœ‰æ—¶ï¼Œæˆ‘ä»¬ä¼šé‡åˆ°**åŠ æƒè¾¹(weighted edges)** çš„æƒ…å†µï¼Œå¤„ç†æ–¹å¼å¦‚ä¸‹ï¼š
+ é‚»æ¥çŸ©é˜µï¼š$adj\_mat[i][j] = \text{weight}$
+ é‚»æ¥è¡¨/é‚»æ¥å¤šé‡è¡¨ï¼šä¸ºæ¯ä¸ªèŠ‚ç‚¹æ·»åŠ æƒé‡çš„å­—æ®µ

## Topological Sort

**AOVç½‘(activity on vertex network)**ï¼šå¯¹äºæœ‰å‘å›¾$G$ï¼Œ$V(G)$è¡¨ç¤ºæ´»åŠ¨ï¼Œ$E(G)$è¡¨ç¤ºä½æ¬¡å…³ç³»
>æ¯”å¦‚è¿™å¼ å›¾è¡¨ç¤ºC1æ˜¯C3çš„å‰ç½®æ´»åŠ¨ï¼š![](./Images/C9/Quicker_20240417_212653.png)

å¦‚æœä»$i$åˆ°$j$æœ‰ä¸€æ¡è·¯å¾„ï¼Œåˆ™ç§°$i$æ˜¯$j$çš„**å‰ä»»(predecessor)**ã€‚å¦‚æœ$<i, j> \in E(G)$ï¼Œåˆ™ç§°$i$æ˜¯$j$çš„**ç›´æ¥å‰ä»»(immediate predecessor)**ã€‚ç§°$j$æ˜¯$i$çš„ **(ç›´æ¥)åä»»((immediate) predecessor)**

**ååº(partial order)**ï¼šå…·æœ‰*ä¼ é€’æ€§($i \rightarrow j, j \rightarrow k \Rightarrow i \rightarrow k$)* å’Œ *éè‡ªåæ€§(ä¸å­˜åœ¨$i \rightarrow i$)* çš„ä½æ¬¡å…³ç³»
>å¦‚æœå…·æœ‰è‡ªåæ€§ï¼Œå°±ä¼šå‡ºç°è¦åšä¸€ä»¶äº‹$i$ä¹‹å‰è¦å®Œæˆ$i$çš„æ€ªåœˆï¼Œå› æ­¤âŒ

>æ³¨ï¼šååºçš„æ¦‚å¿µå¯è§dm[[Chap 9 Relations#9.6 Partial Orderings|9.6èŠ‚]]

å¯è¡Œçš„AOVç½‘å¿…é¡»æ˜¯ä¸€ä¸ª*æœ‰å‘æ— ç¯å›¾(DAG)*

>æ³¨ï¼šä¸AOVç½‘ç›¸å¯¹çš„è¿˜æœ‰*AOEç½‘(activity on edge network)*ï¼Œå…·ä½“å†…å®¹å¯[æˆ³è¿™](https://oi-wiki.org/graph/topo/)

---
**æ‹“æ‰‘åº(topological order)** æ˜¯ä¸€å¼ å›¾çš„é¡¶ç‚¹çš„çº¿æ€§é¡ºåºï¼Œæ»¡è¶³ï¼šå¯¹äºä»»æ„ä¸¤ä¸ªé¡¶ç‚¹$i, j$ï¼Œå¦‚æœ$i$æ˜¯$j$çš„å‰ä»»ï¼Œåˆ™åœ¨çº¿æ€§é¡ºåºä¸­$i$è¦å‡ºç°åœ¨$j$ä¹‹å‰

>æ³¨ï¼š
>+ å¯¹äºä¸€ä¸ªç½‘ï¼Œæ‹“æ‰‘åºä¸ä¸€å®šæ˜¯å”¯ä¸€çš„
>+ **å¼ºè¿é€šçš„DAG**ä¸€å®šæœ‰å”¯ä¸€çš„æ‹“æ‰‘åº
>+ å¦‚æœæ‹“æ‰‘åºä¸­ä¸€ä¸ªé¡¶ç‚¹å‡ºç°åœ¨å¦ä¸€ä¸ªé¡¶ç‚¹çš„å‰é¢ï¼Œå®ƒä»¬ä¹‹é—´ä¸ä¸€å®šå­˜åœ¨è·¯å¾„

ç®—æ³•å®ç°ï¼š
``` c
// version 1
void Topsort(Graph G)
{
	int Counter;
	Vertex V, W;
	for (Counter = 0; Counter < NumVertex; Counter++)
	{
		V = FindNewVertexOfDegreeZero(); // O(|V|)
		if (V == NotAVertex)
		{
			Error("Graph has a cycle");
			break;
		}
		TopNum[V] = Counter; // or output V
		for (each W adjacent from V)
			indegreep[W]--;
	}
}
```
>æ³¨ï¼š
>+ `FindNewVertexOfDegreeZero()`ï¼šæ‰«æ`Indegree[]`æ•°ç»„ï¼Œæ‰¾åˆ°å…¥åº¦ä¸º0ä¸”æœªèµ‹äºˆæ‹“æ‰‘åºçš„é¡¶ç‚¹ï¼Œå¦‚æœæ²¡æœ‰æ‰¾åˆ°é¡¶ç‚¹ï¼Œé‚£ä¹ˆè¡¨æ˜å›¾ä¸­å‡ºç°äº†ç¯ã€‚
>+ æ—¶é—´å¤æ‚åº¦ï¼š$T = O(|V|^2)$ ğŸ‘

æ”¹è¿›æ–¹æ³•ï¼šå°†æ‰€æœ‰==æœªèµ‹äºˆæ‹“æ‰‘åºçš„ã€åº¦ä¸º0çš„é¡¶ç‚¹==æ”¾å…¥ç‰¹æ®Šçš„ç›’å­(æ¯”å¦‚**é˜Ÿåˆ—**æˆ–**å †æ ˆ**)é‡Œ
``` c
// version 2, using queue ADT
void Topsort(Graph G)
{
	Queue Q;
	int Counter = 0;
	Vertex V, W;
	
	Q = CreateQueue(NumVertex); 
	for (each vertex V)
		if (indegree[V] == 0) 
			Enqueue(V, Q);
	while (!isEmpty(Q))
	{
		V = Dequeue(Q);
		TopNum[V] = ++Counter;  // assign next
		for (each W adjacent from V)
			if (--indegree[W] == 0)
				Enqueue(W, Q);
	} // end-while
	if (Counter != NumVertex)
		Error("Graph has a cycle")
	DisposeQueue(Q); // free memery
}
```
>æ—¶é—´å¤æ‚åº¦ï¼š$O(|E| + |V|)$

ğŸŒ°
![](./Images/C9/Quicker_20240417_214857.png)
![](./Images/C9/Quicker_20240417_214925.png)
>æ³¨ï¼šç°å®ç”Ÿæ´»ä¸­ï¼Œæ’è¯¾è¡¨çš„æ—¶å€™å°†é˜Ÿåˆ—ä½œä¸ºspecial boxï¼Œè€Œä¸æ˜¯å †æ ˆï¼Œå› ä¸ºé‡‡ç”¨åè€…çš„æ–¹å¼ï¼Œå­¦ç”Ÿä¼šæ·±å…¥å­¦å®Œä¸€æ•´ä¸ªä½“ç³»ï¼Œç„¶åæ‰å¼€å§‹å­¦ä¸‹ä¸€ä¸ªä½“ç³»ï¼Œè¿™æ ·å­¦æ—¶é—´ä¸å¤Ÿç”¨ã€‚

## Shortest Path Algorithms

ç»™å®šä¸€å¼ æœ‰å‘å›¾$G(V, E)$ï¼Œä»¥åŠæˆæœ¬å‡½æ•°$c(e)$ï¼Œ$e \in E(G)$ï¼Œä»**æº(source)** åˆ°**ç›®çš„åœ°(destination)** çš„è·¯å¾„$P$çš„**é•¿åº¦(length)** ä¸º$\sum\limits_{e_i \subset P}c(e_i)$ï¼ˆä¹Ÿç§°ä¸º**æƒé‡è·¯å¾„é•¿åº¦(weighted path length)**ï¼‰

### Single-Source Shortest-Path Problem

é—®é¢˜ï¼šç»™å®šä¸€å¼ æƒé‡å›¾$G(V, E)$ï¼Œä»¥åŠä¸€ä¸ªå¯åŒºåˆ†çš„é¡¶ç‚¹$s$ï¼Œå¯»æ‰¾ä»$s$åˆ°$G$ä¸­æ‰€æœ‰å…¶ä»–é¡¶ç‚¹çš„æœ€çŸ­æƒé‡è·¯å¾„
![](./Images/C9/Quicker_20240424_131818.png)
>æ³¨ï¼š
>+ å³å›¾å­˜åœ¨è´Ÿçš„è¾¹ï¼Œè¿™æ ·æœ€çŸ­è·¯çš„é•¿åº¦å¯ä»¥æ˜¯æ— ç©·å°ã€‚å› æ­¤åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæœ€çŸ­è·¯æ˜¯æœªå®šä¹‰çš„ï¼Œå› ä¸ºé™·å…¥äº†æ­»å¾ªç¯ã€‚è¿™ç§å¾ªç¯è¢«ç§°ä¸º**è´Ÿå€¼ç¯(negative-cost cycle)**
>+ ä»$s$åˆ°$s$çš„æœ€çŸ­è·¯å¾„è¢«å®šä¹‰ä¸º0
>+ ç°åœ¨ï¼Œè¿˜æ²¡æœ‰ä¸€ç§æœ€çŸ­è·¯ç®—æ³•çš„é€Ÿåº¦å¿«äºæ‰¾åˆ°ä»$s$åˆ°æ‰€æœ‰é¡¶ç‚¹çš„è·¯å¾„çš„ç®—æ³•

#### Unweighted Shortest Paths

>æ‰€æœ‰è¾¹çš„æƒé‡ = 1

![](./Images/C9/Quicker_20240424_132143.png)

å¦‚å›¾æ‰€ç¤ºï¼Œä¸ºäº†æ‰¾åˆ°ä»$v_3$å‡ºå‘åˆ°å…¶ä»–é¡¶ç‚¹çš„æ‰€æœ‰æœ€çŸ­è·¯å¾„ï¼š
+ å…ˆæ‰¾åˆ°ä¸$v_3$é‚»æ¥çš„é¡¶ç‚¹ï¼Œè®°ä»$v_3$åˆ°è¿™äº›é¡¶ç‚¹çš„æœ€çŸ­è·¯å¾„ä¸º1
+ ç„¶åå†ä»è¿™äº›é¡¶ç‚¹å‡ºå‘ï¼Œæ‰¾åˆ°ä¸å®ƒä»¬é‚»æ¥çš„é¡¶ç‚¹ã€‚å¦‚æœæ–°æ‰¾åˆ°çš„é¡¶ç‚¹è¿˜æ²¡æœ‰ç›¸åº”çš„æœ€çŸ­è·¯å¾„ï¼Œé‚£å°±è®°è¿™äº›é¡¶ç‚¹çš„æœ€çŸ­è·¯å¾„ä¸º2
+ é‡å¤æ­¥éª¤2ï¼Œç›´è‡³æ‰€æœ‰é¡¶ç‚¹çš„æœ€çŸ­è·¯å¾„éƒ½å·²æ‰¾åˆ°
è¿™ç§æ–¹æ³•è¢«ç§°ä¸º**å®½åº¦ä¼˜å…ˆæœç´¢(Breadth-first search, BFS)**ï¼šè¯¥æ–¹æ³•ä¸€å±‚å±‚åœ°å¤„ç†é¡¶ç‚¹ï¼šæœ€è¿‘çš„é¡¶ç‚¹æœ€å…ˆå¤„ç†ï¼Œæœ€è¿œçš„é¡¶ç‚¹æœ€åå¤„ç†ã€‚è¿™å’Œæ ‘ä¸­çš„ *[[Chap 4 Trees#^770ab3|å±‚åºéå†]]* ç±»ä¼¼

å®ç°ï¼š
+ `Table[i].Dist` ::= ä»$s$åˆ°$v_i$çš„è·ç¦» $= \begin{cases}\infty & \text{if } v_i \ne s \\ 0 & \text{if } v_i = s\end{cases}$

+ `Table[i].Known` ::= $\begin{cases}1 \quad \text{if } v_i \text{ is checked} \\ 0 \quad \text{if not}\end{cases}$
>+ å…¶å®æ²¡æœ‰å¿…è¦è®¾è¿™ä¸ªå­—æ®µ(å› ä¸º`Table[i].Dist`åŒæ—¶å…·å¤‡**æ ‡è®°**åŠŸèƒ½)ï¼Œå†™åœ¨è¿™é‡Œåªæ˜¯æé†’ä¸€ä¸‹è¦åšä¸€ä¸‹æ ‡è®°
>+ åœ¨åˆå§‹åŒ–ä¸­ï¼Œæ‰€æœ‰é¡¶ç‚¹çš„`Table[i].Known = 0`ï¼ŒåŒ…æ‹¬èµ·å§‹é¡¶ç‚¹ï¼Œå› ä¸ºæ²¡æœ‰ä»»ä½•é¡¶ç‚¹è¢«å¤„ç†è¿‡

+ `Table[i].Path` ::= è®°å½•è·¯å¾„ä¸Š$v_i$çš„å‰ä¸€ä¸ªé¡¶ç‚¹ï¼Œä»¥ä¾¿æ‰“å°æ•´æ¡è·¯å¾„

ä»£ç ï¼š
``` c
// version 1
void Unweighted(Table T)
{
	int CurrDist;
	Vertex V, W;
	for(CurrDist = 0; CurrDist < NumVertex; CurrDist++)
	{
		for (each vertex V)
			if (!T[V].Known && T[V].Dist == CurrDist)
			{
				T[V].Known = true;
				for (each W adjacent to V)
					if (T[W].Dist == infinity)
					{
						T[W].Dist = CurrDist + 1;
						T[W].Path = V;  // (*)
					}// end-if Dist == Infinity
			} // end-if !Known &&Dist == CurrDist
	} // end-for CurrDist
}
```

>æ³¨ï¼š
>+ è¿™ä¸ªç®—æ³•æ˜¾ç„¶æ²¡ä»€ä¹ˆæ•ˆç‡ï¼Œå› ä¸ºå¤–å±‚å¾ªç¯è¦å¾ªç¯`NumVertex - 1`æ¬¡æ‰ç»“æŸï¼Œå³ä½¿æ‰€æœ‰çš„é¡¶ç‚¹æ—©å°±å¤„ç†è¿‡äº†ã€‚è™½ç„¶å¯ä»¥å¢åŠ ä¸€ä¸ªé¢å¤–çš„åˆ¤æ–­æå‰ç»“æŸå¾ªç¯ï¼Œä½†è¿™å¹¶æ²¡æœ‰å½±å“æœ€åæƒ…å†µçš„è¿è¡Œæ—¶é—´ï¼Œæ¯”å¦‚ï¼š
>	![](./Images/C9/Quicker_20240424_134237.png)
>	èµ·å§‹ç‚¹ä¸º$v_9$ï¼Œç¬¬ä¸€æ¬¡å¾ªç¯è¦æ‰¾`CurrDist == 0`çš„é¡¶ç‚¹(å³$v_9$)ã€‚æˆ‘ä»¬ä¸€èˆ¬ä¼šæŒ‰ç…§èŠ‚ç‚¹ä¸‹æ ‡çš„é€’å¢é¡ºåºæŸ¥æ‰¾ï¼Œåˆ™è¦æ‰¾åˆ°$v_9$éœ€è¦ä»å¤´éå†åˆ°å°¾ï¼›è€Œä¸”ä¸éš¾çœ‹å‡ºï¼Œæ¯æ¬¡å¾ªç¯å‡ä¼šä»å¤´éå†åˆ°å°¾(è¶Šæ¥è¶Šé å‰)
>+ å› æ­¤æ—¶é—´å¤æ‚åº¦$T = O(|V|^2)$ğŸ‘

å¯ä»¥å‘ç°ï¼Œå¦‚æœé¡¶ç‚¹$V$æœªè¢«æ ‡è®°ï¼Œä½†$d_v \ne \infty$ï¼Œé‚£ä¹ˆ$d_v = CurrDist$ æˆ– $d_v = CurrDist + 1$ï¼Œå› æ­¤æ²¡æœ‰å¿…è¦åƒä¸Šé¢é‚£ä¸ªç®—æ³•ä¸€æ ·æ‰«ææ•´ä¸ªè¡¨æ¥æ‰¾åˆ°åˆé€‚çš„é¡¶ç‚¹ã€‚

æ”¹è¿›æ€è·¯ï¼šç”¨ä¸¤ä¸ªç®±å­ï¼Œä¸€ä¸ªç®±å­æ”¾æœªæ ‡è®°çš„ä¸”$d_v = CurrDist$çš„é¡¶ç‚¹ï¼Œå¦ä¸€ä¸ªç®±å­æ”¾æœªæ ‡è®°çš„ä¸”$d_v = CurrDist + 1$çš„é¡¶ç‚¹ã€‚é‚£ä¹ˆï¼ŒåŸæ¥æ‰«ææ•´å¼ è¡¨çš„æ“ä½œå¯ä»¥å˜æˆï¼šä»ç¬¬1ä¸ªç®±å­æ‰¾ä»»ä¸€é¡¶ç‚¹$V$ï¼Œç­‰åˆ°(* ) é‚£è¡Œä»£ç æ‰§è¡Œå®Œåï¼Œå°†$W$æ”¾å…¥ç¬¬2ä¸ªç®±å­ã€‚ç­‰åˆ°å¤–å±‚`for`å¾ªç¯ä¸€è½®ç»“æŸåï¼Œç¬¬1ä¸ªç®±å­ä¸ºç©ºï¼Œå°†ç¬¬2ä¸ªç®±å­çš„é¡¶ç‚¹è½¬ç§»åˆ°ç¬¬1ä¸ªç®±å­ï¼Œè¿›è¡Œä¸‹ä¸€è½®å¾ªç¯ã€‚

äº‹å®ä¸Šï¼Œæˆ‘ä»¬åªéœ€è¦ä¸€ä¸ª**é˜Ÿåˆ—**å°±èƒ½å®Œæˆä¸Šè¿°æ­¥éª¤ï¼š
>è¿™é‡Œä¸ç”¨`Known`å­—æ®µæ˜¯å› ä¸º`Dequeue`å°±ä»£è¡¨é¡¶ç‚¹å·²ç»è¢«å¤„ç†è¿‡äº†ï¼Œä¸ä¼šå†å›åˆ°é˜Ÿåˆ—é‡Œ
``` c
// version 2
void Unweighted(Table T)
{
	// T is initialized with the source vertex S given
	Queue Q;
	Vertex V, W;
	Q = CreateQueue(NumVertex);
	MakeEmpty(Q);
	Enqueue(S, Q); // Enqueue the source vertex
	while (!IsEmpty(Q))
	{
		V = Dequeue(Q);
		T[V].Known = true;  // not really necessary
		for (each W adjacent to V)
			if (T[W].Dist == Infinity)
			{
				T[W].Dist = T[V].Dist + 1;
				T[W].Path = V;
				Enqueue(W, Q);
			} // end-if Dist == Infinity
	} // end-while
	DisposeQueue(Q); // free memory
}
```

>æ¼”ç¤ºåŠ¨ç”»è§PPT

#### Dijkstra's Algorithm(for weighted shortest paths)

ä»¤$S =$ {$s$å’Œå·²æ‰¾åˆ°æœ€çŸ­è·¯å¾„çš„é¡¶ç‚¹$v_i$çš„é›†åˆ}
å¯¹äº$\forall u \notin S$ï¼Œå®šä¹‰`distance[u]` = è·¯å¾„$\{s \rightarrow (v_i \in S) \rightarrow u\}$çš„æœ€å°é•¿åº¦

+ Dijkstraç®—æ³•æŒ‰é˜¶æ®µæ‰§è¡Œï¼Œåœ¨æ¯ä¸ªé˜¶æ®µä¸­ï¼ŒæŒ‘é€‰ä¸€ä¸ªé¡¶ç‚¹$w$ï¼Œä¿è¯å®ƒæ˜¯æ‰€æœ‰*æœªè¢«æ ‡è®°*çš„é¡¶ç‚¹ä¸­è·¯å¾„é•¿åº¦$d_w$*æœ€çŸ­*çš„é‚£ä¸ªé¡¶ç‚¹ï¼ˆå¦‚æœæœ‰å¤šä¸ªæœ€çŸ­è·¯å¾„é•¿åº¦ï¼Œåˆ™ä»»æ„æŒ‘é€‰é¡¶ç‚¹ï¼‰
+ å·²çŸ¥ä¸Šä¸€ä¸ªè¢«æŒ‘é€‰çš„é¡¶ç‚¹$v$ï¼Œåˆ™$d_w = \min(d_w, d_v + c_{v, w})$ï¼Œæ­¤æ—¶$w \in S$ï¼Œå°†å…¶æ ‡è®°
+ ç„¶åå¯¹äºå‰©ä½™æœªè¢«æ ‡è®°çš„é¡¶ç‚¹ï¼Œé‡å¤ä¸Šè¿°æ“ä½œï¼Œç›´è‡³æ‰€æœ‰é¡¶ç‚¹å‡è¢«æ ‡è®°

ä¸€äº›åŸºæœ¬ä»£ç ï¼š
``` c
// Declarations for Dijkstra's algorithm
typedef int Vertex

struct TableEntry
{
	List Header; // Adjacency list
	int Known;
	DistType Dist;
	Vertex Path;
};

// Vertices are numbered from 0
#define NotAVerTex (-1)
typedef struct TableEntry Table[NumVertex];

// Initialization
void InitTable(Vertex Start, Graph G, Table T)
{
	int i;

	ReadGraph(G, T);
	for (i = 0; i < NumVertex; i++)
	{
		T[i].Known = False;
		T[i].Dist = Infinity;
		T[i].Path = NotAVerTex;
	}
	T[Start].dist = 0;
}

// Print shortest path to V after Dijkstra has run
// Assume that the path exists
void PrintPath(Vertex V, Table T)
{
	if(T[V].Path != NotAVertex)
	{
		PrintPath(T[V].Path, T);
		printf(" to");
	}
	printf("%v", V) //%v is pseudocode
}
```

ä»£ç å®ç°ï¼š
``` c
void Dijkstra(Table T)
{
	Vertex V, W;
	for(;;)  // O(|V|)
	{
		V = smallest unknown distance vertex;
		if (V == NotAVertex)
			break;
		T[V].Known = true;
		for (each W adjacent to V)
			if (!T[W].Known)
				if(T[V].Dist + Cvw < T[W].Dist) // è¿™æ­¥æ“ä½œç§°ä¸ºâ€œæ¾å¼›â€
				{
					Decrease(T[W].Dist to T[V].Dist + Cvw); 
					T[W].Path = V;
				} // end-if update W
	} // end-for(;;)
} // now work for edge with negative cost
```

ç¤ºæ„å›¾(åŸå›¾è§æœ€çŸ­è·¯ç®—æ³•è¿™ä¸€èŠ‚ç¬¬ä¸€å¼ å›¾ç‰‡çš„å·¦å›¾)ï¼š
![](./Images/C9/Quicker_20240424_205604.png)

>æ¼”ç¤ºåŠ¨ç”»è§PPTï¼Œçœ‹èµ·æ¥æ›´ç›´è§‚

Dijkstraç®—æ³•çš„è¿è¡Œæ—¶é—´å–å†³äºæˆ‘ä»¬å¦‚ä½•æ“ä½œå­˜æ”¾å›¾çš„è¡¨
å®ç°1ï¼š
+ ä»…ä»…ç®€å•æ‰«æä¸€éæ•´å¼ è¡¨æ¥æ‰¾åˆ°$d_v$æœ€å°çš„é¡¶ç‚¹$v \rightarrow O(|V|)$ï¼›è€Œä¸”å¤–å±‚å¾ªç¯éå†æ‰€æœ‰é¡¶ç‚¹ï¼Œå› æ­¤æ—¶é—´å¤æ‚åº¦ä¸º$O(|V|^2)$
+ æ¯æ¡è¾¹æœ€å¤šä¼šæ›´æ–°ä¸€æ¬¡ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º$O(|E|)$ï¼Œè€Œä¸”ä¸é¡¶ç‚¹çš„éå†æ˜¯*ç‹¬ç«‹*çš„
+ å› æ­¤$T = O(|V|^2 + |E|)$ï¼Œé€‚ç”¨äº*ç¨ å¯†å›¾*ï¼ˆæ­¤æ—¶å¤æ‚åº¦ç›¸å½“äºçº¿æ€§å¤æ‚åº¦ï¼‰

å®ç°2ï¼š
+ å°†è·ç¦»ä¿å­˜åœ¨**å †**é‡Œï¼Œè°ƒç”¨`DeleteMin`æ¥æ‰¾åˆ°æœªæ ‡è®°çš„æœ€å°å®šç‚¹ï¼Œå¹¶ä¸”ä¹‹åä¸å»ç®¡å®ƒã€‚
	é‚£ä¹ˆå¦‚ä½•å®ç°ç®—æ³•ä¸­çš„`Decrease(T[W].Dist to T[V].Dist + Cvw);`å‘¢ï¼Ÿ
	+ æ³•1ï¼š`DecreaseKey()` $\rightarrow O(\log |V|)$ï¼Œå› æ­¤$T = O(|V|\log |V| + |E| \log |V|) = O(|E|\log |V|)$ï¼Œé€‚ç”¨äº*ç¨€ç–å›¾*
	>ä½†æ˜¯ï¼Œå› ä¸ºå †ä¸èƒ½æœ‰æ•ˆæ”¯æŒ`Find`æ“ä½œï¼Œå½“$d_i$çš„å€¼å‘ç”Ÿæ”¹å˜æ—¶ï¼Œå®ƒçš„ä½ç½®éœ€è¦ç»´æŠ¤å’Œæ›´æ–°ï¼Œç”¨äºŒå‰å †å®ç°èµ·æ¥æœ‰äº›éº»çƒ¦ã€‚å¦‚æœç”¨åˆ°*é…å¯¹å †(pairing heap)*(ç¬¬12ç« ä¼šè®²åˆ°)ï¼Œæƒ…å†µå°±ä¼šæ”¹å–„


	+ æ³•2ï¼šå°†æ›´æ–°$d_w$æ’å…¥å †ä¸­ã€‚é‚£ä¹ˆå †ä¸­å°±ä¼šå‡ºç°å¤šä¸ªåŒä¸€é¡¶ç‚¹çš„è¡¨ç¤ºã€‚å½“`DeleteMin`å°†æœ€å°é¡¶ç‚¹ä»å †ä¸­åˆ é™¤çš„æ—¶å€™ï¼Œå¿…é¡»ç¡®ä¿å®ƒæ˜¯ã€‚å› æ­¤æœªæ ‡è®°çš„ã€‚å› æ­¤åœ¨`V = smallest unknown distance vertex;`è¿™ä¸€å¥ä¸­ï¼Œè¦å¾ªç¯ä½¿ç”¨`DeleteMin`ï¼Œç›´åˆ°æœªæ ‡è®°çš„ç‚¹å‡ºç°(æ ‡è®°è¿‡çš„ç‚¹å°±æ‰”æ‰ä¸ç”¨)ã€‚è™½ç„¶è¿™ç§æ–¹æ³•ä¼šæ‰©å¤§å †çš„è§„æ¨¡($O(|E|)$)ï¼Œä½†æ˜¯å› ä¸º$|E| \le |V|^2$ã€‚æ‰€ä»¥$\log |E| \le 2\log |V|$ï¼Œå› æ­¤$T = O(|E| \log |V|)$ã€‚ä½†å®ƒå ç”¨ç©ºé—´å¤§äºæ³•1éœ€è¦$|E|$æ¬¡`DeleteMin`æ“ä½œï¼Œå› æ­¤åœ¨å®é™…è¿è¡Œä¸­å¯èƒ½ä¼šå˜æ…¢ã€‚

	>å…¶ä»–æ”¹è¿›æ–¹æ³•ï¼šæ–æ³¢é‚£å¥‘å †(Fibonacci heap)(ç¬¬11ç« )

#### Graphs with Negative Edge Costs

å¦‚æœå‡ºç°è´Ÿçš„è¾¹æˆæœ¬ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±ä¸èƒ½åœ¨ä½¿ç”¨`Known`å­—æ®µæ ‡è®°æ˜¯å¦å·²ç»å¤„ç†è¿‡æŸä¸ªé¡¶ç‚¹ï¼Œå› ä¸ºæœ‰å¯èƒ½åœ¨ç¬¬ä¸€æ¬¡å¤„ç†è¯¥é¡¶ç‚¹ä¹‹åï¼Œåˆå‘ç°æ›´å°çš„è·¯å¾„é•¿åº¦(å› ä¸ºè´Ÿçš„è¾¹)

>ä¸€ç§å°è¯•æ˜¯ç»™æ‰€æœ‰è¾¹åŠ ä¸Šä¸€ä¸ªç›¸åŒçš„å¸¸æ•°ï¼Œä½¿å¾—æ‰€æœ‰è¾¹çš„æˆæœ¬ä¸ºæ­£æ•° $\rightarrow$ âŒ
>åˆ†æï¼šè¿™æ ·åšçš„è¯ï¼ŒåŸæœ¬åŒ…å«è¾¹æ•°è¾ƒå¤šçš„è·¯å¾„ï¼Œå®ƒçš„æˆæœ¬å¢é•¿å°±æ˜æ˜¾å¤šäºè¾¹æ•°è¾ƒå°‘çš„è·¯å¾„ï¼Œè¿™å°±æœ‰å¯èƒ½æ”¹å˜æœ€çŸ­è·¯å¾„çš„å–æ³•ã€‚

æˆ‘ä»¬é‡‡å–å°†ä¸Šé¢ä»‹ç»è¿‡çš„ä¸¤ç§ç®—æ³•ç›¸ç»“åˆçš„æ–¹æ³•æ¥è§£å†³è¿™ä¸€é—®é¢˜ï¼š
``` c
void WeightedNegative(Table T)
{
	Queue Q;
	Vertex V, W;
	Q = CreateQueue(NumVertex);
	MakeEmpty(Q);
	Enqueue(S, Q); // Enqueue the source vertex
	while (!IsEmpty(Q)) // each vertex can dequeue at most |V| times
	{
		V = Dequeue(Q);
		for (each W adjacent to V)
			if (T[V].Dist + Cvw < T[W].Dist) // no longer once per edge
			{
				T[W].Dist = T[V].Dist + Cvw;
				T[W].Path = V;
				if (W is not already in Q)
					Enqueue(W, Q);
			} // end-if update
	} // end-while
	DisposeQueue(Q); // free memory
} // negative-cost cycle will cause indefinite loop
```
>æ³¨ï¼š
>+ æ—¶é—´å¤æ‚åº¦ï¼š$O(|E| \cdot |V|)$
>+ å¦‚æœå‡ºç°è´Ÿå€¼ç¯ï¼Œè¯¥ç®—æ³•å°†ä¼šé™·å…¥æ— é™å¾ªç¯ã€‚å› æ­¤ï¼Œè®°å½•æ¯ä¸ªé¡¶ç‚¹çš„å‡ºé˜Ÿæ¬¡æ•°ï¼Œå‘ç°æœ‰é¡¶ç‚¹å‡ºé˜Ÿæ¬¡æ•°å¤šäº$|V|$æ¬¡æ—¶ï¼Œå°±ç»ˆæ­¢ç¨‹åºï¼Œè¿™æ ·å¯ä»¥é¿å…è¿™ä¸€é—®é¢˜

#### Acyclic Graphs

å¦‚æœå›¾æ˜¯*æ— ç¯(acyclic)*ï¼Œæˆ‘ä»¬å¯ä»¥æŒ‰ç…§æ‹“æ‰‘åºé€‰æ‹©é¡¶ç‚¹ï¼Œå› ä¸ºå½“é€‰æ‹©æŸä¸ªé¡¶ç‚¹åï¼Œå®ƒçš„è·ç¦»ä¸å¯èƒ½å› ä¸ºå®ƒå‰é¢é¡¶ç‚¹çš„å…¥è¾¹è€Œå‡å°‘ï¼Œè¿™æ ·åªéœ€æ‰§è¡Œä¸€è¶Ÿç®—æ³•å³å¯ã€‚

æ—¶é—´å¤æ‚åº¦$T = O(|E| + |V|)$ï¼Œä¸éœ€è¦ä¼˜å…ˆé˜Ÿåˆ—

åº”ç”¨ï¼š
1. ä¸‹å¡æ»‘é›ª
2. ï¼ˆä¸å¯é€†ï¼‰çš„åŒ–å­¦ååº”

3. ğŸŒ°å»ºç­‘å·¥ç¨‹

ğŸ¯
+ æœ€æ—©çš„å®Œæˆæ—¶é—´ï¼Ÿ
+ å“ªä¸ªé¡¹ç›®å¯ä»¥åœ¨ä¸å½±å“æœ€æ—©å®Œæˆæ—¶é—´çš„æƒ…å†µä¸‹æœ‰å»¶è¿Ÿï¼Œèƒ½å»¶è¿Ÿå¤šä¹…ï¼Ÿ

**å…³é”®è·¯å¾„åˆ†æ(critical path analysis)**ï¼š
+ AOVç½‘ï¼šæ¯ä¸ªé¡¶ç‚¹è¡¨ç¤ºä¸€ä¸ªæ´»åŠ¨ï¼Œä¸”åŒ…æ‹¬éœ€è¦å®Œæˆè¯¥æ´»åŠ¨çš„æ—¶é—´ã€‚è¾¹(v, w)è¡¨ç¤ºwå®Œæˆä¹‹å‰ï¼Œvå¿…é¡»å®Œæˆ
	![](./Images/C9/Quicker_20240508_152235.png)
+ **AOEç½‘(activity on edges networks)** 
	![](./Images/C9/Quicker_20240508_152702.png)
	å¦‚ä½•è¡¨ç¤ºï¼Ÿ
![](./Images/C9/Quicker_20240508_140200.png)
>æ³¨ï¼šå¿…è¦æ—¶éœ€è¦æ·»åŠ dummy edgeså’Œdummy nodesï¼Œé¿å…é”™è¯¯æˆ–ç¼ºå°‘çš„ä¾èµ–å…³ç³»äº§ç”Ÿ

![](./Images/C9/Quicker_20240508_140331.png)
+ $EC[j]$ï¼šèŠ‚ç‚¹$v_j$*æœ€æ—©*çš„å®Œæˆæ—¶é—´
+ $LC[j]$ï¼šèŠ‚ç‚¹$v_j$*æœ€æ™š*çš„å®Œæˆæ—¶é—´

ğŸŒ°
![](./Images/C9/Quicker_20240508_140626.png)
>æ³¨ï¼šè“å­—è¡¨ç¤ºECï¼Œçº¢å­—è¡¨ç¤ºLCï¼Œç»¿å­—è¡¨ç¤º*ç©ºé—²æ—¶é—´*(åé¢ä¼šè®²åˆ°)

+ è®¡ç®—ECï¼šæ‰¾åˆ°ç¬¬ä¸€ä¸ªäº‹ä»¶åˆ°æœ€åä¸€ä¸ªäº‹ä»¶ä¹‹é—´*æœ€é•¿*çš„è·¯
	>æ³¨ï¼š å›¾å¦‚æœæ˜¯æœ‰ç¯çš„ï¼Œå› ä¸º**æ­£æˆæœ¬ç¯(positive-cost cycles)** çš„å­˜åœ¨ï¼Œè¿™ç§ç®—æ³•æ— æ³•å®ç°ã€‚ç„¶è€Œè¿™é‡Œå·²ç»è§„å®šæ˜¯æ— ç¯å›¾ï¼Œæ‰€ä»¥æ— éœ€æ‹…å¿ƒ

	ä»èµ·ç‚¹$v_0$å¼€å§‹ï¼Œå¯¹äºä»»æ„çš„$a_i = <v, w>$ï¼Œæˆ‘ä»¬æœ‰
$$
EC[0] = 0 \quad EC[w] = \max\limits_{(v,w) \in E} \{EC[v] + C_{v, w}\}
$$
>æ³¨ï¼šæŒ‰*æ‹“æ‰‘åº*è®¡ç®—
+ è®¡ç®—LCï¼šä»ç»ˆç‚¹$v_8$å¼€å§‹ï¼Œå¯¹äºä»»æ„çš„$a_i = <v, w>$ï¼Œæˆ‘ä»¬æœ‰
$$
LC[8] = EC[8] \quad LC[v] = \min\limits_{(v,w) \in E} \{LC[v] - C_{v, w}\}
$$
>æ³¨ï¼šæŒ‰*é€†å‘æ‹“æ‰‘åº*è®¡ç®—
+ $<v, w>$çš„**ç©ºé—²æ—¶é—´(slack time)** = $LC[w] - EC[v] - C_{v, w}$
+ **å…³é”®æ´»åŠ¨(critical activity)**ï¼šç©ºé—²æ—¶é—´ä¸º0çš„æ´»åŠ¨
+ **å…³é”®è·¯å¾„(critical path)**ï¼šæ‰€æœ‰è¾¹çš„ç©ºé—²æ—¶é—´å‡ä¸º0çš„è·¯å¾„

### All-pairs Shortest Path Problem

å¯¹å›¾ä¸­ä»»æ„ä¸€å¯¹é¡¶ç‚¹$v_i, v_j(i \ne j)$ï¼Œè¦æ±‚å®ƒä»¬çš„æœ€çŸ­è·¯å¾„ï¼Œæœ‰ä»¥ä¸‹æ–¹æ³•ï¼š
+ ä½¿ç”¨$|V|$æ¬¡**å•æºç®—æ³•**(æ¯”å¦‚Dijkstra)ï¼Œæ—¶é—´å¤æ‚åº¦$T = O(|V|^3)$ï¼Œåœ¨*ç¨€ç–å›¾*ä¸­è¿è¡Œè¾ƒå¿«
+ ç”¨Chap 10ï¼ˆæœ¬å­¦æœŸä¸è®²ï¼‰ç»™å‡ºçš„ç®—æ³•ï¼Œæ—¶é—´å¤æ‚åº¦$T = O(|V|^3)$ï¼Œåœ¨*ç¨ å¯†å›¾*ä¸­è¿è¡Œè¾ƒå¿«

## Network Flow Problems

ğŸŒ°ï¼šè€ƒè™‘ä¸‹é¢çš„ç®¡é“ç½‘ç»œ
![](./Images/C9/Quicker_20240508_142217.png)
+ è¿™æ˜¯ä¸€ä¸ªæœ‰å‘å›¾$G(V, E)$ï¼Œæ¯æ¡è¾¹çš„*å®¹é‡(capacity)* ä¸º$c_{v, w}$ï¼Œç»è¿‡è¯¥è¾¹çš„*æµé‡(flow)* ä¸å¾—è¶…è¿‡å®ƒçš„å®¹é‡
+ æˆ‘ä»¬ç§°èµ·ç‚¹sä¸º**æºç‚¹(source)**ï¼Œç»ˆç‚¹tä¸º**æ±‡ç‚¹(sink)**
+ å¯¹äºæ‰€æœ‰é¡¶ç‚¹$v \notin \{s, t\}$ï¼Œæ€»æµå…¥ = æ€»è¾“å‡ºï¼Œå³$\text{Total coming in}(v) \equiv \text{Total going out}(v)$ï¼Œä¹Ÿå°±æ˜¯è¯´é¡¶ç‚¹ ==ä¸å…·å¤‡å­˜å‚¨çš„èƒ½åŠ›==

ğŸ¯ï¼šç¡®å®šä»såˆ°tçš„**æœ€å¤§æµ(maximum-flow)**

### Simple Algorithm

![](./Images/C9/Quicker_20240508_143403.png)
>æ³¨ï¼šä½¿ç”¨è¿™ä¸ªç®—æ³•æ—¶ï¼Œæˆ‘ä»¬éœ€è¦3å¼ å›¾ï¼š
>+ åŸå›¾$G$
>+ *æµé‡(flow)å›¾*$G_f$ï¼šè¡¨ç¤ºç®—æ³•è¿è¡Œçš„æ¯ä¸ªé˜¶æ®µä¸­å·²ç»å¾—åˆ°çš„æµé‡ï¼Œåˆå§‹æƒ…å†µä¸‹æ¯æ¡è¾¹çš„æµé‡å‡ä¸º0
>+ *æ®‹é‡(residual)å›¾*$G_r$ï¼šè¡¨ç¤ºå¯¹äºå›¾ä¸­çš„æ¯æ¡è¾¹ï¼Œè¿˜å‰©ä¸‹å¤šå°‘æµé‡å¯ä»¥è¢«æ·»åŠ 


æ­¥éª¤ï¼š
1.  åœ¨**æ®‹é‡å›¾(residual graph)**$G_r$ä¸­æ‰¾ä»»æ„ä¸€æ¡$s \rightarrow t$çš„è·¯å¾„(ç§°ä¸º**å¢å¹¿è·¯å¾„(augmenting path)**)
2. å°†è¿™æ¡è·¯ä¸Šæœ€å°çš„è¾¹ä½œä¸ºæµé‡çš„ä¸€éƒ¨åˆ†ï¼Œå¹¶åŠ å…¥*æµé‡å›¾(flow graph)*$G_f$
3. æ›´æ–°$G_r$ï¼Œå¹¶ç§»é™¤æµé‡ä¸º0çš„è¾¹
4. å¦‚æœ$G_r$ä¸­è¿˜å­˜åœ¨$s \rightarrow t$çš„è·¯å¾„ï¼Œå›åˆ°æ­¥éª¤1ï¼Œå¦åˆ™ç»ˆæ­¢ç¨‹åº
![](./Images/C9/1.png)

>æ³¨ï¼šè¿™ç§ç®—æ³•æœ‰ä¸€ç‚¹é—®é¢˜â€”â€”å¦‚æœæˆ‘ä»¬é‡‡ç”¨**è´ªå¿ƒ**çš„ç­–ç•¥ï¼Œå¯¹äºä¸Šå›¾ï¼Œæˆ‘ä»¬ä¼šå…ˆé€‰æ‹©$s \rightarrow a \rightarrow d \rightarrow t$ï¼Œè¿™æ ·å¾—åˆ°çš„æµé‡ä¸º3ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºã€‚ç„¶è€Œï¼Œè¿™æ ·åšçš„è¯æˆ‘ä»¬å°±æ— æ³•å†æ‰¾åˆ°ç¬¬2æ¡è·¯å¾„ï¼Œå› æ­¤æ€»æµé‡ä¸º3ï¼Œä¸æ»¡è¶³è¦æ±‚ã€‚å› æ­¤æˆ‘ä»¬éœ€è¦æ”¹è¿›ä¸Šè¿°ç®—æ³•ã€‚

![](./Images/C9/Quicker_20240508_154736.png)

### Solution

>æ”¹è¿›ï¼šä½¿ç®—æ³•å¯ä»¥*æ’¤é”€(undo)* å†³ç­–

ğŸ”‘ å¯¹äºæµé‡å›¾$G_f$ä¸­çš„æ¯æ¡è¾¹(v, w)ï¼Œå®ƒçš„æµé‡ä¸º$f_{v, w}$ï¼Œåœ¨*æ®‹é‡å›¾*ä¸­æ·»åŠ ä¸€æ¡åå‘çš„è¾¹(w, v)ï¼Œå®ƒçš„æµé‡ä¹Ÿä¸º$f_{v, w}$
![](./Images/C9/Quicker_20240508_145050.png)
>æ³¨ï¼šå¼ºçƒˆå»ºè®®çœ‹PPTï¼Œè¿™é‡Œæ²¡æœ‰åŠ¨ç”»å®¹æ˜“äº§ç”Ÿè¯¯è§£

>æ³¨ï¼šå¦‚æœè¾¹çš„å®¹é‡æ˜¯*æœ‰ç†æ•°*ï¼Œé‚£ä¹ˆè¯¥ç®—æ³•åœ¨ç»ˆæ­¢æ—¶æ€»èƒ½å¾—åˆ°ä¸€ä¸ªæœ€å¤§æµï¼ˆå›¾æœ‰*ç¯*çš„è¯ä¹Ÿå¯ä»¥ï¼‰

### Analysis

>å‰æï¼šæ‰€æœ‰è¾¹çš„å®¹é‡ä¸ºæ•´æ•°

æˆ‘ä»¬å¯ä»¥åˆ©ç”¨*æ— æƒæœ€çŸ­è·¯å¾„ç®—æ³•*æ¥æ‰¾åˆ°**å¢å¹¿è·¯å¾„**
>æ—¶é—´å¤æ‚åº¦$T = O(f \cdot |E|)$ï¼Œ$f$è¡¨ç¤ºæœ€å¤§æµé‡

â“ï¼šå¯¹äºä»¥ä¸‹ç‰¹æ®Šæƒ…å†µï¼š
![](./Images/C9/Quicker_20240508_145431.png)
å¦‚æœæˆ‘ä»¬éšæœºæŒ‘é€‰å¢å¹¿è·¯å¾„ï¼ŒæŒ‘åˆ°ä¸€æ¡åŒ…æ‹¬$a \rightarrow b$çš„è·¯å¾„ï¼Œå°±ä¼šäº§ç”Ÿé—®é¢˜ï¼š
>Random augmentations could continually augment along a path that includes the edge connected by a and b. If this were to occur repeatedly, 2,000,000 augmentations would be required, when we could get by with only 2.

è§£å†³æ–¹æ³•ï¼š
1. åœ¨é€‰æ‹©å¢å¹¿è·¯å¾„æ—¶ï¼Œæ€»æ˜¯æŒ‘é€‰ ==å¯¹æµé‡æå‡æœ€å¤§== çš„è·¯å¾„
	å¦‚ä½•å®ç°ï¼šç¨å¾®æ”¹å˜ä¸€ä¸‹Dijkstraç®—æ³•

	æ—¶é—´å¤æ‚åº¦ï¼š
	$$
	\begin{align}
	T = & T_{augmentation} \cdot T_{find\ a\ path} \\
	= & O(|E| \log cap_{max}) \cdot O(|E|\log |V|) \\ 
	= & O(|E|^2 \log |V|) (\text{if } cap_{max} \text{ is a small integer})
	\end{align}
	$$
2. åœ¨é€‰æ‹©å¢å¹¿è·¯å¾„æ—¶ï¼ŒæŒ‘é€‰ ==è¾¹æœ€å°‘== çš„å¢å¹¿è·¯å¾„
	æ—¶é—´å¤æ‚åº¦ï¼š
	$$
	\begin{align}
	T = & T_{augmentation} \cdot T_{find\ a\ path} \\ 
	= & O(|E|) \cdot O(|E| \cdot |V|)\quad (\text{unweighted shortest path algorithm})\\
	= & O(|E|^2 |V|) 
	\end{align}
	$$

### Supplements

+ æ›´ä¼˜çš„ç®—æ³•ï¼Œæ—¶é—´å¤æ‚åº¦å¯ä»¥å°†è‡³$O(|E||V|\log(|V|^2/|E|))$å’Œ$O(|E||V| + |V|^{2 + \epsilon})$
+ å¯¹äºæŸäº›ç‰¹æ®Šæƒ…å†µï¼Œæ—¶é—´å¤æ‚åº¦è¿˜å¯ä»¥é™ä½ï¼šå¦‚æœé™¤äº†æºç‚¹å’Œæ±‡ç‚¹å¤–çš„æ‰€æœ‰é¡¶ç‚¹çš„å…¥è¾¹å®¹é‡ä¸º1ï¼Œæˆ–è€…å‡ºè¾¹å®¹é‡ä¸º1ï¼Œé‚£ä¹ˆæœ€ä¼˜ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸º$O(|E||V|^{\frac{1}{2}})$
+ æ›´å¤æ‚çš„é—®é¢˜ï¼š*æœ€å°è´¹ç”¨æµé—®é¢˜(min-cost flow problem)*â€”â€”æ¯æ¡è¾¹ä¸ä»…æœ‰å®¹é‡ï¼Œè¿˜è¦è€ƒè™‘å•ä½æµé‡çš„è´¹ç”¨ã€‚ğŸ¯ï¼šè¦æ‰¾åˆ°æ‰€æœ‰æœ€å¤§æµé‡ä¸­çš„æœ€å°æˆæœ¬

## Minimum Spanning Tree

å®šä¹‰ï¼šå›¾$G$çš„**ç”Ÿæˆæ ‘(spanning tree)** æ˜¯ä¸€æ£µåŒ…å«æ‰€æœ‰é¡¶ç‚¹$V(G)$ï¼Œä»¥åŠæ‰€æœ‰è¾¹$E(G)$çš„*å­é›†*çš„*æ ‘*

ğŸŒ°ï¼š![](./Images/C9/Quicker_20240508_150633.png)
å¦‚ä½•ç†è§£**æœ€å°ç”Ÿæˆæ ‘(minimum spanning tree)**ï¼Ÿ
+ æœ€å°ç”Ÿæˆæ ‘æ˜¯ä¸€æ£µ*æ ‘*ï¼Œå› ä¸ºå®ƒæ˜¯æ— ç¯çš„ï¼Œä¸”è¾¹çš„æ•°é‡ä¸º$|V| - 1$
+ å®ƒæ˜¯*æœ€å°çš„*ï¼Œå› ä¸ºè¾¹çš„æˆæœ¬å·²ç»æœ€å°åŒ–äº†
+ å®ƒæ˜¯*ç”Ÿæˆçš„*ï¼Œå› ä¸ºå®ƒè¦†ç›–æ‰€æœ‰çš„é¡¶ç‚¹
+ æœ€å°ç”Ÿæˆæ ‘å­˜åœ¨çš„**å……è¦æ¡ä»¶**æ˜¯å›¾$G$æ˜¯**è¿é€šçš„**
+ å¦‚æœåœ¨ç”Ÿæˆæ ‘ä¸­æ·»åŠ ä¸€æ¡è¾¹ï¼Œå°±ä¼šå½¢æˆä¸€ä¸ª*ç¯*
+ æœ€å°ç”Ÿæˆæ ‘æ˜¯å¹¶ä¸ä¸€å®šæ˜¯å”¯ä¸€çš„ï¼Œä½†æœ€å°ç”Ÿæˆæ ‘çš„==**æ€»æƒé‡**æ˜¯å”¯ä¸€çš„==

å¦‚ä½•æ±‚è§£â€”â€”**è´ªå¿ƒç®—æ³•(greedy algorithm)**ï¼Œæ¯ä¸€æ­¥éƒ½é‡‡å–æœ€ä¼˜ç­–ç•¥ï¼Œä½†æœ‰ä»¥ä¸‹é™åˆ¶ï¼š
+ å¿…é¡»ä½¿ç”¨å›¾é‡Œé¢çš„è¾¹
+ å¿…é¡»ç”¨åˆ°$|V| - 1$æ¡è¾¹
+ ä¸ä½¿ç”¨å¯èƒ½å¯¼è‡´ç¯å‡ºç°çš„è¾¹

### Prim's Algorithm

æ–¹æ³•ï¼šç”Ÿæˆä¸€æ£µæ ‘ï¼Œä¸Dijkstraç®—æ³•éå¸¸ç›¸ä¼¼
+ åˆå§‹æƒ…å†µä¸‹ï¼Œå…ˆå°†ä¸€ä¸ªé¡¶ç‚¹ä½œä¸ºæ ‘çš„*æ ¹*æ”¾å…¥æ ‘å†…
+ åœ¨æ¯ä¸ªé˜¶æ®µï¼Œé€šè¿‡æ·»åŠ è¾¹(u, v)ï¼Œæ»¡è¶³(u, v)çš„æˆæœ¬æ˜¯æ‰€æœ‰åœ¨æ ‘é‡Œçš„uå’Œåœ¨æ ‘å¤–çš„vä¹‹é—´çš„è¾¹ä¸­æœ€å°çš„ï¼Œå°†æ–°çš„é¡¶ç‚¹æ·»åŠ è‡³æ ‘é‡Œ

å›¾ç¤ºï¼š
![](./Images/C9/Quicker_20240508_162105.png)

>æ³¨ï¼šæ¼”ç¤ºåŠ¨ç”»è§PPT

ä¸Dijkstraä¸åŒä¹‹å¤„åœ¨äºï¼š
+ è¦ä¿å­˜ä¸¤ç±»å€¼$d_v$å’Œ$p_v$ï¼š
	+ $d_v$ï¼šè¿æ¥$v$å’Œå·²çŸ¥é¡¶ç‚¹çš„æœ€çŸ­è·¯çš„æƒé‡
	+ $p_v$ï¼šæœ€åä¸€ä¸ªå¯¼è‡´$d_v$æ”¹å˜çš„é¡¶ç‚¹
+ æ›´æ–°è§„åˆ™æ›´åŠ ç®€å•ï¼šå¯¹äºå·²ç»é€‰å…¥æ ‘å†…çš„é¡¶ç‚¹$v$ï¼Œå®ƒçš„é‚»æ¥é¡¶ç‚¹$w$æ»¡è¶³$d_w = \min(d_w, c_{w, v})$

>æ³¨ï¼šç”±äºè¿™æ˜¯æ— å‘å›¾ï¼Œå› æ­¤éœ€è¦ç”¨åˆ°<u>ä¸¤å¼ é‚»æ¥è¡¨</u>å­˜å‚¨å›¾

æ—¶é—´å¤æ‚åº¦ï¼š
+ ä¸ç”¨å †(é€‚ç”¨äº*ç¨ å¯†å›¾*)ï¼š$O(|V|^2)$
+ *äºŒå‰å †*(é€‚ç”¨äº*ç¨€ç–å›¾*)ï¼š$O(E\log|V|)$

### Kruskal's Algorithm

æ–¹æ³•ï¼šç»´æŒä¸€ç‰‡æ£®æ—(ä¸€ç»„æ ‘)
+ åˆå§‹æƒ…å†µä¸‹ï¼Œæœ‰$|V|$æ£µå•ä¸ªèŠ‚ç‚¹æ„æˆçš„æ ‘
+ æ·»åŠ ä¸€æ¡è¾¹ï¼Œå¯ä»¥åˆå¹¶ä¸¤æ£µæ ‘ã€‚å½“ç®—æ³•ç»“æŸæ—¶ï¼Œåº”å½“åªå‰©ä¸‹ä¸€æ£µæ ‘ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¾ˆè‡ªç„¶åœ°æƒ³åˆ°ä½¿ç”¨**å¹¶æŸ¥é›†**çš„ç®—æ³•
+ æŒ‘é€‰è¾¹(è¿™é‡Œå‡è®¾æŒ‘é€‰è¾¹$(u, v)$)æ—¶è¦æ³¨æ„çš„ç»†èŠ‚ï¼š
	+ å¦‚æœu, våœ¨åŒä¸€ä¸ªé›†åˆå†…ï¼Œåˆ™ä¸èƒ½æ·»åŠ è¿™æ¡è¾¹ï¼ˆå¦åˆ™ä¼šå‡ºç°ç¯ï¼‰
	+ å¦åˆ™åŠ å…¥è¿™æ¡è¾¹ï¼Œä½¿ç”¨`Union`ç®—æ³•å°†ä¸¤ä¸ªé›†åˆåˆå¹¶èµ·æ¥
+ ç”¨**å †**ç»´æŠ¤æœªè¢«æ£€éªŒè¿‡çš„æœ€å°çš„è¾¹ï¼Œæ¯å½“æ£€éªŒä¸€æ¡è¾¹æ—¶ï¼Œä½¿ç”¨`DeleteMin`ç®—æ³•

å›¾ç¤ºï¼š
![](./Images/C9/Quicker_20240508_194123.png)

ä¼ªä»£ç å®ç°ï¼š
``` c
void Kruskal(Graph G)
{
	T = { };
	while (T contains less than [V] - 1 edges && E is not empty)
	{
		choose a least cost edge(v, w) from E; // DeleteMin
		delete(v, w) from E;
		if ((v, w) does not create a cycle in T)
			add(v, w) to T; // Union/Find
		else
			discard(v, w);
	}
	if (T contains fewer than [V] - 1 edges)
		Error("No spanning tree");
}
```

æ­£å¼ä»£ç ï¼š
``` c
void Kruskal(Graph G)
{
	int EdgesAccepted;
	DisjSet S;
	PriorityQueue H;
	Vertex U, V;
	SetType Uset, Vset;
	Edge E;

	Initialize(S);
	ReadGraphIntoHeapArray(G, H);
	BuildHeap(H);

	EdgeAccepted = 0;
	while (EdgesAccepted < NumVertex - 1)
	{
		E = DeleteMin(H);  // E = (U, V)
		Uset = Find(U, S);
		Vset = Find(V, S);
		if (Uset != Vset)
		{
			// Accept the edge
			EdgesAccepted++;
			SetUnion(S, Uset, Vset);
		}
	}
}
```

ç”±äºæ¯æ¡è¾¹è¦å­˜3ä¸ªå­—æ®µï¼Œå› æ­¤ç”¨*æŒ‡é’ˆæ•°ç»„*å­˜å‚¨è¾¹å¯èƒ½æ›´åŠ é«˜æ•ˆã€‚

æ—¶é—´å¤æ‚åº¦ï¼š$T = O(|E|\log |E|) = O(|E| \log |V|) \quad (|E| = O(|V|^2))$

## Applications of Depth-First Search

**æ·±åº¦ä¼˜å…ˆæœç´¢(depth-first search, DFS)** æ˜¯ä¸€ç§*å‰åºéå†*çš„æ³›åŒ–ã€‚
+ æ ‘ï¼šæ—¶é—´å¤æ‚åº¦$T = O(|E|)\ (|E| = \Theta(|V|))$
+ å›¾ï¼šæ³¨æ„è¦é¿å…ç¯(cycles)ï¼Œæ‰€ä»¥è®¿é—®è¿‡çš„é¡¶ç‚¹å°±è¦å¯¹å…¶*æ ‡è®°*ï¼Œç„¶åæ¥ç€è®¿é—®æœªè®¿é—®è¿‡çš„é¡¶ç‚¹ã€‚
+ å¦‚æœæ— å‘å›¾ä¸è¿é€šï¼Œæˆ–è€…æœ‰å‘å›¾ä¸æ˜¯å¼ºè¿é€šçš„ï¼Œé‚£ä¹ˆç”¨ä¸€æ¬¡DFSæ— æ³•è®¿é—®æ‰€æœ‰é¡¶ç‚¹ï¼Œéœ€è¦å¯¹æœªæ ‡è®°çš„é¡¶ç‚¹å†ç”¨ä¸€æ¬¡DFSï¼Œç›´è‡³æ‰€æœ‰é¡¶ç‚¹éƒ½è¢«æ ‡è®°ã€‚å› æ­¤ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º$O(|E| + |V|)$

æ¨¡ç‰ˆï¼š
``` c
void DFS(Vertex V)
{
	visited[V] = true; // mark this vertex to void cycles
	for (each W adjacent to V)
		if (!visited[W])
			DFS(W);
}
```

### Undirected Graphs

å½“ä¸”ä»…å½“1æ¬¡DFSèƒ½å¤Ÿéå†æ‰€æœ‰é¡¶ç‚¹æ—¶ï¼Œæ— å‘å›¾æ˜¯è¿é€šçš„

![](./Images/C9/2.gif)

æˆ‘ä»¬å¯ä»¥ä½¿ç”¨**æ·±åº¦ä¼˜å…ˆç”Ÿæˆæ ‘(depth-first spanning tree)** æ¥å½¢è±¡å±•ç¤ºDFSçš„è¿‡ç¨‹ã€‚å½“æˆ‘ä»¬å‘ç°æŸæ¡è¾¹(v, w)ä¸­çš„wå·²è¢«æ ‡è®°è¿‡ï¼Œç”¨è™šçº¿ç”»å‡ºè¿™æ¡è¾¹ï¼Œç§°ä½œâ€œ**å›è¾¹(back edge)**â€ï¼Œè¡¨ç¤ºè¿™æ¡è¾¹ä¸åŒ…å«äºç”Ÿæˆæ ‘é‡Œï¼Œå¦‚å›¾æ‰€ç¤ºï¼š
![](./Images/C9/2.png)
>æ³¨ï¼šå¦‚æœæ— å‘å›¾ä¸è¿é€šï¼Œåˆ™å¯ä»¥ç”Ÿæˆ*æ·±åº¦ä¼˜å…ˆç”Ÿæˆæ£®æ—(depth-first spanning forest)*

ä»£ç å®ç°ï¼š
``` c
void ListComponents(Graph G)
{
	for (each V in G)
	{
		if (!visited[V])
			DFS(V);
			printf("\n");
	}
}
```

### Biconnectivity

+ å½“`G' = DeleteVertex(G, v)` è‡³å°‘æœ‰2ä¸ªè¿é€šåˆ†é‡ï¼Œç§°`v`ä¸º**å…³èŠ‚ç‚¹(articulation point)**
>äººè¯ï¼šå›¾*ä¸æ˜¯åŒè¿é€šçš„*ï¼Œä¸”æŸä¸ªé¡¶ç‚¹çš„ç§»é™¤ä¼šç ´åå›¾çš„è¿é€šæ€§ï¼Œç§°è¯¥é¡¶ç‚¹ä¸º**å…³èŠ‚ç‚¹**
+ å¦‚æœ`G`æ˜¯è¿é€šçš„ä¸”æ²¡æœ‰å…³èŠ‚ç‚¹ï¼Œç§°`G`ä¸º**åŒè¿é€šå›¾(biconnected graph)**
>äººè¯ï¼šä»»æ„é¡¶ç‚¹çš„ç§»é™¤ä¸ä¼šç ´åå‰©ä½™çš„æ— å‘å›¾çš„è¿é€šæ€§
+ **åŒè¿é€šåˆ†é‡(biconnected component)**ï¼šæœ€å¤§çš„åŒè¿é€šå­å›¾
![](./Images/C9/Quicker_20240515_150434.png)

>æ³¨ï¼šæ²¡æœ‰ä¸€æ¡è¾¹ä¼šåŒæ—¶å‡ºç°åœ¨å¤šä¸ªåŒè¿é€šåˆ†é‡ä¸­ã€‚å› æ­¤E(G)è¢«åŒè¿é€šåˆ†é‡åˆ’åˆ†

é—®é¢˜ï¼šå¯»æ‰¾æ— å‘è¿é€šå›¾Gä¸­çš„æ‰€æœ‰*åŒè¿é€šåˆ†é‡*

é¢„å¤‡ï¼š
+ `Num(v)`ï¼šé¡¶ç‚¹vçš„å‰åºéå†çš„åºå·
+ `Low(v)`ï¼šæ‰€æœ‰é€šè¿‡æ ‘çš„è¾¹å’Œå›è¾¹ä¸vç›¸è¿é€šçš„æœ€å°é¡¶ç‚¹($\min(Num(w_i))$)ã€‚è¿™é‡Œè¦ç”¨åˆ°*ååºéå†*ï¼Œæ‰¾åˆ°æ‰€æœ‰ä¸vç›¸é‚»çš„é¡¶ç‚¹ï¼Œç„¶åæ‰¾å‡ºæœ€å°çš„é‚£ä¸ª

è§£å†³æ–¹æ³•ï¼š
+ ä½¿ç”¨*æ·±åº¦ä¼˜å…ˆæœç´¢(depth first search)* å¾—åˆ°Gçš„ç”Ÿæˆæ ‘![](./Images/C9/3.gif)
![](./Images/C9/Quicker_20240515_152220.png)
>æ³¨ï¼š*å›è¾¹(back edges)* (u, v)ï¼š(u, v) $\notin$ treeï¼Œä¸”u(æˆ–v)æ˜¯v(æˆ–u)çš„ç¥–å…ˆã€‚å¦‚æœuæ˜¯vçš„ç¥–å…ˆï¼Œåˆ™Num(u) < Num(v)

+ æ‰¾åˆ°Gå†…çš„**å…³èŠ‚ç‚¹**
	+ å½“ä¸”ä»…å½“*æ ¹èŠ‚ç‚¹*è‡³å°‘æœ‰2ä¸ªå­©å­æ—¶ï¼Œæ ¹èŠ‚ç‚¹ä¸ºå…³èŠ‚ç‚¹
	+ å½“ä¸”ä»…å½“*å…¶ä»–çš„é¡¶ç‚¹u*è‡³å°‘æœ‰1ä¸ªå­©å­ï¼Œä¸”ä¸èƒ½é€šè¿‡å¾€ä¸‹ç§»åŠ¨è‡³å°‘1æ­¥æ¥åˆ°å®ƒçš„ç¥–å…ˆ(å³Low(child) $\ge$ Num(u))æ—¶ï¼Œuä¸ºå…³èŠ‚ç‚¹

$$
Low(u) = \min\{Num(u), \min\{Low(w)\ |\ w \text{ is a child of }u\}, \min\{Num(w)\ |\ (u, w) \text{ is a back edge}\}\}
$$

åˆ—è¡¨ï¼š![](./Images/C9/Quicker_20240515_153001.png)

ä»£ç ï¼š
``` c
// Assign Num and compute Parents
void AssignNum(Vertex V)
{
	Vertex W;

	Num[V] = Counter++;
	Visited[V] = ture;
	for each W adjacent to V
		if (!Visited[W])
		{
			Parent[W] = V;
			AssignNum(W);
		}
}

// Assign Low; also check for articulation points
void AssignLow(Vertex V)
{
	Vertex W;

	Low[V] = Num[V]; // Rule 1
	for each W adjacent to V
	{
		if (Num[W] > Num[V])
		{
			AssignLow(W);
			if (Low[W] >= Num[V])
				printf("%v is an articulation point\n", v);
			Low[V] = Min(Low[V], Low[W]);  // Rule 3
		}
		else if (Parent[V] != W)
			Low[V] = Min(Low[V], Num[W]);  // Rule 2
	}
}

// Testing for articulation points in one depth-first search
void FindArt(Vertex V)
{
	Vertex W;

	Visited[V] = True
	Low[V] = Num[V] = Counter; // Rule 1
	for each W adjacent to V
	{
		if (!Visited[W])
		{
			Parent[W] = V;
			FindArt(W);
			if (Low[W] >= Num[V])
				printf("%v is an articulation point\n", v);
			Low[V] = Min(Low[V], Low[W]);  // Rule 3
		}
		else if (Parent[V] != W)
			Low[V] = Min(Low[V], Num[W]);  // Rule 2
	}
}
```

### Euler Circuits

+ **æ¬§æ‹‰è·¯ç¨‹(Euler tour)**ï¼šåœ¨ç¬”ä¸ç¦»çº¸çš„æƒ…å†µä¸‹ï¼Œæ¯æ¡è¾¹ä»…ç”»åˆ°ä¸€éï¼ˆä¸€ç¬”ç”»ï¼‰
+ **æ¬§æ‹‰å›è·¯(Euler circuit)**ï¼šåœ¨ç¬”ä¸ç¦»çº¸çš„æƒ…å†µä¸‹ï¼Œæ¯æ¡è¾¹ä»…ç”»åˆ°ä¸€éï¼Œä¸”æœ€åå›åˆ°èµ·ç‚¹çš„ä½ç½®
![](./Images/C9/4.gif)

+ å½“ä¸”ä»…å½“å›¾æ˜¯è¿é€šçš„ï¼Œä¸”æ¯ä¸ªé¡¶ç‚¹éƒ½æœ‰==å¶æ•°ä¸ªåº¦==æ—¶ï¼Œ**æ¬§æ‹‰å›è·¯**æ˜¯æœ‰å¯èƒ½å‡ºç°çš„
+ å½“ä¸”ä»…å½“*ä¸¤ä¸ª*é¡¶ç‚¹æœ‰*å¥‡æ•°ä¸ªåº¦*æ—¶ï¼Œä¸”ä»å¥‡æ•°åº¦çš„é¡¶ç‚¹å‡ºå‘ç”»å›¾ï¼Œåˆ™**æ¬§æ‹‰è·¯ç¨‹**æ˜¯æœ‰å¯èƒ½çš„

åˆ©ç”¨DFSå¯»æ‰¾æ¬§æ‹‰å›è·¯ï¼š![](./Images/C9/5.gif)
>[!note]
>+ ç”¨*é“¾è¡¨*ç»´æŠ¤è·¯å¾„
>+ å¯¹äºæ¯ä¸ªé‚»æ¥è¡¨ï¼Œç»´æŠ¤ä¸€ä¸ªæŒ‡å‘æœ€åè¢«æ‰«æçš„è¾¹
>+ æ—¶é—´å¤æ‚åº¦$T = O(|E| + |V|)$

>æ³¨ï¼š**å“ˆå¯†é¡¿ç¯(Hamilton cycle)**ï¼šåœ¨æ— å‘å›¾ä¸­æ‰¾åˆ°ä¸€ä¸ªæœ€å°çš„ï¼Œè®¿é—®æ‰€æœ‰*é¡¶ç‚¹*çš„åœˆï¼Œä»£ç è§ä¸‹é¢çš„[[Chap 9 Graph Algorithm#^3b293b|é¢˜ç›®]]ï¼ˆ[wiki](https://en.wikipedia.org/wiki/Hamiltonian_path)ï¼‰

``` c
// è¿™é‡Œç¼ºå°‘ä»£ç å®ç°
```

### ~~Directed Graphs~~

### ~~Finding Strong Components~~

## Problems

>2-1. If graph G is NOT connected and has 35 edges, then it must have at least ___ vertices.
>A. 7
>B. 8
>C. 9
>D. 10

**D**

$C(8, 2) = 28, C(9, 2) = 36$ï¼Œå› æ­¤9ä¸ªé¡¶ç‚¹35æ¡è¾¹ä¹Ÿèƒ½æ„æˆè¿é€šå›¾ï¼Œæ‰€ä»¥éœ€è¦10ä¸ªé¡¶ç‚¹

---
>2-2. A graph with 90 vertices and 20 edges must have *at least* __ connected component(s).
>A. 69
>B. 70
>C. 84
>D. 85

**B**

20æ¡è¾¹è‡³å¤šå¯ä»¥å°†21ä¸ªé¡¶ç‚¹è¿æ¥èµ·æ¥ï¼Œå½¢æˆä¸€ä¸ªè¿é€šåˆ†é‡ã€‚é‚£ä¹ˆå‰©ä½™69ä¸ªé¡¶ç‚¹å„è‡ªå½¢æˆè¿é€šåˆ†é‡ï¼Œæ‰€ä»¥æœ€å°çš„æ€»çš„è¿é€šåˆ†é‡ä¸ªæ•°ä¸º1 + 69 = 70

---
>2-4. Given an undirected graph G with 16 edges, where 3 vertices are of degree 4, 4 vertices are of degree 3, and all the other vertices are of degrees less than 3. Then G must have at least __ vertices.
>A. 10
>B. 11
>C. 13
>D. 15

**B**

å¯¹äºæ— å‘å›¾ï¼Œ16æ¡è¾¹å°±æœ‰32ä¸ªåº¦ï¼Œå·²çŸ¥3 * 4 + 4 * 3 = 24ä¸ªåº¦ï¼Œå› æ­¤å‰©ä¸‹12ä¸ªåº¦ã€‚åˆå› ä¸ºå…¶ä½™é¡¶ç‚¹çš„åº¦å°‘äº3ä¸ªï¼Œå› æ­¤å°±è®©å®ƒä»¬çš„åº¦å‡ä¸º2ï¼Œå› æ­¤å°±æœ‰ 8 / 2 = 4ä¸ªé¡¶ç‚¹ã€‚æ‰€ä»¥è‡³å°‘æœ‰3 + 4 + 4 = 11ä¸ªé¡¶ç‚¹

---
>Midterm-R2-9. A graph with 100 vertices and 12 edges must have *at most* ___ connected component(s).
>A.95
>B.88
>C.94
>D.87

**A**

12æ¡è¾¹è‡³å°‘ä½¿6ä¸ªé¡¶ç‚¹è¿é€šï¼Œå› ä¸º$\dfrac{5(5-1)}{2} < 12 \le \dfrac{6(6-1)}{2}$ã€‚æ‰€ä»¥è‡³å¤šæœ‰94 + 1 = 95ä¸ªè¿é€šåˆ†é‡

>æ³¨ï¼šå°†2-2å’ŒMidterm-R2-9å¯¹ç…§èµ·æ¥çœ‹ï¼Œæ³¨æ„é¢˜ç›®é—®çš„æ˜¯ä»€ä¹ˆ

---

>The minimum spanning tree of any weighted graph 
>A. must be unique
>B. must not be unique
>C. exists but may not be unique
>D. may not exist

**D**

æœ€å°ç”Ÿæˆæ ‘å­˜åœ¨çš„å……è¦æ¡ä»¶æ˜¯å›¾æ˜¯ ==è¿é€šçš„==

---
### 6-1 Is Topological Order
Write a program to test if a give sequenceÂ `Seq`Â is a topological order of a given graphÂ `Graph`.

**Format of functions**:

```c++
bool IsTopSeq( LGraph Graph, Vertex Seq[] );
```

whereÂ `LGraph`Â is defined as the following:

```c++
typedef struct AdjVNode *PtrToAdjVNode; 
struct AdjVNode{
    Vertex AdjV;
    PtrToAdjVNode Next;
};

typedef struct Vnode{
    PtrToAdjVNode FirstEdge;
} AdjList[MaxVertexNum];

typedef struct GNode *PtrToGNode;
struct GNode{  
    int Nv;
    int Ne;
    AdjList G;
};
typedef PtrToGNode LGraph;
```

The functionÂ `IsTopSeq`Â must returnÂ `true`Â ifÂ `Seq`Â does correspond to a topological order; otherwise returnÂ `false`.

**Note:**Â Although the vertices are numbered from 1 to MaxVertexNum, they areÂ **indexed from 0**Â in the LGraph structure.

**Sample program of judge**:

```c++
#include <stdio.h>
#include <stdlib.h>

typedef enum {false, true} bool;
#define MaxVertexNum 10  /* maximum number of vertices */
typedef int Vertex;      /* vertices are numbered from 1 to MaxVertexNum */

typedef struct AdjVNode *PtrToAdjVNode; 
struct AdjVNode{
    Vertex AdjV;
    PtrToAdjVNode Next;
};

typedef struct Vnode{
    PtrToAdjVNode FirstEdge;
} AdjList[MaxVertexNum];

typedef struct GNode *PtrToGNode;
struct GNode{  
    int Nv;
    int Ne;
    AdjList G;
};
typedef PtrToGNode LGraph;

LGraph ReadG(); /* details omitted */

bool IsTopSeq( LGraph Graph, Vertex Seq[] );

int main()
{
    int i, j, N;
    Vertex Seq[MaxVertexNum];
    LGraph G = ReadG();
    scanf("%d", &N);
    for (i=0; i<N; i++) {
        for (j=0; j<G->Nv; j++)
            scanf("%d", &Seq[j]);
        if ( IsTopSeq(G, Seq)==true ) printf("yes\n");
        else printf("no\n");
    }

    return 0;
}

/* Your function will be put here */
```

**Sample Input (for the graph shown in the figure):**

![topord.JPG](https://images.ptausercontent.com/5373e878-196d-45dd-a82f-555b1fea6929.JPG)

```in
6 8
1 2
1 3
5 2
5 4
2 3
2 6
3 4
6 4
5
1 5 2 3 6 4
5 1 2 6 3 4
5 1 2 3 6 4
5 2 1 6 3 4
1 2 3 4 5 6
```

**Sample Output:**

```out
yes
yes
yes
no
no
```

My code:

``` c
bool IsTopSeq( LGraph Graph, Vertex Seq[] )
{
    int indegree[MaxVertexNum];
    int i;
    int flag = 1;
    PtrToAdjVNode cur;

    for (i = 0; i < Graph->Nv; i++)
    {
        indegree[i] = 0;
    }

    for (i = 0; i < Graph->Nv; i++)
    {
        cur = Graph->G[i].FirstEdge;
        while (cur != NULL)
        {
            indegree[cur->AdjV]++;
            cur = cur->Next;
        }
    }

    for (i = 0; i < Graph->Nv; i++)
    {
        if (indegree[Seq[i] - 1] != 0)
        {
            flag = 0;
            break;
        }

        indegree[Seq[i] - 1] = -1;

        cur = Graph->G[Seq[i] - 1].FirstEdge;
        while (cur != NULL)
        {
            indegree[cur->AdjV]--;
            cur = cur->Next;
        }
    }

    if (flag)
        return true;
    else
        return false;
}
```

---
### 7-1 Hamiltonian Cycle

^3b293b

The "Hamilton cycle problem" is to find a simple cycle that contains every vertex in a graph. Such a cycle is called a "Hamiltonian cycle".

In this problem, you are supposed to tell if a given cycle is a Hamiltonian cycle.

**Input Specification:**

Each input file contains one test case. For each case, the first line contains 2 positive integersÂ NÂ (2<Nâ‰¤200), the number of vertices, andÂ M, the number of edges in an undirected graph. ThenÂ MÂ lines follow, each describes an edge in the formatÂ `Vertex1 Vertex2`, where the vertices are numbered from 1 toÂ N. The next line gives a positive integerÂ KÂ which is the number of queries, followed byÂ KÂ lines of queries, each in the format:

nÂ V1â€‹Â V2â€‹Â ...Â Vnâ€‹

whereÂ nÂ is the number of vertices in the list, andÂ Viâ€‹'s are the vertices on a path.

**Output Specification:**

For each query, print in a lineÂ `YES`Â if the path does form a Hamiltonian cycle, orÂ `NO`Â if not.

**Sample Input:**

```in
6 10
6 2
3 4
1 5
2 5
3 1
4 1
1 6
6 3
1 2
4 5
6
7 5 1 4 3 6 2 5
6 5 1 4 3 6 2
9 6 2 1 6 3 4 5 2 6
4 1 2 5 1
7 6 1 3 4 5 2 6
7 6 1 2 5 4 3 1
```

**Sample Output:**

```out
YES
NO
NO
NO
YES
NO
```

My code:

``` c
#include <stdio.h>
#include <stdlib.h>

#define SIZE 201
#define PSIZE 2001

typedef struct AdjVNode *PtrToAdjVNode; 
struct AdjVNode{
    int AdjV;
    PtrToAdjVNode Next;
};

typedef struct Vnode{
    PtrToAdjVNode FirstEdge;
} AdjList[SIZE];

typedef struct GNode *PtrToGNode;
struct GNode{  
    int Nv;
    int Ne;
    AdjList G;
};
typedef PtrToGNode LGraph;

void HCycle(LGraph g, int p[ ]);

int main()
{
    int n, m, k, q;
    int i, j;
    int v1, v2;
    int path[PSIZE];
    LGraph Graph;
    PtrToAdjVNode cur1, cur2;

    Graph = (PtrToGNode)malloc(sizeof(struct GNode));
    scanf("%d%d", &n, &m);
    Graph->Nv = n;
    Graph->Ne = m;
    for (i = 0; i < n; i++)
    {
        Graph->G[i].FirstEdge = NULL;
    }

    for (i = 0; i < m; i++)
    {
        scanf("%d%d", &v1, &v2);
        cur1 = (PtrToAdjVNode)malloc(sizeof(struct AdjVNode));
        cur1->AdjV = v2;
        cur1->Next = Graph->G[v1 - 1].FirstEdge;
        Graph->G[v1 - 1].FirstEdge = cur1;
        cur2 = (PtrToAdjVNode)malloc(sizeof(struct AdjVNode));
        cur2->AdjV = v1;
        cur2->Next = Graph->G[v2 - 1].FirstEdge;
        Graph->G[v2 - 1].FirstEdge = cur2;
    }

    scanf("%d", &k);
    for (i = 0; i < k; i++)
    {
        scanf("%d", &q);
        for (j = 0; j < q; j++)
            scanf("%d", &path[j]);
        if (q != Graph->Nv + 1)
            printf("NO\n");
        else
            HCycle(Graph, path);
    }

    return 0;

}

void HCycle(LGraph g, int p[ ])
{
    int i;
    int flag[SIZE];
    PtrToAdjVNode cur;

    if (p[0] != p[g->Nv])
    {
        printf("NO\n");
    }
    else
    {
        for (i = 0; i < g->Nv; i++)
            flag[i] = 0;
        for (i = 1; i < g->Nv + 1; i++)
        {
            if (flag[p[i - 1] - 1] == 1)
            {
                printf("NO\n");
                return;
            }
            cur = g->G[p[i - 1] - 1].FirstEdge;
            while (cur != NULL && cur->AdjV != p[i])
                cur = cur->Next;
            if (cur == NULL)
            {
                printf("NO\n");
                return;
            }
            flag[p[i - 1] - 1] = 1;
        }
        printf("YES\n");
    }
}
```