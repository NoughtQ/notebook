# Chap 3 Lists, Stacks, and Queues

## Abstract Data Type (ADT)

æ•°æ®ç±»å‹(Data Type) = {å¯¹è±¡(Objects)} $\cup$ {è¿ç®—(Operations)}

**æŠ½è±¡æ•°æ®ç±»å‹(ADT)** æ˜¯å°†å¯¹è±¡å’Œè¿ç®—çš„*è§„èŒƒ*(å°±æ˜¯æˆ‘ä»¬å®šä¹‰çš„å‡½æ•°)å’Œå…¶*è¡¨ç¤ºå’Œå®ç°*(ä¸ªäººç†è§£ä¸ºæ¥å£(Interface)ï¼Œå¯¹å‡½æ•°çš„è°ƒç”¨ç­‰ç­‰)*åˆ†ç¦»*å¼€æ¥çš„ä¸€ç§æ•°æ®ç±»å‹

## The List ADT

### Simple Array Implementation of Lists

+ **Objects**: {$item_0, item_1, \dots, item_{N - 1}$}
+ **Operations**: 
	+ `Finding_the_length`ï¼šå³æ±‚$N$
	+ `Printing`ï¼šæ‰“å°åˆ—è¡¨æ‰€æœ‰å…ƒç´ 
	+ `Making_an_empty`ï¼šå»ºç«‹ç©ºåˆ—è¡¨
	+ ==`Finding`==ï¼šæŸ¥æ‰¾ç¬¬$k$é¡¹ï¼Œ$0 \le k < N$
	+ ==`Inserting`==ï¼šåœ¨ç¬¬$k$é¡¹**å**æ’å…¥æ–°çš„é¡¹ï¼Œ$k$çš„èŒƒå›´åŒä¸Š
	+ ==`Deleting`==ï¼šåˆ é™¤ä¸€é¡¹
	+ `Finding_next`ï¼šæŸ¥æ‰¾ä¸‹ä¸€ä¸ªé¡¹
	+ `Finding_previous`ï¼šæŸ¥æ‰¾ä¸Šä¸€ä¸ªé¡¹ï¼Œ==ç”¨äºåˆ é™¤åˆ—è¡¨é¦–é¡¹==

> æ—¶é—´å¤æ‚åº¦ï¼š
> + æŸ¥æ‰¾ï¼š$O(1)$
> + æ’å…¥&åˆ é™¤ï¼š$O(N)$ â€”â€” â€ç‰µä¸€å‘è€ŒåŠ¨å…¨èº«â€œ

å› æ­¤ï¼Œå¯¹äºé¢‘ç¹è¿›è¡Œæ’å…¥å’Œåˆ é™¤çš„åˆ—è¡¨ï¼Œæˆ‘ä»¬éœ€è¦æ¢ä¸€ç§å®ç°å½¢å¼â€”â€”**é“¾è¡¨**(Linked List)

### Linked Lists

â—æ³¨æ„ï¼š
+ é“¾è¡¨ç›¸æ¯”æ•°ç»„å ç”¨ç©ºé—´æ›´å¤šï¼ˆå­˜å‚¨æŒ‡é’ˆï¼‰ï¼Œä½†å®ƒä¸è¦æ±‚ç©ºé—´è¿ç»­
+ è™½ç„¶æŸ¥æ‰¾æ—¶é—´æ…¢($O(N)$)ï¼Œä½†æ’å…¥å’Œåˆ é™¤å¾ˆå¿«($O(1)$)ï¼Œé€šè¿‡ä¸‹é¢å›¾ç¤ºå¯ä»¥è¾ƒä¸ºç›´è§‚åœ°æ„Ÿå—åˆ°
+ æœ€åä¸€é¡¹çš„æŒ‡é’ˆæŒ‡å‘`NULL`
+ å¯¹äº==å¤´æŒ‡é’ˆ==ï¼Œæˆ‘ä»¬ä¸å°†ç¬¬ä¸€é¡¹ä½œä¸ºå¤´æŒ‡é’ˆï¼Œè€Œæ˜¯é‡‡ç”¨ä¸€ä¸ª**è™šæ‹ŸèŠ‚ç‚¹(dummy node)**ã€‚è¿™ä¸ªç»“ç‚¹æ•°æ®åŸŸä¸ºç©ºï¼ŒæŒ‡é’ˆæŒ‡å‘åˆ—è¡¨ä¸­çš„ç¬¬ä¸€é¡¹ã€‚è¿™æ ·åšçš„å¥½å¤„æœ‰ï¼š
	+ åˆ é™¤é¦–é¡¹æ—¶æ— éœ€ä½¿ç”¨`Finding_previous()`äº†
	+ $\dots$
>æ³¨ï¼šé™¤éä½œç‰¹æ®Šè¯´æ˜ï¼Œfdsç¬”è®°ä¸­æ‰€æœ‰é“¾è¡¨çš„å®ç°åº”è¯¥éƒ½ä»¥dummy nodeä¸ºå¤´æŒ‡é’ˆ

å›¾ç¤ºï¼š
![](Quicker_20240308_205455.png)

![](Quicker_20240308_205536.png)

ä»£ç å®ç°ï¼š
```c
// é“¾è¡¨çš„ç±»å‹å£°æ˜ï¼Œä¸€èˆ¬æ”¾åœ¨.hæ–‡ä»¶ä¸­

#idndef _List_H

struct Node;
typedef struct Node *PtrToNode;
typedef PtrToNode List;
typedef PtrToNode Position;

List MakeEmpty(List L);
int IsEmpty(List L);
int IsLast(Position P, List L);
Position Find(ElementType X, List L);
void Delete(ElementType X, List L, Position P);
Position FindPrevious(ElementType X, List L);
void Insert(ElementType X, List L, Position P);
void DeleteList(List L);
Position Header(List L);
Position First(List L);
Position Advance(Position P);
ElementType Retrieve(Position P);

#endif
```

```c
// é“¾è¡¨çš„å…·ä½“å®ç°ï¼Œä¸€èˆ¬æ”¾åœ¨.cæ–‡ä»¶ä¸­

// èŠ‚ç‚¹
struct Node
{
    ElementType Element;
    Position Next;
};

// æ£€æŸ¥é“¾è¡¨æ˜¯å¦ä¸ºç©º
int IsEmpty(List L)
{
    return L->Next == NULL;
}

// æ£€æŸ¥èŠ‚ç‚¹Pæ˜¯å¦ä¸ºæœ€åä¸€é¡¹
// æ³¨æ„åˆ°é“¾è¡¨Læ²¡æœ‰ç”¨ä¸Šï¼Œæ”¾åœ¨è¿™é‡Œä»¥é˜²ç‰¹æ®Šæƒ…å†µçš„å¤„ç†
int IsLast(Position P, List L)  
{
    return P->Next == NULL;
}

// æŸ¥æ‰¾æ•°æ®Xåœ¨é“¾è¡¨Lä¸­çš„ä½ç½®
Position Find(ElementType X, List L)
{
    Position P;
    
    P = L->Next;
    while (P != NULL && P->Element != X)
        P = P->Next;
    
    return P;
}

// åˆ é™¤é“¾è¡¨Lä¸­çš„æ•°æ®X
void Delete(ElementType X, List L)
{
    Position P, TmpCell;
    
    P = FindPrevious(X, L);
    
    if (!IsLast(P, L))
    {
        TmpCell = P->Next;
        P->Next = TmpCell->Next;
        Free(TmpCell); // åˆ é™¤èŠ‚ç‚¹æ—¶ä¸è¦å¿˜è®°é‡Šæ”¾å†…å­˜ï¼ï¼ï¼
    }
}

// æŸ¥æ‰¾å‰ä¸€é¡¹
Position FindPrevious(ElementType X, List L)
{
    Position P;
    
    P = L;
    while (P->Next != NULL && P->Next->Element != X)
        P = P->Next;
    
    return P;
}

// åœ¨ä½ç½®Påæ’å…¥æ–°æ•°æ®X
void Insert(ElementType X, List L, Position P)
{
    Position TmpCell;
    
    TmpCell = (PtrToNode)malloc(sizeof(struct Node)); // è®°ä½è¯­æ³•
    if (TmpCell == NULL)
        FatalError("Out of Space!!!"); // è¿™é‡Œç”¨åˆ°å¤„ç†é”™è¯¯ä¿¡æ¯çš„è‡ªå®šä¹‰å‡½æ•°
    
    TmpCell->Element = X;
    TmpCell->Next = P->Next;
    P->Next = TmpCell;
}
```

### Common Errors

1. **å†…å­˜è®¿é—®é”™è¯¯(Memory Access Violation)** æˆ–**æ®µé”™è¯¯(Segmentation Violation)**â€”â€”å¯èƒ½å› ä¸º==é”™è¯¯çš„åˆå§‹åŒ–==ï¼Œæˆ–è€…==é—´æ¥å¼•ç”¨æŒ‡é’ˆ==ï¼ˆè¯¥æŒ‡é’ˆå·²è¢«`free()`äº†ï¼‰
2. åˆ¤æ–­ä½•æ—¶ä½¿ç”¨æˆ–ä¸ç”¨`malloc()`
	+ å¦‚æœæƒ³è¦åˆ›å»ºä¸€ä¸ªä¹‹å‰æœªå£°æ˜çš„æŒ‡å‘ç»“æ„çš„æŒ‡é’ˆï¼Œéœ€è¦ç”¨åˆ°`malloc()`
	+ å¦‚æœæƒ³è¦ç”¨æŒ‡é’ˆéå†ä¸€éé“¾è¡¨ï¼Œåˆ™æ— éœ€ä½¿ç”¨`malloc()`
	> æ³¨æ„ï¼š`malloc()`æ˜¯ç»™æŒ‡é’ˆåˆ†é…å­˜å‚¨ç©ºé—´ï¼Œè€Œä¸æ˜¯ç»“æ„
3. è®°å¾—ä½¿ç”¨`free()`ï¼Œå°¤å…¶æ˜¯åˆ é™¤èŠ‚ç‚¹æ—¶ï¼Œå¦åˆ™ä¼šå¸¦æ¥ä¸¥é‡çš„é—®é¢˜

### Double Linked Circular Lists

![](Quicker_20240308_212555.png)

> ä½œç”¨ï¼šç®€åŒ–**åˆ é™¤**èŠ‚ç‚¹çš„è¿‡ç¨‹

### Applications

#### The Polynomial ADT

+ **Objects**ï¼š$P(x) = a_1x^{e_1} + \dots + a_nx^{e_n}$ï¼Œæœ‰ä¸€ç»„æœ‰åºå¯¹$<e_i, a_i>$ï¼Œå…¶ä¸­$a_i$ç§°ä¸º*ç³»æ•°(coefficient)*ï¼›$e_i$ç§°ä¸º*æŒ‡æ•°(exponent)*ï¼Œå®ƒæ˜¯éè´Ÿæ•°
+ **Operations**ï¼š
	+ `Finding_degree`ï¼šåˆ¤æ–­å¤šé¡¹å¼çš„æœ€é«˜æ¬¡
	+ `Addition`
	+ `Subtraction`
	+ `Multiplication`
	+ `Differentiation`ï¼šæ±‚å¯¼

è¡¨ç¤ºå½¢å¼ï¼š

```c
// 1. æ•°ç»„â€”â€”ç¼–å†™åŠ æ³•ã€ä¹˜æ³•ç­‰å‡½æ•°è¾ƒä¸ºç®€å•ï¼Œä½†ä¼šæœ‰å¾ˆå¤§çš„ç©ºé—´æµªè´¹
typedef struct
{
    int CoeffArray[MaxDegree + 1];
    int HighPower;
} *Polynomial;

// 2. é“¾è¡¨â€”â€”èŠ‚çœç©ºé—´ï¼Œä½†ç¼–å†™åŠ æ³•ã€ä¹˜æ³•å’Œå‡½æ•°è¾ƒä¸ºå›°éš¾
typedef struct Node *PtrToNode;

struct Node
{
    int Coefficient;
    int Exponent;
    PtrToNode Next;
};

typedef PtrToNode Polynomial;  // èŠ‚ç‚¹æ ¹æ®æŒ‡æ•°å¤§å°æ’åºå¥½

// ä¸‹é¢ç”¨æ•°ç»„å½¢å¼ç¼–å†™åŠ æ³•å’Œä¹˜æ³•å‡½æ•°

// Addition
void add_polynomial( POLYNOMIAL poly1, POLYNOMIAL poly2,POLYNOMIAL poly_sum )
{
	int i;
	zero_polynomial( poly_sum );
	poly_sum->high_power = max( poly1->high_power, poly2->high_power);
	for( i=poly_sum->high_power; i>=0; i-- )
		poly_sum->coeff_array[i] = 
			poly1->coeff_array[i] + poly2->coeff_array[i];
}

// Multiplication
void mult_polynomial( POLYNOMIAL poly1, POLYNOMIAL poly2,POLYNOMIAL poly_prod )
{
	unsigned int i, j;
	zero_polynomial( poly_prod );
	poly_prod->high_power = poly1->high_power + poly2->high_power;
	if( poly_prod->high_power > MAX_DEGREE )
		error("Exceeded array size");
	else
		for( i=0; i<=poly->high_power; i++ )
			for( j=0; j<=poly2->high_power; j++ )
				poly_prod->coeff_array[i+j] +=
					poly1->coeff_array[i] * poly2->coeff_array[j];
}

// ä½œä¸šé¢˜ä¸­è¦æ±‚ç¼–å†™é“¾è¡¨å®ç°çš„åŠ æ³•å‡½æ•°ï¼Œè¿™æ˜¯æˆ‘çš„ä»£ç ï¼š
Polynomial Add( Polynomial a, Polynomial b )
{ 
    PtrToNode head = (PtrToNode)malloc(sizeof(struct Node));
    head->Next = NULL;
    Polynomial ans = head;
    Polynomial cur = head;

    while (a->Next != NULL && b->Next != NULL)
    {
        PtrToNode temp = (PtrToNode)malloc(sizeof(struct Node));
        temp->Next = NULL;
        if (a->Next->Exponent > b->Next->Exponent)
        {
            temp->Coefficient = a->Next->Coefficient;
            temp->Exponent = a->Next->Exponent;
            a = a->Next;
        }
        else if (a->Next->Exponent < b->Next->Exponent)
        {
            temp->Coefficient = b->Next->Coefficient;
            temp->Exponent = b->Next->Exponent;
            b = b->Next;
        }
        else
        {
            temp->Coefficient = a->Next->Coefficient + b->Next->Coefficient;
            if (temp->Coefficient == 0)
            {
                a = a->Next;
                b = b->Next;
                free(temp);
                continue;
            }
            else
            {
                temp->Exponent = a->Next->Exponent;
            }
            a = a->Next;
            b = b->Next;
        }
        // printf("%d %d\n", cur->Next->Coefficient, cur->Next->Exponent);
        // printf("%d\n", head->Next->Exponent);
        cur->Next = temp;
        cur = cur->Next;
    }

    while (a->Next != NULL)
    {
        PtrToNode temp = (PtrToNode)malloc(sizeof(struct Node));
        temp->Coefficient = a->Next->Coefficient;
        temp->Exponent = a->Next->Exponent;
        temp->Next = NULL;
        cur->Next = temp;
        a = a->Next;
        cur = cur->Next;
    }

    while (b->Next != NULL)
    {
        PtrToNode temp = (PtrToNode)malloc(sizeof(struct Node));
        temp->Coefficient = b->Next->Coefficient;
        temp->Exponent = b->Next->Exponent;
        temp->Next = NULL;
        cur->Next = temp;
        b = b->Next;
        cur = cur->Next;
    }    
    // printf("%d %d\n", head->Next->Coefficient, head->Next->Exponent);
    return head;
}
```

#### ~~Radix Sort~~

> ç­‰åˆ°ä¸Šå®Œæ’åºé‚£ç« å†å›è¿‡æ¥çœ‹å§ï¼Œç°åœ¨ä¹Ÿçœ‹ä¸å¤ªæ‡‚ğŸ¶

#### Multilists

^222af4

> æƒ…å¢ƒï¼šæœ‰40000åå­¦ç”Ÿå’Œ2500é—¨è¯¾ï¼Œè¦æ±‚åˆ—å‡ºæ¯é—¨è¯¾å­¦ç”Ÿçš„åå•ï¼Œä»¥åŠæ¯ä½å­¦ç”Ÿçš„è¯¾è¡¨

å¦‚æœç”¨æ•°ç»„($40000 \times 2500$)åšï¼Œä¼šæµªè´¹å·¨å¤§çš„ç©ºé—´ã€‚

å› æ­¤ç”¨**å¾ªç¯é“¾è¡¨**ï¼Œè€Œä¸”å¯¹äºé“¾è¡¨çš„æ¯ä¸ªèŠ‚ç‚¹ï¼Œæœ‰*ä¸¤ç»„æŒ‡é’ˆ*ï¼šä¸€ç»„æŒ‡å‘è¿™é—¨è¯¾çš„å…¶ä»–å­¦ç”Ÿï¼Œå¦ä¸€ç»„æŒ‡å‘è¿™ä½å­¦ç”Ÿçš„å…¶ä»–è¯¾ç¨‹ã€‚

å›¾ç¤ºï¼š
![](Quicker_20240308_214222.png)
>çœ‹èµ·æ¥å¾ˆä¼˜é›…ï¼Œä½†å®ç°èµ·æ¥å›°éš¾é‡é‡ï¼Œå¾ˆéš¾ç¼–å†™å¥½ä»£ç 

#### Cursor Implementation of Linked Lists

> å¯¹äºä¸€äº›æ²¡æœ‰æŒ‡é’ˆç±»å‹çš„ç¼–ç¨‹è¯­è¨€ï¼Œå¦‚ä½•åšåˆ°**ä¸ç”¨æŒ‡é’ˆ**å®ç°é“¾è¡¨å‘¢ï¼Ÿâ€”â€”ç”¨**æ¸¸æ ‡å®ç°(Cursor Implementation)**!

ç‰¹å¾ï¼š
+ é“¾è¡¨ä¸ºä¸€ç»„ç»“æ„ï¼Œæ¯ä¸ªç»“æ„åŒ…å«ä¸€ä¸ªæ•°æ®åŸŸå’ŒæŒ‡é’ˆåŸŸï¼ˆæŒ‡å‘ä¸‹ä¸€ä¸ªç»“æ„ï¼‰
+ é€šè¿‡`malloc()`å¾—åˆ°æ–°çš„ç»“æ„ï¼Œä¸”é€šè¿‡è°ƒç”¨`free()`é‡Šæ”¾

![](Quicker_20240308_214733.png)

é‡ç‚¹ç†è§£èŠ‚ç‚¹**åˆ†é…**å’Œ**é‡Šæ”¾**çš„è¿‡ç¨‹ï¼ˆç°åœ¨æˆ‘è¿˜æ²¡å¤ªç†è§£ğŸ˜µï¼‰
![](Quicker_20240308_215059.png)

ä»£ç å®ç°ï¼š
``` c
// é“¾è¡¨çš„ç±»å‹å£°æ˜ï¼Œä¸€èˆ¬æ”¾åœ¨.hæ–‡ä»¶ä¸­

#idndef _Cursor_H

typedef int PtrToNode;
typedef PtrToNode List;
typedef PtrToNode Position;

void InitializeCursorSpace(void);

List MakeEmpty(List L);
int IsEmpty(List L);
int IsLast(Position P, const List L);
Position Find(ElementType X, const List L);
void Delete(ElementType X, List L);
Position FindPrevious(ElementType X, const List L);
void Insert(ElementType X, List L, Position P);
void DeleteList(List L);
Position Header(const List L);
Position First(const List L);
Position Advance(const Position P);
ElementType Retrieve(const Position P);

#endif
```

```c
// é“¾è¡¨çš„å…·ä½“å®ç°ï¼Œä¸€èˆ¬æ”¾åœ¨.cæ–‡ä»¶ä¸­

// èŠ‚ç‚¹
struct Node
{
    ElementType Element;
    Position Next;
};

struct Node CursorSpace[SpaceSize];

// å‡è®¾æ¸¸æ ‡åˆ†é…å’Œé‡Šæ”¾å‡½æ•°å·²æœ‰å‡½æ•°åŸå‹
// æ¸¸æ ‡åˆ†é…
static Position CursorAlloc(void)
{
    Position P;
    
    P = CursorSpace[0].Next;
    CursorSpace[0].Next = CursorSpace[P].Next;
    
    return P;
}

// æ¸¸æ ‡é‡Šæ”¾
static void CursorFree(Position P)
{
    CursorSpace[P].Next = CursorSpace[0].Next;
    CursorSpace[0].Next = P;
}

// æ£€æŸ¥é“¾è¡¨æ˜¯å¦ä¸ºç©º
int IsEmpty(List L)
{
    return CursorSpace[L].Next == 0;
}

// æ£€æŸ¥èŠ‚ç‚¹Pæ˜¯å¦ä¸ºæœ€åä¸€é¡¹
// æ³¨æ„åˆ°é“¾è¡¨Læ²¡æœ‰ç”¨ä¸Šï¼Œæ”¾åœ¨è¿™é‡Œä»¥é˜²ç‰¹æ®Šæƒ…å†µçš„å¤„ç†
int IsLast(Position P, List L)  
{
    return CursorSpace[P].Next == 0;
}

// æŸ¥æ‰¾æ•°æ®Xåœ¨é“¾è¡¨Lä¸­çš„ä½ç½®
Position Find(ElementType X, List L)
{
    Position P;
    
    P = CursorSpace[L].Next;
    while (P && CursorSpace[P].Element != X)
        P = CursorSpace[P].Next;
    
    return P;
}

// åˆ é™¤é“¾è¡¨Lä¸­çš„æ•°æ®X
void Delete(ElementType X, List L)
{
    Position P, TmpCell;
    
    P = FindPrevious(X, L);
    
    if (!IsLast(P, L))
    {
        TmpCell = CursorSpace[P].Next;
        CursorSpace[P].Next = CursorSapce[TmpCell].Next;
        CursorFree(TmpCell); // åˆ é™¤èŠ‚ç‚¹æ—¶ä¸è¦å¿˜è®°é‡Šæ”¾å†…å­˜ï¼ï¼ï¼
    }
}

// åœ¨ä½ç½®Påæ’å…¥æ–°æ•°æ®X
void Insert(ElementType X, List L, Position P)
{
    Position TmpCell;
    
    TmpCell = CursorAlloc();
    if (TmpCell == 0)
        FatalError("Out of Space!!!"); // è¿™é‡Œç”¨åˆ°å¤„ç†é”™è¯¯ä¿¡æ¯çš„è‡ªå®šä¹‰å‡½æ•°
    
    CursorSpace[TmpCell].Element = X;
    CursorSpace[TmpCell].Next = CursorSpace[P].Next;
    CursorSpace[P].Next = TmpCell;
}
```

> é€šå¸¸æ¸¸æ ‡å®ç°æ³•æ¯”ç”¨æŒ‡é’ˆ*æ›´å¿«*ï¼Œå› ä¸ºæ²¡æœ‰è°ƒç”¨å†…å­˜ç®¡ç†çš„ç¨‹åº

### Supplements
``` c
// é€†è½¬é“¾è¡¨
List Reverse( List L )
{
    Position cur;
    Position pre;
    Position rear;

    cur = L->Next;
    while (cur != NULL)
    {
        rear = cur->Next;
        if (cur == L->Next)
            cur->Next = NULL;
        else
            cur->Next = pre;
        pre = cur;
        cur = rear;
    }
    L->Next = pre;

    return L;
}
```

## The Stack ADT
### ADT

**Stack(å †æ ˆ)**ï¼šä¸€ç§==LIFO(Last-in-First-out)(åè¿›å…ˆå‡º)==çš„åˆ—è¡¨ï¼Œå³ä»…åœ¨æœ‰åºåˆ—è¡¨çš„é¡¶ç«¯(top)è¿›è¡Œæ’å…¥å’Œåˆ é™¤æ“ä½œ

+ **Objects**ï¼šæ‹¥æœ‰0ä¸ªæˆ–å¤šä¸ªå…ƒç´ çš„æœ‰é™æœ‰åºåˆ—è¡¨
+ **Operations**ï¼š
	+ `Int IsEmpty(Stack S);` æ£€æŸ¥å †æ ˆæ˜¯å¦ä¸ºç©º
	+ `Stack CreateStack();` åˆ›å»ºå †æ ˆ
	+ `DisposeStack(Stack S);`  
	+ `MakeEmpty(Stack S);` æ¸…ç©ºå †æ ˆ
	+ ==`Push(ElementType X, Stack S);`== æ’å…¥æ–°å…ƒç´ 
	+ ==`ElementType Top(Stack S);`== è·å¾—æ ˆé¡¶å…ƒç´ 
	+ ==`Pop(Stack S);`== åˆ é™¤æ ˆé¡¶å…ƒç´ 


> â—æ³¨æ„ï¼š 
> + å¯¹*ç©º*çš„å †æ ˆä½¿ç”¨`Pop`æˆ–`Top`æ“ä½œå°†ä¼šå¼•å‘==å †æ ˆADTé”™è¯¯==
> + ç„¶è€Œï¼Œå¯¹*æ»¡*çš„å †æ ˆä½¿ç”¨`Push`æ“ä½œå°†ä¼šå¼•å‘==å®ç°é”™è¯¯(implementation error)==

### Implementations

#### Linked List Impletation

å›¾ç¤ºï¼š

`Push`
![](./Images/C3/1.png)

`Top`
![](./Images/C3/Quicker_20240421_195053.png)

`Pop`
![](./Images/C3/2.png)

ä»£ç å®ç°ï¼š
``` c
// .hæ–‡ä»¶ä»£ç ï¼šå †æ ˆADTçš„ç±»å‹å£°æ˜
#ifndef _Stack_h

struct Node;
typedef struct Node *PtrToNode;
typedef PtrToNode Stack;

int IsEmpty(Stack S);
Stack CreateStack(void);
void DisposeStack(Stack S);
void MakeEmpty(Stack S);
void Push(ElementType X, Stack S);
ElementType Top(Stack S);
void Pop(Stack S);

#endif /* _Stack_h*/
```

``` c
// .cæ–‡ä»¶ä»£ç ï¼šé“¾è¡¨æ–¹å¼çš„å®ç°
struct Node
{
	ElementType Element;
	PtrToNode Next;
};

int IsEmpty(Stack S)
{
	return S->next == NULL;
}

Stack CreateStack(void)
{
	Stack S;

	S = (Stack)malloc(sizeof(struct Node));
	if (S == NULL)
		FatalError("Out of space!!"); // è‡ªå®šä¹‰å‡½æ•°
	MakeEmpty(S);
	return S;
}

void MakeEmpty(Stack S)
{
	if (S == NULL)
		Error("Must use CreateStack first");  // è‡ªå®šä¹‰å‡½æ•°
	else 
		while (!IsEmpty(S))
			Pop(S);
}

void Push(ElementType X, Stack S)
{
	PtrToNode TmpCell;

	TmpCell = (PtrToNode)malloc(sizeof(struct Node));
	if (TmpCell == NULL)
		FatalError("Out of space!!");
	else
	{
		TmpCell->Element = X;
		TmpCell->Next = S->Next;
		S->Next = TmpCell;
	}
}

ElementType Top(Stack S)
{
	if (!IsEmpty(S))
		return S->Next->Element;
	Error("Empty stack");
	return 0; // Return value used to avoid warning
}

void Pop(Stack S)
{
	PtrToNode FirstCell;

	if (IsEmpty(S))
		Error("Empty stack");
	else
	{
		FirstCell = S->Next;
		S->Next = S->Next->Next;
		free(FirstCell);
	}
}
```

æ—¶é—´å¤æ‚åº¦ï¼šå¸¸æ•°$O(1)$

ç¼ºç‚¹ï¼šå¤šæ¬¡ä½¿ç”¨`malloc()`å’Œ`free()`å¼€é”€å¤ªå¤§

æ”¹è¿›æ–¹æ³•ï¼šé¢å¤–åˆ›å»ºä¸€ä¸ªå †æ ˆï¼Œç”¨äºå­˜æ”¾æœ¬æ¥åº”è¯¥`free()`æ‰çš„ç©ºé—´ï¼Œç­‰åˆ°æœ‰æ–°çš„å…ƒç´ éœ€è¦`push`çš„æ—¶å€™å°±å¯ä»¥ç”¨è¿™ä¸ªâ€œ*å›æ”¶ç«™*â€ä¸­çš„ç©ºé—´ï¼Œè€Œæ— éœ€å†ä½¿ç”¨`malloc()`

#### Array Impletation

ä¸å¤šè¯´ï¼Œç›´æ¥æ”¾ä¸Šä»£ç å®ç°
``` c
// .hæ–‡ä»¶ä»£ç ï¼šå †æ ˆADTçš„ç±»å‹å£°æ˜
#ifndef _Stack_h

struct StackRecord;
typedef struct StackRecord *Stack;

int IsEmpty(Stack S);
int IsFull(Stack S);
Stack CreateStack(int MaxElements);
void DisposeStack(Stack S);
void MakeEmpty(Stack S);
void Push(ElementType X, Stack S);
ElementType Top(Stack S);
void Pop(Stack S);
ElementType TopAndTop(Stack S);

#endif /* _Stack_h*/
```

``` c
// .cæ–‡ä»¶ä»£ç ï¼š(åŠ¨æ€åˆ†é…)æ•°ç»„æ–¹å¼çš„å®ç°
#define EmptyTOS (-1)   // åŠ æ‹¬å·æ˜¯ä¸ºäº†é˜²æ­¢è¿ç®—é¡ºåºçš„é”™è¯¯
#define MintackSize (5) // åŒä¸Š
struct StackRecord
{
	int Capacity;
	int TopOfStack;
	ElementType *Array;
};

Stack CreateStack(int MaxElements)
{
	Stack S;

	if (MaxElemets < MinStackSize)
		Error("Stack size if too small");

	S = (Stack)malloc(sizeof(struct StackRecord));
	if (S == NULL)
		FatalError("Out of space!!!");
	S->Array = (ElementType *)malloc(sizeof(ElementType) * MaxElements);
	if (S->Array == NULL)
		FatalError("Out of Space!!!");
	S->Capacity = MaxElements;
	MakeEmpty(S);
	
	return S;
}

void DisposeStack(Stack S)
{
	if (S != NULL)
	{
		free(S->Array);
		free(S);
	}
}

int IsEmpty(Stack S)
{
	return S->TopOfStack == EmptyTOS;
}

void MakeEmpty(Stack S)
{
	S->TopOfStack = EmptyTOS;
}

void Push(ElementType X, Stack S)
{
	if(IsFull(S))
		Error("Full stack");
	else
		S->Array[++S->TopOfStack] = X;
}

ElementType Top(Stack S)
{
	if (!IsEmpty(S))
		return S->Array[S->TopOfStack];
	Error("Empty stack");
	return 0; // Return value used to avoid warning
}

void Pop(Stack S)
{
	PtrToNode FirstCell;

	if (IsEmpty(S))
		Error("Empty stack");
	else
	{
		S->TopOfStack--;
	}
}

// å¸‚é¢ä¸Šå¾ˆå¤šä¹¦éƒ½ä¼šæŠŠPopå’ŒTopå‡½æ•°é›†æˆåˆ°Popå‡½æ•°ä¸Šï¼Œè€Œæœ¬ä¹¦çš„ä½œè€…å°†ä¸¤è€…åˆ†å¼€ï¼Œä½†ä»–ä¹Ÿæä¾›äº†é›†æˆçš„ç‰ˆæœ¬(å‰é¢æ²¡æœ‰å†™å‡½æ•°åŸå‹)
ElementType TopAndPop(Stack S)
{
	if(!IsEmpty(S))
		return S->Array[S->TopOfStack--];
	Error("Empty stack");
	return 0; // Return value used to avoid warning
}
```
> æ³¨ï¼š
> 1. å †æ ˆæ¨¡å‹å¿…é¡»**å°è£…**å¥½ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œé™¤äº†å †æ ˆç›¸å…³å‡½æ•°å¤–ï¼Œä»£ç çš„å…¶ä»–éƒ¨åˆ†ä¸èƒ½ä½¿ç”¨`Array`æˆ–`TopOfStack`çš„å˜é‡
> 2. åœ¨æ‰§è¡Œ`Push`å’Œ`Pop(Top)`å‰å¿…é¡»è¿›è¡Œ**é”™è¯¯æ£€æŸ¥**

### Applications

#### Balancing Symbols

``` c
// è¿™æ˜¯ä¼ªä»£ç ï¼Œå­¦ä¹ ä¸€ä¸‹ä¼ªä»£ç çš„æ ¼å¼
Algorithm
{
	Make an Empty stack S;
	while (read in a character c)
	{
		if (c in an opening symbol)
			Push(c, S);
		else if (c is a closing symbol)
		{
			if (S is empty)
			{
				ERROR;
				exit;
			}
			else // stack is okay
			{
				if (Top(S) doesn't match c)
				{
					ERROR;
					exit;
				}
				else 
					Pop(S);
			}  // end else-stack is okay
		} // end else-if-closing symbol
	} // end while-loop
	if (S is not empty)
		ERROR;
}
```

> æ—¶é—´å¤æ‚åº¦ï¼š$O(N)$ï¼Œè¿™æ˜¯ä¸€ä¸ª*åœ¨çº¿ç®—æ³•([[Chap 2 Algorithm Analysis#^9fd2b7|on-line algirithm]])*

#### Postfix Evaluation

^f00de4
å›¾ç¤ºï¼š
>è¿™é‡Œåªåˆ—ä¸¾äº† â€˜6 2 /â€™ çš„è§£æ³•

![](./Images/C3/3.png)
è¯´æ˜ï¼š
+ é‡åˆ°**æ“ä½œæ•°**ï¼Œå°†å…¶å‹å…¥å †æ ˆä¸­
+ é‡åˆ°**è¿ç®—ç¬¦**$opt$ï¼Œå¼¹å‡ºå †æ ˆæœ€é¡¶ä¸Šä¸¤ä¸ªå…ƒç´ $a, b$ï¼Œå…¶ä¸­$top = a$ï¼Œç„¶åè®¡ç®—$c = b\ opt\ a$ï¼Œæœ€åå°†$c$å‹å…¥å †æ ˆä¸­
+ éå†å®Œåç¼€è¡¨è¾¾å¼åï¼Œå †æ ˆä¸­åº”å½“å‰©ä¸‹ä¸€ä¸ªå…ƒç´ ï¼Œè¯¥å…ƒç´ å³ä¸ºæœ€ç»ˆç»“æœ
>æ³¨ï¼šåé¢è®²åˆ°[[Chap 4 Trees#^fc61a7|è¡¨è¾¾å¼æ ‘]]çš„æ„å»ºæ—¶ä¹Ÿé‡‡ç”¨ç±»ä¼¼æ­¥éª¤

ä»£ç å®ç°ï¼š
``` c
// è¿™é‡Œç¼ºå°‘ä»£ç å®ç°ï¼Œæœ‰ç©ºå†è¡¥doge
```
#### Infix to Postfix Conversion

^01bb22
å…³é”®ç‚¹ï¼š
+ **æ“ä½œæ•°(operands)** çš„é¡ºåºä¸å˜ï¼Œå› æ­¤ç›´æ¥è¾“å‡º
+ åœ¨å †æ ˆå†…ï¼Œ==é«˜==ä¼˜å…ˆçº§çš„**è¿ç®—ç¬¦(operators)** åœ¨==ä½==ä¼˜å…ˆçº§è¿ç®—ç¬¦çš„å‰é¢
+ æ³¨æ„ï¼šå¦‚æœ *â€˜(â€™* ==ä¸åœ¨å †æ ˆå†…==ï¼Œåˆ™å®ƒçš„ä¼˜å…ˆçº§**æœ€é«˜**ï¼›å¦‚æœå®ƒ==åœ¨å †æ ˆå†…==ï¼Œåˆ™ä¼˜å…ˆçº§**æœ€ä½**ã€‚

å…·ä½“å®ç°ï¼š
+ å¦‚æœå¾…åˆ¤æ–­çš„è¿ç®—ç¬¦çš„==ä¼˜å…ˆçº§é«˜äºæ ˆé¡¶è¿ç®—ç¬¦(åŒ…æ‹¬â€˜(â€™)==/==ç©ºæ ˆ==ï¼Œå°†å…¶å‹å…¥å †æ ˆ
+ å¦åˆ™å¦‚æœè¿ç®—ç¬¦æ˜¯ *â€˜)â€™* ï¼Œåˆ™å°†==æ ˆå†…'('å‰çš„æ‰€æœ‰è¿ç®—ç¬¦==æŒ‰å‡ºæ ˆé¡ºåºå¼¹å‡º('('ä¹Ÿä»…åœ¨è¯¥æƒ…å†µä¸‹æ‰èƒ½å¼¹å‡º)
+ å¦åˆ™çš„è¯ï¼Œ==ä»æ ˆé¡¶å¼€å§‹ä¾æ¬¡å¼¹å‡ºè¿ç®—ç¬¦ï¼Œç›´åˆ°æ»¡è¶³æ¡ä»¶1==ï¼Œå†å°†è¯¥è¿ç®—ç¬¦å‹å…¥å †æ ˆä¸­
> è¡¥å……ï¼šä¸Šè¿°åŸåˆ™é€‚ç”¨äºåŠ å‡ä¹˜é™¤å››åˆ™è¿ç®—ï¼Œä½†<u>ä¸é€‚åˆå¹‚è¿ç®—</u>ï¼Œå› ä¸ºå¹‚è¿ç®—ç¬¦^ç»“åˆæ–¹å‘è‡ªå³å‘å·¦

ä»£ç å®ç°ï¼š
``` c
// ç›´æ¥æ‘˜è‡ªæˆ‘çš„project 2ï¼Œä¹‹ååº”å½“è¿˜è¦ä¿®æ”¹ä¸€ä¸‹
Queue InToPost(char * exp)
{
Â  Â  char * tmp = (char *)malloc(sizeof(char) * VLENGTH); Â // Containing the variables or constant
Â  Â  Stack s; Â  // The stack for operators, in order to getting the proper order in postfix form
Â  Â  Queue q; Â  // The postfix expression, split them into variables, constants and operators in a queue
Â  Â  char opt; Â // The operator
Â  Â  char * head = exp; Â // Cheking if it's the first character in the expression
Â  Â  
Â  Â  // Initialization
Â  Â  s = CreateStack();
Â  Â  q = CreateQueue();
Â  Â  tmp[0] = '\0';
Â  Â  
Â  Â  while (*exp != '\0') // Traversing the infix expression
Â  Â  {
Â  Â  Â  Â  if (isalnum(*exp)) Â // Finding the potential variables and constants
Â  Â  Â  Â  {
Â  Â  Â  Â  Â  Â  CharToString(*exp, tmp); Â // Receiving it
Â  Â  Â  Â  }
Â  Â  Â  Â  else if (*exp == '-' && (exp == head || *(exp - 1) == '(')) // Handling with the case with minus sign
Â  Â  Â  Â  {
Â  Â  Â  Â  Â  Â  Enqueue("0", q);
Â  Â  Â  Â  Â  Â  Push2(*exp, s);
Â  Â  Â  Â  }
Â  Â  Â  Â  else Â // If it's an operator
Â  Â  Â  Â  {
Â  Â  Â  Â  Â  Â  if (strlen(tmp)) Â // If there is a variable or a constant
Â  Â  Â  Â  Â  Â  {
Â  Â  Â  Â  Â  Â  Â  Â  if (*exp == '(' && (!strcmp(tmp, "sin") || !strcmp(tmp, "cos") || !strcmp(tmp, "ln"))) Â // Dealing with math functions
Â  Â  Â  Â  Â  Â  Â  Â  {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Enqueue("0", q);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  switch (tmp[0])
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  case 's': Â  Â  Â  Â  Â  // sin
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Push2('!', s);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  case 'c': Â  Â  Â  Â  Â  // cos
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Push2('@', s);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  case 'l': Â  Â  Â  Â  Â  // ln
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Push2('#', s);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  else
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Enqueue(tmp, q); Â // Outputting it
Â  Â  Â  Â  Â  Â  Â  Â  tmp[0] = '\0'; Â  Â // Resetting
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  // If it's an empty stack or the priority of the current operator is higher than the top element, or the top element is the left parentheses
Â  Â  Â  Â  Â  Â  if (IsEmpty(s) || priority(*exp) < priority(s->top->operator) || s->top->operator == '(')
Â  Â  Â  Â  Â  Â  Â  Â  Push2(*exp, s); Â // Pushing the operator into the stack
Â  Â  Â  Â  Â  Â  else if (*exp == ')') Â // If it's a right parentheses
Â  Â  Â  Â  Â  Â  {
Â  Â  Â  Â  Â  Â  Â  Â  while (s->top->operator != '(') Â // Poping out all the operators on the left parentheses in the stack
Â  Â  Â  Â  Â  Â  Â  Â  {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  opt = Top2(s);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Pop(s);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  CharToString(opt, tmp);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Enqueue(tmp, q); Â // Don't forget to output it!
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  tmp[0] = '\0'; Â  Â // Resetting
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Pop(s); Â // Don't forget throw the left parentheses out!
Â  Â  Â  Â  Â  Â  Â  Â  while (s->top->operator == '!' || s->top->operator == '@' || s->top->operator == '#') // Coping with math functions, but unluckily, there are still some bugs
Â  Â  Â  Â  Â  Â  Â  Â  {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  opt = Top2(s);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Pop(s);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  CharToString(opt, tmp);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Enqueue(tmp, q); Â // Don't forget to output it!
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  tmp[0] = '\0'; Â  Â // Resetting
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  else // Else Poping out all elements with the higher priority out, until encountering the '(' or the lower one
Â  Â  Â  Â  Â  Â  {
Â  Â  Â  Â  Â  Â  Â  Â  while (s->top->operator != '(' && priority(*exp) >= priority(s->top->operator))
Â  Â  Â  Â  Â  Â  Â  Â  {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  opt = Top2(s);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Pop(s);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  CharToString(opt, tmp);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Enqueue(tmp, q); Â // Don't forget to output it!
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  tmp[0] = '\0'; Â  Â // Resetting
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Push2(*exp, s); Â // Pushing the new one to the stack
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  exp++; Â // Checking the next one
Â  Â  }

Â  Â  // Dealing with the remaining part(important!)
Â  Â  if (strlen(tmp))
Â  Â  {
Â  Â  Â  Â  Enqueue(tmp, q);
Â  Â  Â  Â  tmp[0] = '\0';
Â  Â  }

Â  Â  while (!IsEmpty(s)) Â // Disposing of the remaining elements in the stack
Â  Â  {
Â  Â  Â  Â  if (Top2(s) != '(' Â && Top2(s) != ')') Â // Special case for parentheses
Â  Â  Â  Â  {
Â  Â  Â  Â  Â  Â  opt = Top2(s);
Â  Â  Â  Â  Â  Â  Pop(s);
Â  Â  Â  Â  Â  Â  CharToString(opt, tmp);
Â  Â  Â  Â  Â  Â  Enqueue(tmp, q);
Â  Â  Â  Â  Â  Â  tmp[0] = '\0'; Â 
Â  Â  Â  Â  }
Â  Â  Â  Â  else
Â  Â  Â  Â  Â  Â  Pop(s); Â  Â  Â  Â 
Â  Â  }

Â  Â  return q; Â  // Returing the output sequence

}
```
>æ³¨ï¼š
>+ è¿™é‡Œçš„ä»£ç æ˜¯é’ˆå¯¹projectçš„é—®é¢˜â€œå®šåˆ¶â€çš„ï¼Œå› æ­¤å¯èƒ½ä¸å¤ªå…·æœ‰é€šç”¨æ€§
>+ è¿™é‡Œæˆ‘å°†å¾—åˆ°çš„åç¼€è¡¨è¾¾å¼å­˜å‚¨ä¸ºé˜Ÿåˆ—ï¼Œæ˜¯ä¸ºäº†æ–¹ä¾¿åç»­æ„å»ºè¡¨è¾¾å¼æ ‘

#### Function Calls

æ¯ä¸€æ¬¡**å‡½æ•°è°ƒç”¨**äº§ç”Ÿçš„æ•°æ®ï¼ŒåŒ…æ‹¬å±€éƒ¨å˜é‡(Local Variables)å’Œè¿”å›åœ°å€(Return Address)ï¼Œéƒ½ä¼šè¢«å­˜å…¥åˆ°==å †æ ˆå¸§(Stack Frame)==å½“ä¸­ï¼Œè€Œè¿™ä¸ªå¸§ä¼šè¢«å­˜åˆ°**ç³»ç»Ÿå †æ ˆ(System Stack)** ä¸­ã€‚
![](Quicker_20240314_171005.png)

ç”±äºç³»ç»Ÿä¸ä¼šæ£€æŸ¥*å †æ ˆæº¢å‡º*(overflow)çš„æƒ…å†µï¼Œå› æ­¤å½“è°ƒç”¨å‡½æ•°è¿‡å¤šæ—¶ä¼šå¸¦æ¥ç¾éš¾æ€§åæœï¼ˆæ¯”å¦‚æ¼æ‰åŸºæœ¬æƒ…å†µçš„é€’å½’å‡½æ•°ï¼‰

**å°¾éƒ¨é€’å½’(Tail Recursion)**ï¼šé€’å½’å‡½æ•°åœ¨æœ€åä¸€è¡Œè¿›è¡Œé€’å½’è°ƒç”¨ã€‚è¿™æ—¶ç³»ç»Ÿå¾€å¾€å°†é€’å½’å‡½æ•°æ”¹å†™æˆå¾ªç¯å½¢å¼(`goto`ï¼Œå½“ç„¶è‡ªå·±å†™å¾ªç¯æ—¶åƒä¸‡åˆ«ç”¨è¿™ä¸ª)ï¼Œè§ä¸‹é¢çš„ä¾‹å­ï¼š
``` c
// Recursion
void PrintList(List L)
{
	if (L != NULL)
	{
		PrintElement(L->Element);
		PrintList(L->Next);
	}
}  // a bad use of recursion

// Iteration
void PrintList(List L)
{
	top: if (L != NULL)
	{
		PrintElement(L->Element);
		L = L->Next;
		goto top;
	}  // do NOT do this!
}  // compiler removes recursion
```
> è™½ç„¶è§£å†³åŒä¸€é—®é¢˜ï¼Œéé€’å½’çš„ç¨‹åºå¾€å¾€å¿«äºé€’å½’ï¼Œä½†é€’å½’ç¨‹åºé€šå¸¸æ›´åŠ ç®€å•å’Œæ˜“äºç†è§£

## The Queue ADT

### ADT

**é˜Ÿåˆ—(Queue)**ï¼šä¸€ç§==FIFO(First-in-First-out)(å…ˆè¿›å…ˆå‡º)==çš„åˆ—è¡¨ï¼Œå³åœ¨æœ‰åºåˆ—è¡¨çš„ä¸€ç«¯æ’å…¥ï¼Œå¦ä¸€ç«¯åˆ é™¤
+ **Objects**ï¼šæ‹¥æœ‰0ä¸ªæˆ–å¤šä¸ªå…ƒç´ çš„æœ‰é™æœ‰åºåˆ—è¡¨
+ **Operations**ï¼š
	+ `Int IsEmpty(Queue Q);` æ£€æŸ¥é˜Ÿåˆ—æ˜¯å¦ä¸ºç©º
	+ `Stack CreateQueue();` åˆ›å»ºé˜Ÿåˆ—
	+ `DisposeQueue(Queue Q);`  
	+ `MakeEmpty(Queue Q);` æ¸…ç©ºé˜Ÿåˆ—
	+ ==`Enqueue(ElementType X, Queue Q);`== å…¥é˜Ÿ
	+ ==`ElementType Front(Queue Q);`== è·å¾—é˜Ÿé¦–å…ƒç´ 
	+ ==`Dequeue(Queue Q);`== å‡ºé˜Ÿ

### Array Implementation of Queues

ä¸å¤šè¯´ï¼Œç›´æ¥æ”¾ä¸Šä»£ç å®ç°
``` c
// .hæ–‡ä»¶ä»£ç ï¼šé˜Ÿåˆ—ADTçš„ç±»å‹å£°æ˜
#ifndef _Queue_h

struct QueueRecord;
typedef struct QueueRecord *Queue;

int IsEmpty(Queue Q);
int IsFull(Queue Q);
Stack CreateQueue(int MaxElements);
void DisposeQueue(Queue Q);
void MakeEmpty(Queue Q);
void Enqueue(ElementType X, Queue Q);
ElementType Front(Queue Q);
void Dequeue(Queue Q);
ElementType FrontAndDequeue(Queue Q);

#endif /* _Queue_h*/
```

``` c
// .cæ–‡ä»¶ä»£ç ï¼š(åŠ¨æ€åˆ†é…)æ•°ç»„æ–¹å¼çš„å®ç°
#define MintackSize (5) // åŠ æ‹¬å·æ˜¯ä¸ºäº†é˜²æ­¢è¿ç®—é¡ºåºçš„é”™è¯¯
struct QueueRecord
{
	int Capacity;
	int Front;
	int Rear;
	int Size;
	ElementType *Array;
};

int IsEmpty(Queue Q)
{
	return Q->Size == 0;
}

void MakeEmpty(Queue Q)
{
	Q->Size = 0;
	Q->Front = 1;
	Q->Rear = 0;
}

// å½¢æˆå¾ªç¯é˜Ÿåˆ—
static int Succ(int Value, Queue Q)
{
	if (++Value == Q->Capacity)
		Value = 0;
	return Value;
}

void Enqueue(ElementType X, Queue Q)
{
	if (IsFull(Q))
		Error("Full Queue");
	else
	{
		Q->Size++;
		Q->Rear = Succ(Q->Rear, Q);
		Q->Array[Q->Rear] = X;
	}
}
```
ä¸Šè¿°ä»£ç ä¸­é‡‡ç”¨äº†**å¾ªç¯é˜Ÿåˆ—(Circular Queue)** çš„æ–¹æ³•ï¼Œèƒ½å¤Ÿæœ€å¤§åŒ–åˆ©ç”¨é˜Ÿåˆ—çš„ç©ºé—´ã€‚å¯¹äºå¾ªç¯é˜Ÿåˆ—ï¼ŒåŒºåˆ†ç©ºé˜Ÿåˆ—å’Œæ»¡é˜Ÿåˆ—æœ‰2ç§åšæ³•ï¼š
1. *ç©ºå‡ºä¸€å—ç©ºé—´* 
2. ==å¢åŠ ä¸€ä¸ª`Size`çš„å­—æ®µ==ï¼Œç”¨æ¥å®æ—¶ç»Ÿè®¡é˜Ÿåˆ—å…ƒç´ ä¸ªæ•°ï¼Œè¿™æ ·æ— éœ€æµªè´¹ç©ºé—´ï¼ˆä¸Šè¿°ä»£ç ä¾¿é‡‡ç”¨è¿™ç§åšæ³•ï¼‰
>åœ¨æ³•2ä¸­ï¼Œå¦‚æœç”¨`front`è¡¨ç¤ºé˜Ÿé¦–å…ƒç´ ï¼Œ`size`è¡¨ç¤ºå½“å‰é˜Ÿä¼å¤§å°ï¼Œ`m`è¡¨ç¤ºé˜Ÿä¼æœ€å¤§å¤§å°ï¼Œåˆ™é˜Ÿå°¾å…ƒç´ `rear = (front + size - 1) % m`

### Applications

+ æ“ä½œç³»ç»Ÿä¸­çš„ä»»åŠ¡å®‰æ’ï¼šæ¯ä¸ªä»»åŠ¡æŒ‰ç…§FIFOåŸåˆ™æ‰§è¡Œ
	>è¿™é‡Œæœ‰ä¸ªå°é—®é¢˜ï¼šæ¯ä¸ªä»»åŠ¡å¯ä»¥åœ¨ä¸­é€”`kill`æ‰ï¼Œè¿™ä¸ç¬¦åˆé˜Ÿåˆ—çš„å‡ºé˜Ÿæ–¹æ³•

## Problems

>2.2  If the most commonly used operations are to visit a random position and to insert and delete the last element in a linear list, then which of the following data structures is the most efficient?
> A. doubly linked list
> B. singly linked circular list
> C. doubly linked circular list with a dummy head node
> D. sequential list

**D**ï¼Œçœ‹æ¸…é¢˜ç›®ï¼Œå®ƒè¯´çš„æ˜¯éšæœºè®¿é—®+åœ¨æœ€åè¿›è¡Œæ’å…¥å’Œåˆ é™¤æ“ä½œï¼Œé‚£ä¹ˆæ˜¾ç„¶æ˜¯æ•°ç»„å•¦ã€‚
è¿™ä¹ˆç®€å•éƒ½é”™ï¼Œè¯¥æ‰“ğŸ–ï¸

---
**7-1 Pop Sequence**

Given a stack which can keepÂ MÂ numbers at most. PushÂ NÂ numbers in the order of 1, 2, 3, ...,Â NÂ and pop randomly. You are supposed to tell if a given sequence of numbers is a possible pop sequence of the stack. For example, ifÂ MÂ is 5 andÂ NÂ is 7, we can obtain 1, 2, 3, 4, 5, 6, 7 from the stack, but not 3, 2, 1, 7, 5, 6, 4.

**Input Specification:**

Each input file contains one test case. For each case, the first line contains 3 numbers (all no more than 1000):Â MÂ (the maximum capacity of the stack),Â NÂ (the length of push sequence), andÂ KÂ (the number of pop sequences to be checked). ThenÂ KÂ lines follow, each contains a pop sequence ofÂ NÂ numbers. All the numbers in a line are separated by a space.

**Output Specification:**

For each pop sequence, print in one line "YES" if it is indeed a possible pop sequence of the stack, or "NO" if not.

**Sample Input:**

```in
5 7 5
1 2 3 4 5 6 7
3 2 1 7 5 6 4
7 6 5 4 3 2 1
5 6 4 3 7 2 1
1 7 6 5 4 3 2
```

**Sample Output:**

```out
YES
NO
NO
YES
NO
```

my code:
``` c
#include <stdio.h>
#define SIZE 1000

int main()
{
    int m, n, k;
    int i, j, t;
    int a[SIZE];
    // int stack[SIZE];
    int top, pt;
    int flag, cnt;
    int temp;

    scanf("%d%d%d", &m, &n, &k);
    for (i = 0; i < k; i++)
    {
        
        for (j = 0; j < n; j++)
            scanf("%d", &a[j]);
        
        for (j = 0; j < n - 1; j++)
        {
            flag = 0;
            cnt = 1;
            temp = 0;
            for (t = j + 1; t < n && cnt <= m; t++)
            {
                if (a[t] < a[j])
                {
                    if (!temp || a[t] < temp)
                    {
                        temp = a[t];
                        cnt++;
                    }
                    else
                    {
                        flag = 1;
                        break;
                    }
                }
            }
            if (flag || cnt > m)
            {
                printf("NO\n");
                break;
            }
        }
        if (!flag && cnt <= m)
            printf("YES\n");
    }
    return 0;
}
```