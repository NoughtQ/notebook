# Chap 2 Algorithm Analysis

**ç®—æ³•(Algorithm)**ï¼šå®Œæˆç‰¹å®šä»»åŠ¡çš„æœ‰é™ä¸ªæŒ‡ä»¤ã€‚æ‰€æœ‰çš„ç®—æ³•éƒ½å…·å¤‡ä»¥ä¸‹ç‰¹å¾ï¼š

+ *è¾“å…¥(Input)*ï¼š0ä¸ªæˆ–å¤šä¸ªè¾“å…¥
+ *è¾“å‡º(Output)*ï¼š**è‡³å°‘æœ‰1ä¸ª**è¾“å‡º
+ *ç¡®å®šæ€§(Definiteness)*ï¼šæ¯æ¡æŒ‡ä»¤éƒ½æ˜¯æ¸…æ¥šçš„
+ *æœ‰é™æ€§(Finiteness)*ï¼šåœ¨æ‰€æœ‰æƒ…å†µä¸‹ï¼Œç®—æ³•åœ¨ç»è¿‡æœ‰é™æ­¥åç»ˆæ­¢
+ *æœ‰æ•ˆæ€§(Effectiveness)*ï¼šæ¯æ¡æŒ‡ä»¤è¶³å¤Ÿç®€å•å¯è¡Œï¼ŒåŸåˆ™ä¸Šä½¿ç”¨çº¸å’Œç¬”ä¾¿èƒ½è¡¨è¾¾å‡ºæ¥ã€‚

> æ³¨ï¼š
>
> + **ç¨‹åº**ç”±ç¼–ç¨‹è¯­è¨€ä¹¦å†™ï¼Œå¹¶ä¸”ä¸å¿…æ˜¯æœ‰é™æ­¥ï¼Œæ¯”å¦‚æ“ä½œç³»ç»Ÿï¼ˆçš„æ—¶é’Ÿï¼‰
> + **ç®—æ³•**èƒ½ç”±ä»¥ä¸‹æ–¹æ³•æè¿°ï¼š
> 	+ äººç±»è¯­è¨€*human languages*
> 	+ æµç¨‹å›¾*flow charts*
> 	+ ç¼–ç¨‹è¯­è¨€*programming languages*
> 	+ ä¼ªä»£ç *pseudo-code*

## What to Analyze

æˆ‘ä»¬éœ€è¦åˆ†æç®—æ³•çš„**æ—¶é—´å’Œç©ºé—´å¤æ‚åº¦(time & space complexity)**

åœ¨åˆ†æå¤æ‚åº¦å‰ï¼Œæˆ‘ä»¬ä½œå‡ºä»¥ä¸‹å‡è®¾ï¼š
1. æ¯æ¡æŒ‡ä»¤æŒ‰é¡ºåºæ‰§è¡Œ
2. æ¯æ¡æŒ‡ä»¤**å¾ˆç®€å•**ï¼Œä¸”æ‰§è¡Œä¸€æ¡æŒ‡ä»¤ä»…èŠ±è´¹**ä¸€ä¸ªæ—¶é—´å•å…ƒ**
3. æ•´æ•°è§„æ¨¡æ˜¯å›ºå®šçš„ï¼Œå¹¶ä¸”æˆ‘ä»¬æœ‰æ— é™çš„å†…å­˜

é€šå¸¸ï¼Œæˆ‘ä»¬åˆ†æä¸‹åˆ—ä¸¤ä¸ªå‡½æ•°ï¼Œä»–ä»¬çš„è¾“å…¥è§„æ¨¡å‡ä¸º$N$ï¼š
+ $T_{avg}(N)$ï¼šå¹³å‡æ—¶é—´å¤æ‚åº¦
+ $T_{worst}(N)$â€‹â€‹ï¼šæœ€å·®æ—¶é—´å¤æ‚åº¦âœ”ï¸

## Asympotic Notation

^3c2e18

### Definition

+ ğŸŒŸ$T(N) = O(f(N))$ï¼šå­˜åœ¨æ­£å¸¸æ•°$c$å’Œ$n_0$ï¼Œ$\forall N \ge n_0$ï¼Œéƒ½æœ‰$T(N) \le c \cdot f(N)$â€‹

  > ä¸€èˆ¬å–**æœ€å°**çš„$f(N)$ï¼Œä»£è¡¨$T(N)$çš„**ä¸Šç•Œ**ã€‚ä¿—ç§°â€œ$Big-Oh$â€‹â€
  > â— *è¯·å¿½ç•¥* å¤§Oé˜¶é‡Œé¢çš„**å¸¸æ•°é¡¹**å’Œ**ä½é˜¶é¡¹**

+ $T(N) = \Omega(g(N))$ ï¼šå­˜åœ¨æ­£å¸¸æ•°$c$å’Œ$n_0$ï¼Œ$\forall N \ge n_0$ï¼Œéƒ½æœ‰$T(N) \ge c \cdot g(N)$â€‹

	> ä¸€èˆ¬å–**æœ€å¤§**çš„$g(N)$ï¼Œä»£è¡¨$T(N)$çš„**ä¸‹ç•Œ**

+ $T(N) = \Theta(h(N))$ï¼šå½“ä¸”ä»…å½“$T(N) = O(h(N))$ ä¸” $T(N) = \Omega(h(N))$

+ $T(N) = o(p(N))$ï¼šå½“$T(N) = O(p(N))$ ä¸” $T(N) \ne \Omega(p(N))$â€‹

### Rules

1. å¦‚æœ$T_1(N) = O(f(N))$ ä¸” $T_2(N) = O(g(N))$ ï¼Œé‚£ä¹ˆï¼š
	+ $T_1(N) +T_2(N) = max(O(f(N)), O(g(N)))$
	+ $T_1(N) \cdot T_2(N) = O(f(N) \cdot g(N))$
2. å¦‚æœ$T(N)$æ˜¯$k$æ¬¡å¤šé¡¹å¼ï¼Œé‚£ä¹ˆ$T(N) = \Theta(N^k)$
3. å¯¹äºä»»æ„å¸¸æ•°$k$ï¼Œ$log^kN = O(N)$â€‹ã€‚è¿™è¯´æ˜==**å¯¹æ•°**å¢é•¿é€Ÿåº¦éå¸¸æ…¢==

> æ³¨ï¼šå¦‚æœä½¿ç”¨æ¸è¿›ç¬¦å·æ¯”è¾ƒä¸¤ä¸ªç¨‹åºçš„å¤æ‚åº¦ï¼Œç¡®ä¿$N$â€‹â€‹è¶³å¤Ÿå¤§

å¢é•¿é€Ÿåº¦å›¾
![](2024-02-29-213259.png)

![](2024-02-29-213311.png)

**Example**

![](2024-02-29-194702.png)

> æ³¨:
> 1. æ³¨æ„å†…éƒ¨å¾ªç¯çš„æŒ‡ä»¤æ‰§è¡Œæ¬¡æ•°
> 2. å½“$rows \text{ }\gg \text{ }cols$æ—¶ï¼Œå¯è€ƒè™‘è¡Œåˆ—è½¬ç½® 
> 3. $T(rows, cols) = \Theta(rows \cdot cols)$

### General Rules

+ **forå¾ªç¯(FOR LOOPS)**ï¼šforå¾ªç¯çš„è¿è¡Œæ—¶é—´<u>ä¸è¶…è¿‡</u>*â€œå¾ªç¯ä½“å†…éƒ¨è¯­å¥ $\times$ è¿­ä»£æ¬¡æ•°â€*
+ **åµŒå¥—forå¾ªç¯(NESTED FOR LOOPS)**ï¼šåœ¨ä¸€ç»„åµŒå¥—å¾ªç¯å†…çš„ä¸€æ¡è¯­å¥çš„æ‰§è¡Œæ—¶é—´ä¸º *â€œè¯¥è¯­å¥ $\times$ æ‰€æœ‰çš„forå¾ªç¯è§„æ¨¡çš„ä¹˜ç§¯â€*
+ **è¿ç»­çš„è¯­å¥(CONSECUTIVE STATEMENTS)**ï¼šç®€å•åœ°*ç›¸åŠ *èµ·æ¥ï¼ˆè¿™æ„å‘³ç€å…¶ä¸­è¿è¡Œæ¬¡æ•°æœ€å¤šçš„ä¸€æ¡è¯­å¥æœ€é‡è¦ï¼‰
+ **æ¡ä»¶è¯­å¥(IF / ELSE)**ï¼šå¯¹äºä¸‹é¢ä»£ç å—

	``` c
	if (condition) S1;
	else S2
	```

	å®ƒçš„è¿è¡Œæ—¶é—´<u>ä¸ä¼šè¶…è¿‡</u>*â€œæµ‹è¯•æ¡ä»¶ + S1 å’Œ S2 ä¸­è¿è¡Œæ—¶é—´çš„æœ€é•¿è€…â€*

+ â—**RECURSION**
	![](2024-02-29-204805.png)
> ç”±æ­¤å¯è§ï¼Œ$Fib(N)$çš„æ—¶é—´å¤æ‚åº¦å¤§çš„å“äºº(æŒ‡æ•°é˜¶)

>è¡¥å……ï¼š 
>+ **ç©ºé—´**å¤æ‚åº¦ï¼š$O(N)$ï¼Œé€’å½’çš„å †æ ˆè°ƒç”¨ï¼ˆä¸²è¡Œç¨‹åºï¼‰ã€‚æ¯”å¦‚è¦ç®—$Fib(N)$ï¼Œä¸€å®šæ˜¯å…ˆ**ç®—å®Œ** $Fib(N - 1)$ å†ç®—$Fib(N - 2)$ ï¼Œä¸ä¼šåŒæ—¶è®¡ç®—ä¸¤è€…ï¼Œæ‰€ä»¥æ˜¯çº¿æ€§å¤æ‚åº¦
>+ å‡†ç¡®çš„**æ—¶é—´**å¤æ‚åº¦ï¼š$T = \Theta((\dfrac{1 + \sqrt 5}{2})^n)$ï¼Œè¯æ˜è¿‡ç¨‹å¯ä»¥çœ‹[è¿™ç¯‡æ–‡ç« ](https://zhuanlan.zhihu.com/p/257214075)

## Compare the Algorithms

> ä¸‹é¢æœ‰å››ç§æ±‚è§£æœ€å¤§è¿ç»­å­åˆ—å’Œçš„ç®—æ³•ï¼Œæ—¶é—´å¤æ‚åº¦é€ä¸€é€’å‡ï¼ˆä¸åŒ…æ‹¬è¯»å–æ•°æ®çš„æ—¶é—´ï¼ï¼‰

**Algorithm 1 ($O(N^3)$)**
```c
int MaxSubsequenceSum(const int A[ ], int N)
{
    int ThisSum, MaxSum, i, j, k;
    
    MaxSum = 0;
    for (i = 0; i < N; i++)
        for (j = i; j < N; j++)
        {
            ThisSum = 0;
            for (k = i; k <= j; k++)// è¿™é‡Œæµªè´¹äº†æ—¶é—´ï¼Œä¸éœ€è¦é‡æ–°ä»iå¼€å§‹
                ThisSum += A[k];
            
            if (ThisSum > MaxSum)
                MaxSum = ThisSum;
        }
    return MaxSum;
}
```

**Algorithm 2 ($O(N^2)$)**
```c
int MaxSubsequenceSum(const int A[ ], int N)
{
    int ThisSum, MaxSum, i, j, k;
    
    MaxSum = 0;
    for (i = 0; i < N; i++)
    {
        ThisSum = 0;
        for (j = i; j < N; j++)
        {
            ThisSum += A[j];
            
            if (ThisSum > MaxSum)
                MaxSum = ThisSum;
        }
    }
    return MaxSum;
}
```

**Algorithm 3($O(NlogN)$)**
> é‡‡ç”¨==åˆ†æ²»(divide-and-conquer)ç®—æ³•==ï¼Œåªéœ€**é€’å½’**æ¯”è¾ƒ*å·¦*åŠè¾¹å­åˆ—ã€*å³*åŠè¾¹å­åˆ—å’Œ*ä¸­é—´*çš„å­åˆ—ï¼Œé€‰æ‹©å…¶ä¸­æœ€å¤§çš„ä½œä¸ºæœ€å¤§å€¼ã€‚ä¸‹é¢æ”¾ä¸Šç¤ºæ„å›¾ï¼Œçœ‹èµ·æ¥æ›´åŠ ç›´è§‚ğŸ‘‡

![](Quicker_20240308_193906.png)

```c
static int MaxSubSum(const int A[ ], int Left, int Right)
{
    int MaxLeftSum, MaxRightSum;
    int MaxLeftBorderSum, MaxRightBorderSum;
    int LeftBorderSum, RightBorderSum;
    int Center, i;
    
    // Base Case
    if (Left == Right)
        if (A[Left] > 0)
            return A[Left];
    	else
            return 0;
   	
    // å¤„ç†å·¦å³ä¸¤åŠ
    Center = (Left + Right) / 2;
    MaxLeftSum = MaxSubSum(A, Left, Center);
    MaxRightSum = MaxSubSum(A, Center + 1, Right);
    
    // å¤„ç†ä¸­é—´éƒ¨åˆ†
    // ä»ä¸­é—´å¼€å§‹å·¦åŠéƒ¨åˆ†
    MaxLeftBorderSum = 0;
    LeftBorderSum = 0;
    for (i = Center; i >= Left; i--)
    {
        LeftBorderSum += A[i];
        if (LeftBorderSum > MaxLeftBorderSum)
            MaxLeftBorderSum = LeftBorderSum; 
    }
    // ä»ä¸­é—´å¼€å§‹å³åŠéƒ¨åˆ†
    MaxRightBorderSum = 0;
    RightBorderSum = 0;
    for (i = Center + 1; i <= Right; i++)
    {
        RightBorderSum += A[i];
        if (RightBorderSum > MaxRightBorderSum)
            MaxRightBorderSum = RightBorderSum; 
    }
    
    return Max3(MaxLeftSum, MaxRightSum, MaxLeftBorderSum + MaxRightBorderSum); // è‡ªå®šä¹‰å‡½æ•°ï¼Œæ¯”è¾ƒ3ä¸ªæ•°çš„å¤§å°
}
```

æ—¶é—´å¤æ‚åº¦è®¡ç®—ï¼š
$$
\text{Base case:  }\ T(1) = 1 \quad T(N) = 2T(N/2) + O(N)
$$
$\begin{align}\therefore T(N) = & 2T(N/2) + cN\\ = & 2[2T(N/2^2) + cN/2] + cN \\ = & 2^kO(1) + ckN \quad \text{where } N/2^k = 1\\ = & O(NlogN)\end{align}$

**Algorithm 4 ($O(N)$)**
> é‡‡ç”¨**åœ¨çº¿(on-line)ç®—æ³•**ï¼Œå®ƒèƒ½åœ¨*ä»»ä½•æ—¶é—´ç‚¹*ä¸Šè®¡ç®—å¯¹äºå·²ç»è¯»å…¥çš„æ•°æ®çš„è§£

^9fd2b7
```c
int MaxSubsequenceSum(const int A[ ], int N)
{
    int ThisSum, MaxSum, j;
    
    ThisSum = MaxSum = 0;
    for (j = 0; j < N; j++)
    {
        ThisSum += A[j];
        
        if (ThisSum >= MaxSum)
            MaxSum = ThisSum;
        else if (ThisSum < 0)
            ThisSum = 0;
    }
    return MaxSum;
}
```

è¿è¡Œæ—¶é—´çš„æ¯”è¾ƒï¼š

![](Quicker_20240308_195959.png)

## Logarithm in the Running Time

> ä»¥ä¸‹ç»™å‡ºçš„ä¸‰ä¸ªä¾‹å­æ—¶é—´å¤æ‚åº¦å‡ä¸º$O(log N)$

### Binary Search

> ä½¿ç”¨å‰æä¸ºåœ¨ä¸€ç»„**æœ‰åº**çš„åˆ—è¡¨ä¸­æŸ¥æ‰¾ã€‚æ—¶é—´å¤æ‚åº¦æ˜¾è€Œæ˜“è§

å›¾ç¤ºï¼š
![](Quicker_20240308_200244.png)

ä»£ç ï¼š
```c
int BinarySearch(const ElementType A[ ], ElementType X, int N)
{
    int Low, Mid, High;
    
    Low = 0;
    High = N - 1;
    while (Low <= High)
    {
        Mid = (Low + High) / 2;
        if (A[Mid] < X)
            Low = Mid + 1;
        else if (A[Mid] > X)
            High = Mid - 1;
        else
            return Mid;
    }
    return NotFound;  // NotFoundè¢«å®šä¹‰ä¸º-1
}
```

### Euclidâ€™s Algorithm

> åˆç§°==è¾—è½¬ç›¸é™¤æ³•==ï¼Œç”¨äºæ±‚è§£ä¸¤ä¸ªæ•°çš„**æœ€å¤§å…¬çº¦æ•°(greatest common divisor, gcd)**

åˆ†æï¼šè¦æ±‚è§£ä¸¤ä¸ªæ•°$M, N(\text{assume that } M \ge N)$çš„æœ€å¤§å…¬çº¦æ•°ï¼Œå…ˆç®—å‡ºä¸¤è€…ç›¸é™¤å¾—åˆ°çš„ä½™æ•°ï¼Œç„¶åç”¨å°çš„æ•°$N$é™¤ä»¥ä½™æ•°å¾—åˆ°æ–°çš„ä½™æ•°ï¼Œä»¥æ­¤ç±»æ¨ï¼Œå½“è¾ƒå°æ•°ä¸º0æ—¶ç»“æŸã€‚æ­¤æ—¶å‰©ä¸‹çš„é0æ•°ï¼ˆå³è¾ƒå¤§æ•°ï¼‰å³ä¸ºæœ€å¤§å…¬çº¦æ•°ã€‚

è¦è¯´æ˜å®ƒçš„æ—¶é—´å¤æ‚åº¦ä¸º$O(logN)$ï¼Œå…ˆè¯æ˜ä¸‹é¢è¿™ä¸ªå®šç†ï¼š
$$
\text{If }M > N\text{ ,then }M\text{ mod }N < M / 2
$$

> æç¤ºï¼šåˆ†$N \le M/2$ å’Œ $N > M/2$ä¸¤ç§æƒ…å†µè®¨è®ºï¼Œæ˜“è¯ï¼Œæ•…ç•¥å»è¯æ˜è¿‡ç¨‹

æœ‰äº†è¿™ä¸ªå®šç†åï¼Œè‡ªç„¶è€Œç„¶å°±èƒ½æƒ³åˆ°å®ƒçš„æ—¶é—´å¤æ‚åº¦åœ¨$O(logN)$å·¦å³ã€‚äº‹å®ä¸Šï¼Œå®é™…çš„å¤æ‚åº¦è¿˜ç•¥å¾®ä½ä¸€äº›ã€‚

ä»£ç ï¼š
```c
unsigned int Gcd(unsigned int M, unsigned int N)
{
    // è¿™é‡Œå·²ç»å‡è®¾ M > Näº†
    unsigned int Rem;
    
    while (N > 0)
    {
        Rem = M % N;
        M = N;
        N = Rem;
    }
    return M;
}
```

### Exponentation

ä¸å¤šè¯´ï¼Œç›´æ¥ä¸Šä»£ç ï¼Œçœ‹å®Œåä¾¿ç†è§£å…¶æ—¶é—´å¤æ‚åº¦ä¸ºä»€ä¹ˆä¸º$O(logN)$
```c
long Pow(long, X, unsigned int N)
{
    if (N == 0)
        return 1;
    if (N == 1)  // 5,6ä¸¤è¡Œå¯ä»¥ä¸å†™ï¼Œå› ä¸ºç¬¬10è¡Œå’Œ3,4è¡Œå¯ä»¥è§£å†³è¿™ä¸€æƒ…å†µ
        return X;
    if (IsEven(N))  // int IsEven(int N){return N % 2 == 0}
        return Pow(X * X, N / 2);
    else
        return Pow(X * X, N / 2) * X;
}
// æœ€åæ³¨æ„é€’å½’ç¨‹åºçš„ä¹¦å†™é—®é¢˜ï¼Œé”™è¯¯çš„ä¹¦å†™ä¼šå½±å“æ•ˆç‡ï¼Œç”šè‡³å¯¼è‡´æ­»å¾ªç¯ï¼ˆè§ä¹¦ä¸Šåä¾‹ï¼‰
```

## Cheking Your Analysis

å¦‚æœç¨‹åºè¿‡äºå¤æ‚ï¼Œæ— æ³•ç›´æ¥çœ‹å‡ºæ—¶é—´å¤æ‚åº¦ï¼ˆè¿™ç§æƒ…å†µå¸¸å¸¸å‘ç”Ÿï¼‰ï¼Œé‚£ä¹ˆä¸‹é¢çš„æ–¹æ³•ä¼šå¸®åˆ°æˆ‘ä»¬ï¼š
$$
\text{When }T(N) = O(f(N)) \text{ , check if}
\\
\lim\limits _{N \rightarrow \infty} \frac{T(N)}{f(N)} \approx \text{ Constant}
$$
å¦‚æœæ˜¯å¸¸æ•°çš„è¯ï¼Œè¯´æ˜æˆ‘ä»¬ä¼°è®¡çš„æ—¶é—´å¤æ‚åº¦$O(f(N))$åŸºæœ¬æ­£ç¡®