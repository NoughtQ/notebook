# Chap 8 The Disjoint Set ADT

## Equivalence Relations

>å…·ä½“æ¦‚å¿µè§dm[[Chap 9 Relations|ç¬¬9ç« ]]

å®šä¹‰ï¼š
+ åœ¨æŸä¸ªé›†åˆ$S$çš„ä¸€ä¸ª**å…³ç³»(relation)**$R$ï¼Œå¯¹äºæ¯å¯¹å…ƒç´ $(a ,b), a, b \in S$ï¼Œå®ƒä»¬çš„å…³ç³»$a \ R\ b$ï¼Œå¦‚æœå…¶å€¼ä¸ºçœŸï¼Œé‚£ä¹ˆç§°$a$ä¸$b$ç›¸å…³($a$ is related to $b$)
+ å¯¹äºé›†åˆ$S$çš„ä¸€ç§å…³ç³»$\sim$ï¼Œå¦‚æœå®ƒæ»¡è¶³*è‡ªåæ€§(reflexive)* ã€*å¯¹ç§°æ€§(symmetric)*å’Œ *ä¼ é€’æ€§(transitive)*ï¼Œé‚£ä¹ˆç§°è¿™ç§å…³ç³»ä¸º**ç­‰ä»·å…³ç³»(equivalence relation)**
	>+ è‡ªåæ€§ï¼š$\forall a \in S, a\ R\ a$
	>+ å¯¹ç§°æ€§ï¼š$a\ R\ b \leftrightarrow b\ R\ a$
	>+ ä¼ é€’æ€§ï¼š$(a\ R\ b) \wedge (b\ R\ c) \rightarrow a\ R\ c$

+ å¯¹äºå…ƒç´ $a \in S$çš„**ç­‰ä»·ç±»(equivalence class)**ï¼Œæ˜¯åŒ…å«æ‰€æœ‰ä¸$a$*ç›¸å…³*çš„å…ƒç´ çš„$S$çš„å­é›†
>å¯ä»¥çœ‹å‡ºï¼Œç­‰ä»·ç±»ç›¸å½“äº$S$å†…çš„éš”æ¿(partition)ï¼Œ$S$å†…çš„æ¯ä¸ªå…ƒç´ ä»…å‡ºç°åœ¨ä¸€ä¸ªç­‰ä»·ç±»ä¸­

## The Dynamic Equivalence Problem

>é—®é¢˜ï¼šç»™å®šç­‰ä»·å…³ç³»$\sim$ï¼Œå¯¹äºä»»ä½•çš„$a, b$ï¼Œåˆ¤æ–­$a \sim b$æ˜¯å¦æˆç«‹

ğŸŒ°
![](Images/C8/Quicker_20240410_154916.png)
ç®—æ³•â€”â€”**å¹¶æŸ¥é›†(Union / Find, the disjoint set)**
``` c
Algorithm: (Union / Find)
{   
	// step 1: read the relations in
	initialize N disjoint sets;
	while  (read in a~b)
	{
		if (!(Find(a) == Find(b)))
			Union the two sets;
	} // end-while
	// step 2: decide if a~b
	while (read in a and b)
		if (Find(a) == Find(b))
			output(true) ;
		else
			output(false);
}
```
>æ³¨ï¼šè¿™æ˜¯ä¸€ç§*åŠ¨æ€çš„(dynamic)*ï¼Œ*åœ¨çº¿(on-line)* ç®—æ³•
>+ åŠ¨æ€ï¼šåœ¨ç®—æ³•æ‰§è¡Œè¿‡ç¨‹ä¸­ï¼Œ`Union()`ä¼šéšæ—¶æ”¹å˜é›†åˆ

---
å¹¶æŸ¥é›†æœ‰ä»¥ä¸‹å±æ€§ï¼š
+ é›†åˆçš„ **å…ƒç´ (Elements)**ï¼š$1, 2, 3, \dots, N$
>åˆå§‹çŠ¶æ€ï¼šæœ‰$N$ä¸ªé›†åˆï¼Œæ¯ä¸ªé›†åˆä»…æœ‰1ä¸ªå…ƒç´ 
+ å¯¹äºä¸€ç»„é›†åˆ$S_1, S_2, \dots \dots$ï¼Œå¦‚æœæ»¡è¶³$S_i \cap S_j = \emptyset(i \ne j)$ï¼Œç§°è¿™äº›é›†åˆä¸º**ä¸ç›¸äº¤(disjoint)**
	>å¦‚ä½•åœ¨ç¨‹åºä¸­è¡¨ç¤ºè¿™ç§æ•°æ®ç»“æ„ï¼Ÿâ€”â€”**æ ‘**ï¼Œå¹¶æ³¨æ„æŒ‡é’ˆåº”==ä»å­©å­èŠ‚ç‚¹æŒ‡å‘çˆ¶èŠ‚ç‚¹==

+ **è¿ç®—(Operations)**
	+ `Union(i, j)`ï¼š ç”¨$S = S_i \cup S_j$å–ä»£$S_i$å’Œ$S_j$
	+ `Find(i)`ï¼šæ‰¾åˆ°åŒ…å«å…ƒç´ $i$çš„é›†åˆ$S_k$

## Basic Data Structure

``` c
// Declaration
#ifndef _DisjSet_H

typedef int DisjSet[NumSet + 1];
typedef int SetType;
typedef int ElementType;

void Initialize(DisjSet S);
void SetUnion(DisjSet S, SetType Root1, SetType Root2);
SetType Find(ElementType X, DisjSet S);

#endif // _DisjSet_H
```

### `Union(i, j)`
>æ€è·¯ï¼šä»¤$S_i$ä¸º$S_j$çš„å­æ ‘ï¼ˆåè¿‡æ¥ä¹Ÿè¡Œï¼‰ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œæˆ‘ä»¬å°†å…¶ä¸­ä¸€æ£µæ ‘çš„æ ¹èŠ‚ç‚¹æŒ‡å‘å¦ä¸€æ£µæ ‘çš„æ ¹èŠ‚ç‚¹

![](Images/C8/Quicker_20240410_164944.png)

å¦‚ä½•å®ç°ï¼Ÿ
+ æ–¹æ³•1â€”â€”æ•°ç»„+æŒ‡é’ˆ(ä¸æ¨èâŒ)
	![](Images/C8/Quicker_20240410_165101.png)
+ æ–¹æ³•2â€”â€”åˆ©ç”¨æ•°ç»„çš„*ç´¢å¼•*ï¼ˆå› ä¸ºé›†åˆçš„å…ƒç´ éƒ½æ˜¯æ­£æ•´æ•°ï¼‰ğŸ‘
	$$
	S[i] = \begin{cases}\text{the element's parent} &,\ \text{if the element isn't a root} \\ 0 &,\ \text{if the element is a root}\end{cases}
	$$
 	>æ³¨ï¼šç´¢å¼•ä»**1**å¼€å§‹

	ğŸŒ°
	![](Images/C8/Quicker_20240410_165640.png)
	å˜åŒ–å
	![](Images/C8/Quicker_20240410_165703.png)
	
	ä»£ç å®ç°ï¼š
``` c
void Initialize(DisjSet S)
{
	int i;

	for (i = NumSets; i > 0; i--)
		S[i] = 0;
}
```

``` c
void SetUnion(DisSet S, SetType Rt1, SetType Rt2)
{
	S[Rt2] = S[Rt1];
}
```
>æ—¶é—´å¤æ‚åº¦ï¼š$O(1)$

### `Find(i)`

+ æ–¹æ³•1â€”â€”æ ‘çš„èŠ‚ç‚¹æœ‰ä¸€ä¸ª`parent`å­—æ®µï¼Œåˆ©ç”¨å®ƒå¾—åˆ°æ•´æ£µæ ‘çš„æ ¹èŠ‚ç‚¹(è¿˜æ˜¯ä¸æ¨èâŒ)
	![](Images/C8/Quicker_20240412_152330.png)
+ æ–¹æ³•2
	ä»£ç å®ç°ï¼š
``` c
SetType Find(ElementType X, DisSet S)
{
	for (; S[X] > 0; X = S[X]);
	return X;
}
```
>(æœ€åæƒ…å†µ)æ—¶é—´å¤æ‚åº¦ï¼š$O(N)$ï¼ˆä¸$X$çš„æ·±åº¦æœ‰å…³ï¼Œ$N$ä¸ºæ•´ä¸ªå¹¶æŸ¥é›†çš„èŠ‚ç‚¹ä¸ªæ•°ï¼‰

### Analysis

å› ä¸º`union()`å’Œ`find()`æ“ä½œå¾€å¾€æ˜¯æˆå¯¹å‡ºç°çš„ï¼Œå› æ­¤è¦åˆ†æè¯¥ç®—æ³•çš„å¤æ‚åº¦ï¼Œéœ€è¦è€ƒè™‘æ‰§è¡Œä¸€ç³»åˆ—çš„`union()` + `find()`è¿ç®—

ä»£ç å®ç°
``` c
// ä½¿ç”¨ä¸Šè¿°ç®—æ³•å®ç°çš„å¹¶æŸ¥è¿ç®—
{
	Initialize S[i] = {i} for i = 1,..., 12;
	for (k = 1; k <= Size; k++) // å¯¹äºæ¯ä¸€å¯¹i~j
		if (Find(i) != Find(j))
			SetUnion(Find(i), Find(j));  // æ³¨æ„ï¼šUnionæ—¶æœ€å¥½åˆå¹¶çš„æ˜¯ä¸¤æ£µæ ‘çš„æ ¹èŠ‚ç‚¹
}
```

è€ƒè™‘æœ€åæƒ…å†µï¼š`union(2, 1), find(1); union(3, 2), find(2); ...... union(N, N - 1), find(1);`ï¼Œè¿™äº›æ“ä½œæœ€ç»ˆä½¿ä¸€æ£µæ ‘é€€åŒ–æˆä¸€ä¸ªé“¾è¡¨ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º$\Theta(N^2)$
![](Images/C8/Quicker_20240410_170917.png)

## Smart Union Algorithms

### Union-by-Size

>æ ¹æ®**è§„æ¨¡(size)** åˆå¹¶æ ‘â€”â€”æ€»æ˜¯å°†è§„æ¨¡å°çš„æ ‘åˆå¹¶åˆ°è§„æ¨¡å¤§çš„æ ‘ä¸Šï¼Œä»¤`S[Root] = -size`ï¼Œåˆå§‹åŒ–ä¸º-1

*å¼•ç†*ï¼šä»¤æ ‘$T$ä¸ºé€šè¿‡union-by-sizeæ–¹æ³•æ„é€ å‡ºçš„ï¼Œä¸”æœ‰$N$ä¸ªèŠ‚ç‚¹ï¼Œåˆ™ï¼š
$$
height(T) \le \lfloor \log_2N \rfloor + 1
$$
>è¯æ˜ï¼šåˆ©ç”¨æ•°å­¦å½’çº³æ³•

å› æ­¤`Find()`çš„æ—¶é—´å¤æ‚åº¦å˜ä¸º$O(\log N)$

æ—¶é—´å¤æ‚åº¦ï¼š$O(N + M \log N)$ï¼ˆè¿›è¡Œ$N$æ¬¡åˆå¹¶æ“ä½œå’Œ$M$æ¬¡æŸ¥æ‰¾æ“ä½œåï¼‰

``` c
void SetUnion(DisjSet S, SetType Root1, SetType Root2)
{
    if (Root1 == Root2)         // å¦‚æœæ˜¯åŒä¸€æ£µæ ‘ï¼Œå•¥éƒ½ä¸ç”¨åš
        return;
    if (S[Root2] < S[Root1])    // å¦‚æœRoot2å¯¹åº”æ ‘çš„è§„æ¨¡æ›´å¤§
    {
        S[Root2] += S[Root1];
        S[Root1] = Root2;
    }
    else                        // å¦‚æœRoot1å¯¹åº”æ ‘çš„è§„æ¨¡æ›´å¤§
    {
        S[Root1] += S[Root2];
        S[Root2] = Root1;
    }
}
```

>æ³¨ï¼šæ ‘çš„é«˜åº¦ $\le \log N + 1$

### Union-by-Height(rank)

>æ ¹æ®**é«˜åº¦(height)** åˆå¹¶æ ‘â€”â€”æ€»æ˜¯å°†çŸ®çš„é‚£æ£µæ ‘åˆå¹¶åˆ°é«˜çš„é‚£æ£µæ ‘ä¸Šï¼Œå› æ­¤æ¯æ¬¡`Union()`åæ ‘çš„é«˜åº¦æœ€å¤šå¢åŠ 1ï¼ˆå½“2æ£µæ ‘é«˜åº¦ç›¸åŒæ—¶ï¼‰

ä»£ç å®ç°ï¼š
``` c
void SetUnion(DisjSet S, SetType Root1, SetType Root2)
{
	if (S[Root2] < S[Root1])
		S[Root1] = Root2;
	else
	{
		if (S[Root1] == S[Root2])
			S[Root1]--;
		S[Root2] = Root1;
	}
}
```

>ğŸŒŸè®°å¾—åœ¨è°ƒç”¨`Union()`å‡½æ•°æ—¶ï¼Œ==å‚æ•°ä¸­çš„ä¸¤ä¸ª`root`ä¸€å®šè¦å…ˆè°ƒç”¨`Find`==ï¼Œç±»ä¼¼`Union(S, Find(x1), Find(x2))`ï¼Œå› ä¸ºæˆ‘ä»¬è¦åˆå¹¶2ä¸ªå®Œæ•´çš„å¹¶æŸ¥é›†ï¼Œè€Œä¸æ˜¯2ä¸ªèŠ‚ç‚¹ã€‚

## Path Compression

>ç»è¿‡ä¸Šè¿°æ”¹è¿›ï¼Œ`Union`ç®—æ³•çš„æ€§èƒ½å·²ç»ä¸èƒ½å†æå‡äº†ï¼Œå› æ­¤æˆ‘ä»¬è€ƒè™‘æ”¹è¿›`Find`ç®—æ³•ã€‚äºæ˜¯æˆ‘ä»¬ä¾¿ç”¨åˆ°äº†**è·¯å¾„å‹ç¼©(path compression)** çš„æ–¹æ³•â€”â€”å¯¹äºä»æ ¹èŠ‚ç‚¹åˆ°$X$è·¯å¾„ä¸Šçš„æ¯ä¸ªèŠ‚ç‚¹ï¼Œå°†å®ƒçš„çˆ¶èŠ‚ç‚¹è®¾ä¸ºæ ¹èŠ‚ç‚¹

ç¤ºæ„å›¾ï¼š
![](Images/C8/Quicker_20240421_170311.png)

ä»£ç å®ç°ï¼š
``` c
// algorithm1--recursion
SetType Find(ElementType X, DisSet S)
{
	if (S[X] <= 0)
		return X;
	else
		return S[X] = Find(S[X], S); // è®©Xçš„çˆ¶èŠ‚ç‚¹ä¸ºXåŸæ¥çˆ¶èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹
}
```

``` c
// algorithm2--iteration
SetType Find(ElementType X, DisSet S)
{
	ElementType root, trail, lead;
	for (root = X; S[root] > 0; root = S[root]); // find the root
	for (trail = X; trail != root; trail = lead) 
	// å°†è·¯å¾„ä¸Šçš„æ‰€æœ‰èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹éƒ½è®¾ä¸ºæ ¹èŠ‚ç‚¹
	{
		lead = S[trail];
		S[trail] = root;
	} // collapsing
	return rootl
}
```
>æ³¨ï¼š
>+ è™½ç„¶è¿™ç§ç®—æ³•ç›¸è¾ƒäºä¸Šä¸€ç§ï¼ŒæŸ¥æ‰¾å•ä¸ªå…ƒç´ çš„é€Ÿåº¦å˜æ…¢ï¼ˆå› ä¸ºå¤šäº†ä¸€æ¬¡èµ‹å€¼ï¼‰ï¼›ä½†æ˜¯å¯¹äºæŸ¥æ‰¾æ•´ä¸ªåºåˆ—çš„å…ƒç´ ï¼Œè¿™ä¸ªç®—æ³•çš„é€Ÿåº¦æ›´å¿«ï¼ˆå› ä¸ºå¤šå‡ºæ¥çš„èµ‹å€¼**å‹ç¼©**äº†æ•´æ£µæ ‘ï¼Œå¯¹äºé¢‘ç¹çš„åˆå¹¶æ“ä½œæ˜¾ç„¶æ˜¯æœ‰åˆ©çš„ï¼‰
>+ è¯¥æ–¹æ³•ä¸*æŒ‰é«˜åº¦åˆå¹¶æ ‘*çš„æ–¹æ³•ä¸å…¼å®¹ï¼Œå› ä¸ºæ ‘çš„é«˜åº¦å‘ç”Ÿæ”¹å˜ã€‚æ‰€ä»¥æ¨èä½¿ç”¨*union-by-size*

## Worst Case for Union-by-Rank and Path Compression

>å¹¶æŸ¥é›†çš„å®ç°è¾ƒä¸ºç®€å•ï¼Œä½†è¦åˆ†æå®ƒçš„æ—¶é—´å¤æ‚åº¦ç›¸å½“å›°éš¾ã€‚ä¸‹é¢çš„å†…å®¹ä»…ä¾›å‚è€ƒï¼Œè€ƒè¯•ä¸åšè¦æ±‚ã€‚

**å¼•ç†**ï¼šä»¤$T(M, N)$ä¸ºå¤„ç†æ··åˆè¿ç®—$M \ge N$ æŸ¥æ‰¾è¿ç®—å’Œ$N - 1$æ¬¡åˆå¹¶è¿ç®—çš„æ‰€éœ€æœ€å¤§æ—¶é—´ï¼Œé‚£ä¹ˆå¯¹äºæ­£å¸¸æ•°$k_1, k_2$ï¼š
$$
k_1M \alpha(M, N) \le T(M, N) \le k_2M \alpha(M, N)
$$
å³å¹¶æŸ¥é›†æœ€åæƒ…å†µçš„æ—¶é—´å¤æ‚åº¦ä¸ºï¼š$\Theta(M\alpha (M, N))$

**é˜¿å…‹æ›¼å‡½æ•°(Ackermann's Function)**ï¼š$\alpha (M, N)$ ^ab877c
$$
A(i, j) = 
\begin{cases}
2^j & i = 1 \text{ and } j \ge 1 \\
A(i - 1, 2) & i \ge 2 \text{ and } j = 1 \\
A(i - 1, A(i, j - 1)) & i \ge 2 \text{ and } j \ge 2
\end{cases}
$$
[è¯¦ç»†ä»‹ç»](http://mathworld.wolfram.com/AckermannFunction.html)
>æ³¨ï¼šå³ä½¿$i, j$æ•°å­—å¾ˆå°ï¼Œ$A(i, j)$ç»“æœå¯èƒ½ä¹Ÿéå¸¸å¤§ï¼Œæ¯”å¦‚$A(2, 4) = 2^{65536}$

$\alpha (M, N) = \min\{ i\ge 1 | A(i, \lfloor M / N \rfloor )> \log N\} \le O(\log^* N) \le 4$
>æ³¨ï¼š$\log^*N$æ˜¯é˜¿å…‹æ›¼å‡½æ•°çš„*åå‡½æ•°*ï¼Œä»£è¡¨ç”¨äº$N$çš„å¯¹æ•°çš„æ¬¡æ•°ï¼Œä½¿å…¶æœ€ç»ˆç»“æœ$\le 1$ã€‚æ¯”å¦‚ä¸Šä¾‹ä¸­$\log^* 2^{65536} = 5$ï¼Œå› ä¸º$\log\log\log\log\log(2^{65536}) = 1$

^e5be9e

## An Application

åº”ç”¨ï¼šè®¡ç®—æœºç½‘ç»œä¸­çš„æ–‡ä»¶ä¼ è¾“ï¼ˆå…·ä½“å†…å®¹è§è¯¾æœ¬$P_{279}$ï¼Œä¹Ÿå¯ä»¥çœ‹çœ‹ä¸‹é¢çš„ç¼–ç¨‹é¢˜ï¼‰

åç»­ç« èŠ‚ä¸­ä¼šæœ‰æ›´å¥½çš„åº”ç”¨

## Problems

>2-1. The array representation of a disjoint set containing numbers 0 to 8 is given by { 1, -4, 1, 1, -3, 4, 4, 8, -2 }. Then to union the two sets which contain 6 and 8 (with union-by-size), the index of the resulting root and the value stored at the root are:
>A. 1 and -6
>B. 4 and -5
>C. 8 and -5
>D. 8 and -6

**B**
è¿™é¢˜å¾ˆç®€å•ï¼Œåªè¦ç”»ä¸€ä¸‹å›¾å°±okäº†~~ï¼ˆå½“æ—¶è„‘å­æ²¡é•¿ï¼‰~~

---
**7-1 File Transfer**

We have a network of computers and a list of bi-directional connections. Each of these connections allows a file transfer from one computer to another. Is it possible to send a file from any computer on the network to any other?

**Input Specification:**

Each input file contains one test case. For each test case, the first line containsÂ NÂ (2â‰¤Nâ‰¤104), the total number of computers in a network. Each computer in the network is then represented by a positive integer between 1 andÂ N. Then in the following lines, the input is given in the format:

```
I c1 c2  
```

whereÂ `I`Â stands for inputting a connection betweenÂ `c1`Â andÂ `c2`; or

```
C c1 c2    
```

whereÂ `C`Â stands for checking if it is possible to transfer files betweenÂ `c1`Â andÂ `c2`; or

```
S
```

whereÂ `S`Â stands for stopping this case.

**Output Specification:**

For eachÂ `C`Â case, print in one line the word "yes" or "no" if it is possible or impossible to transfer files betweenÂ `c1`Â andÂ `c2`, respectively. At the end of each case, print in one line "The network is connected." if there is a path between any pair of computers; or "There areÂ `k`Â components." whereÂ `k`Â is the number of connected components in this network.

**Sample Input 1:**

```in
5
C 3 2
I 3 2
C 1 5
I 4 5
I 2 4
C 3 5
S
```

**Sample Output 1:**

```out
no
no
yes
There are 2 components.
```

**Sample Input 2:**

```in
5
C 3 2
I 3 2
C 1 5
I 4 5
I 2 4
C 3 5
I 1 3
C 1 5
S
```

**Sample Output 2:**

```out
no
no
yes
yes
The network is connected.
```

my code
``` c
#include <stdio.h>
#include <math.h>
#define SIZE 100001

int s[SIZE];

void Init(int n);
int Find(int x);
void Union(int n1, int n2);
void CheckCnt(int n1, int n2);
void JoinCnt(int n1, int n2);
void CheckAll(int n);

int main()
{
    int n, i;
    char opt;
    int num1, num2;

    scanf("%d", &n);
    getchar();
    Init(n);
    opt = getchar();
    while (opt != 'S')
    {
        scanf("%d%d", &num1, &num2);
        getchar();
        if (opt == 'C')      
            CheckCnt(num1, num2);            
        else if (opt == 'I')
            JoinCnt(num1, num2);
        opt = getchar();
    }

    CheckAll(n);
    
    return 0;
}

void Init(int n)
{
    int i;
    for (i = 1; i <= n; i++)
        s[i] = -1;
}

int Find(int x)
{
    if (s[x] <= 0)
        return x;
    else 
        return s[x] = Find(s[x]);
}

void Union(int n1, int n2)
{
    if (n1 == n2)
        return;
    if (s[n2] < s[n1])
    {
        s[n2] += s[n1];
        s[n1] = n2;
    }
    else
    {
        s[n1] += s[n2];
        s[n2] = n1;
    }
}

void CheckCnt(int n1, int n2)
{
    if (Find(n1) == Find(n2))
        printf("yes\n");
    else
        printf("no\n");
}

void JoinCnt(int n1, int n2)
{
    Union(Find(n1), Find(n2)); // Important!
}

void CheckAll(int n)
{
    int i;
    int cnt = 0;

    for (i = 1; i <= n; i++)
    {
        if (s[i] <= 0)
            cnt++;       
    }
    if (cnt == 1)
        printf("The network is connected.\n");
    else if (cnt > 1)
        printf("There are %d components.\n", cnt);
}
```