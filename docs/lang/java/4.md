---
counter: true
---

# Advanced Feature

## Exception Handling and Text I/O

### Exception

**异常**(exception)是程序运行过程中出现的非正常情况，以对象的形式包装错误信息，通过抛出和捕获机制让开发者能够优雅地处理程序故障。

- 异常类型：

    <div style="text-align: center">
        <img src="images/lec4/6.png" width=80%>
    </div>

    - `Exception` 类表示**异常**，描述由程序和外部条件导致的错误，可以在程序中被捕获和处理
        - `RuntimeException` 类表示**运行时异常**，由程序错误导致，需要修改代码才能修复
            - 比如不良的转型、访问越界数组、数值错误等
    - `Error` 类表示**系统错误**(system errors)
        - JVM 发生了不可恢复的故障，例如内存溢出
        - 这种错误很少发生，若发生，只能通知用户，并尝试优雅地终止程序（不能恢复）

- 异常还可以分为：
    - **未检查型异常**(unchecked exception)：包括 `RuntimeException`、`Error` 以及它们的子类，在多数情况下反映了程序中不可恢复的逻辑错误
        - `NullPointerException`：在给引用变量分配对象之前通过该引用变量访问对象时抛出
        - `IndexOutOfBoundsException`：访问数组中超出数组边界的元素时抛出
        - 为了避免过度使用 `#!java try-catch` 块而变得繁琐，Java 不强制要求编写代码来捕获这类异常
    - **检查型异常**(checked exception)：其他所有异常，此时编译器会强制程序员检查和处理异常
        - 如果一个方法声明了检查型异常，那么调用它的时候必须将其放在 `#!java try-catch` 块中，或者通过声明抛出该异常

        ??? example "例子"

            <div class="grid" markdown>

            ```java hl_lines="5"
            void p1() {
                try {
                    p2();
                }
                catch (IOException ex) {
                    ...
                }
            }
            ```

            ```java hl_lines="1"
            void p1() throws IOException {
                p2();
            }
            ```

            </div>

- 声明异常：每个方法必须说明它可能抛出的检查型异常类型

    ```java
    public void myMethod() 
    throws IOException, OtherException
    ```

- 抛出异常：当程序检测到错误时，程序可以创建一个适当异常类型的实例并抛出它
    - 何时该抛出异常：
        - 方法中发生异常
        - 若希望调用者处理该异常，应该创建一个异常对象并将其抛出
        - 如果可以在发生异常的方法中处理它，则无需抛出

    ```java
    throw new TheException();

    TheException ex = new TheException();
    throw ex;
    ```

    ??? example "例子"

        ```java
        public void setRadius(double newRadius)
        throws IllegalArgumentException {
            if (newRadius >= 0)
                radius = newRadius;
            else
                throw new IllegalArgumentException(
                            "Radius cannot be negative");
        }
        ```



- 捕捉异常：

    ```java
    try {
        // Statements that may throw exceptions
    } catch (Exception1 exVar1) {
        // handler for exception1;
    } catch (Exception2 exVar2) {
        // handler for exception2;
    }
    ...
    catch (ExceptionN exVar3) {
        // handler for exceptionN;
    }
    ```

    - 可以使用多个 `#!java catch` 语句来捕获 `#!java try` 语句块中可能发生的多种异常
    - 异常发生后，JVM 会**由上而下来检测**当前 `#!java catch` 语句块所捕获的异常是否与 `#!java try` 语句块中某个发生的异常匹配；若匹配，则不执行其他的 `#!java catch` 语句块
    - 如果多个 `#!java catch` 语句块捕获的是**同种类型**的异常，则捕获**子类**异常的 `#!java catch` 语句块要放在捕获父类异常的 `#!java catch` 语句块前面

- 重新抛出异常：

    ```java hl_lines="6"
    try {
        // statements;
    } catch(TheException ex) {
        // perform operations before exits;
        throw ex;
    }
    ```

- `#!java finally` 子句：无论程序使用何种方式退出 `#!java try-catch` 块，该子句内的代码都会被执行
    
    ```java hl_lines="7-9"
    try {
        // statements;
    } catch(TheException ex) {
        // handling ex;
    } finally {
        // finalStatements;
    }
    ```
    
    - 更具体的，finally 块会在以下情况发生之后执行：
        - `#!java try` 块中的代码正常执行完毕
        - 在 `#!java try` 块中抛出异常
        - 在 `#!java try` 块中执行 `#!java return`, `#!java break`, `#!java continue`
        - `#!java catch` 块中代码执行完毕
        - 在 `#!java catch` 块中抛出异常
        - 在 `#!java catch` 块中执行 `#!java return`, `#!java break`, `#!java continue`

    - 注意：如果在 `#!java catch` 块中抛出异常（或者 `#!java return` 等情况），则 `#!java try-catch` 块之后的代码不会执行，但是 `#!java finally` 中的代码始终会执行

        ??? example "例子"

            ```java hl_lines="9 14"
            try {
                statement1;
                statement2;
                statement3;
            } catch(Exception1 ex) {
                handling ex;
            } catch(Exception2 ex) {
                handling ex;
                throw ex;        // (1)
            } finally {
                finalStatements;
            }

            Next statement;      // (2)
            ```

            1.  重新抛出异常，将控制权转移给调用者
            2.  这条语句不会执行，因为已经抛出异常了

    - 使用 `#!java finally` 块释放资源
    - `#!java finally` 块不能抛出异常
        - 因为如果在 `#!java finally` 块中抛出异常，`#!java try-catch` 块的异常就不能抛出，外部捕捉到的异常就是 `#!java finally` 块中的异常信息，而 `#!java try-catch` 块中发生的真正的异常堆栈信息则丢失了

- 抛出自定义异常异常时带上原始异常信息
- 打印异常信息时带上异常堆栈

    ```java hl_lines="6"
    public void method3() {
        try {
            method2();
        } catch(MyException e) {
            // 对异常进行处理
            e.printStackTrace(); // 打印异常信息
        }
    }
    ```

- 守护线程中需要捕捉 `RuntimeException`
    - **守护线程**是指在需要长时间运行的线程，其生命周期一般和整个程序的时间一样长，用于提供某种持续的服务
    - 因此需要对 `RuntimeException` 进行保护，避免因为某一次偶发的异常而导致线程被终止

- 使用异常时需注意：异常处理通常需要更多的时间和资源，因为它需要实例化一个新的异常对象、回滚调用栈并将错误传播到调用方法
    - 所以不要用异常来处理简单且在预期内的情况

- 定义自定义异常类
    - 尽可能使用 API 中已有的异常类
    - 如果预定义的类不够用，通过扩展 `Exception` 或其子类来定义自定义异常类

    ??? example "例子"

        ```java
        /** 自定义异常类，用于处理无效的半径输入 */
        public class InvalidRadiusException extends Exception {
            private double radius;

            /** 构造一个异常对象 */
            public InvalidRadiusException(double radius) {
                super("Invalid radius: " + radius);
                this.radius = radius;
            }

            /** 返回触发异常的半径值 */
            public double getRadius() {
                return radius;
            }
        }

        /** 包含半径设置逻辑的类 */
        public class CircleWithRadiusException {
            /** 圆的半径 */
            private double radius;

            /** 设置新半径，如果半径小于 0 则抛出自定义异常 */
            public void setRadius(double newRadius) throws InvalidRadiusException {
                if (newRadius >= 0) {
                    radius = newRadius;
                } else {
                    throw new InvalidRadiusException(newRadius);
                }
            }
        }
        ```


### Assertions

**断言**(assertions)包含一个**布尔表达式**，该表达式应在程序执行期间为真，可用于确保程序正确性并避免逻辑错误。

- 声明：使用 `#!java assert` 关键字

    ```java
    assert assertion;
    assert assertion : detailMessage;
    ```

    其中 `assertion` 是布尔表达式，`detailMessage` 是基本类型或 `Object` 值

- 执行：
    - Java 会评估断言；如果为假，将抛出 `AssertionError` 异常
    - `AssertionError` 类有一个无参构造函数和七个重载的单参数构造函数，参数类型分别为 `#!java int`、`#!java long`、`#!java float`、`#!java double`、`#!java boolean`、`#!java char` 和 `#!java Object`
    - 对于没有详细信息的断言语句，使用无参的 `AssertionError` 构造函数
    - 对于带有详细信息的断言语句，使用合适的 `AssertionError` 构造函数以匹配消息的数据类型
    - 由于 `AssertionError` 是 `Error` 的子类，当断言为假时，程序会在控制台显示消息并退出

    ??? example "例子"

        ```java
        public class AssertionDemo {
            public static void main(String[] args) {
                int i; int sum = 0;
                for (i = 0; i < 10; i++) {
                    sum += i;
                }
                assert i == 10;
                assert sum > 10 && sum < 5 * 10 : "sum is " + sum;
            }
        }
        ```

- 运行带断言的程序：
    - **默认**情况下在运行时**禁用**断言
    - 要启用断言，需要使用 `–enableassertions` 或 `-ea` 选项
    - 还可以手动禁用断言：使用 `–disableassertions` 或 `-da` 选项

???+ abstract "断言 vs 异常"

    - 断言不应用来替代异常处理
    - 异常处理关注鲁棒性，断言关注正确性
    - 与异常处理一样，断言也不用于常规测试，而是用于内部一致性和有效性检查
    - 不要在 `#!java public` 方法中使用断言进行参数检查


### Text I/O

- `File` 类：用于文件名及其目录路径的包装类
    - 它提供了一个抽象，以机器无关的方式处理文件和路径名的大部分机器相关复杂性
    - 属性和方法汇总：

        <div style="text-align: center">
            <img src="images/lec4/7.png" width=90%>
        </div>

    - 它封装了文件或路径的属性，但不包含用于从/向文件读取/写入数据的方法

- 存储数据的两种方式
    - 文本格式：字符序列，是人类可读的形式
    - 二进制格式：用字节表示的数据项

- 文本 I/O **需要编码和解码**：JVM 在写入字符时将 Unicode 转换为文件特定的编码，在读取字符时将文件特定的编码转换为 Unicode

- 使用 `java.io.PrintWriter` 写数据

    ```java
    PrintWriter(filename: String)     // 为指定文件创建 PrintWriter 对象
    print(s: String): void
    print(c: char): void
    print(cArray: char[]): void
    print(i: int): void
    print(l: long): void
    print(f: float): void
    print(d: double): void
    print(b: boolean): void
    ```

    - 它还包含重载的 `println` 和 `printf` 方法，用法同 `print`，但 `println` 支持换行，`printf` 支持格式字符串（[之前](2.md#formatted-output)介绍过）
    - 可以指定**字符集**，否则会使用运行这个程序的机器的默认编码，可能在不同的机器上有不同的表现

        ```java
        PrintWriter out = new PrintWriter("myfile.txt", "UTF-8");
        ```

    ??? example "例子"

        ```java
        import java.io.PrintWriter;
        import java.io.File;

        public class WriteData {
            public static void main(String[] args) throws Exception {
                java.io.File file = new java.io.File("scores.txt");
                if (file.exists()) {
                    System.out.println("File already exists");
                    System.exit(0);
                }

                // 创建文件
                java.io.PrintWriter output = new java.io.PrintWriter(file);

                // 向文件写入格式化输出
                output.print("John T Smith ");
                output.println(90);
                output.print("Eric K Jones ");
                output.println(85);

                // 关闭文件
                output.close();
            }
        }
        ```

- 使用 `java.util.Scanner` 读数据

    ```java
    Scanner(source: File)        // 创建一个从指定文件读取数据的 Scanner 对象
    Scanner(source: String)      // 创建一个从指定文件读取数据的 String 对象
    close()
    hasNext(): boolean           // 如果 Scanner 的输入中还有另一个 token，则返回 true
    next(): String
    nextByte(): byte
    nextShort(): short
    nextInt(): int
    nextLong(): long
    nextFloat(): float
    nextDouble(): double
    useDelimiter(pattern: String): Scanner    // 设置分隔符模式
    ```

    - 也可以设置字符编码

        ```java
        Scanner in = new Scanner(Paths.get("myfile.txt"), "UTF-8");
        ```


## Binary I/O

### Basics

**二进制 I/O** 不需要额外的转换。

- 将一个字节写入文件时，原始字节会被复制到文件中
- 从文件中读取一个字节时，将返回文件中的确切字节

二进制 I/O 类：

<div style="text-align: center">
    <img src="images/lec4/8.png" width=70%>
</div>

- `InputStream`

    ```java
    // 从输入流中读取下一个字节的数据
    // 返回的字节值为 0 到 255 范围内的 int 值
    // 如果没有可用的字节，因为已到达流的末尾，则返回值 -1
    read(): int

    // 从输入流中读取最多 b.length 字节到数组 b，并返回实际读取的字节数
    // 流结束时返回 -1
    read(b: byte[]): int

    // 从输入流中读取字节并存储到 b[off], b[off+1], ..., b[off+len-1]
    // 返回实际读取的字节数
    // 在流的末尾返回 -1
    read(b: byte[], off: int, len: int): int

    available(): int             // 返回可以从输入流中读取的字节数
    close(): void                // 关闭此输入流并释放与该流相关的任何系统资源
    skip(n: long): long          // 跳过并丢弃此输入流中的 n 字节数据，实际跳过的字节数将被返回
    markSupported(): boolean     // 测试此输入流是否支持 mark 和 reset 方法
    mark(readlimit: int): void   // 标记此输入流中的当前位置
    reset(): void                // 将此流重新定位到上次在该输入流上调用 mark 方法时的位置
    ```

    - 如果在流的末尾继续读取数据，将会发生 `EOFException`；因此使用 `input.available()` 来检查文件结束，当 `input.available() == 0` 时表示文件结束

- `OutputStream`

    ```java
    // 将指定的字节写入此输出流，参数 b 是一个整数值
    // (byte) b 被写入输出流
    write(int b): void

    // 将数组 b 中的所有字节写入输出流
    write(b: byte[]): void

    // 将 b[off], b[off+1], ..., b[off+len-1] 写入输出流
    write(b: byte[], off: int, len: int): void

    close(): void    // 关闭此输出流并释放与该流相关的任何系统资源
    flush(): void    // 刷新此输出流，并强制将任何缓冲的输出字节写出
    ```

- `FileInputStream`
    - 构造函数：

        ```java
        public FileInputStream(String filename)
        public FileInputStream(File file)
        ```

        尝试创建一个不存在的文件的 `FileInputStream` 时，将发生 `java.io.FileNotFoundException`

- `FileOutputStream`
    - 构造函数：

        ```java
        public FileOutputStream(String filename)
        public FileOutputStream(File file)
        public FileOutputStream(String filename, boolean append)
        public FileOutputStream(File file, boolean append)
        ```

    - 如果文件不存在，将会创建一个新文件
    - 如果文件已经存在，
        - 前两个构造函数将删除文件中的当前内容
        - 要保留当前内容并将新数据追加到文件中，请使用最后两个构造函数，并将 `#!java true` 传递给 `append` 参数

- **过滤器流**(filter streams)是用于某种目的过滤字节的流
    - 基本的字节输入流提供了一个只能用于读取字节的读取方法
    - 如果想要读取整数、双精度浮点数或字符串，你需要一个过滤器类来包装字节输入流
    - `FilterInputStream` 和 `FilterOutputStream` 是过滤数据的基类
    - 当需要处理基本数值类型时，使用 `DataInputStream` 和 `DataOutputStream` 来过滤字节

- `DataInputStream`：从流中读取字节，并将它们转换为适当的基本类型值或字符串
    - 继承自 `FileInputStream`，并实现 `DataInput` 接口
    - 方法：

        ```java
        readBoolean(): boolean
        readByte(): byte
        readChar(): char
        readFloat(): float
        readDouble(): double
        readInt(): int
        readLong(): long
        readshort(): short
        readLine(): String
        readUTF(): String
        ```

    - 注意：必须以存储的相同顺序和格式读取数据
    

- `DataOutputStream`：将基本类型值或字符串转换为字节，并将字节输出到流中
    - 继承自 `FileOutputStream`，并实现 `DataOutput` 接口
    - 方法：

        ```java
        writeBoolean(b: boolean): void
        writeByte(v: int): void
        writeBytes(s: String): void
        writeChar(c: char): void
        writeChars(s: String): void
        writeFloat(v: float): void
        writeDouble(v: double): void
        writeInt(v: int): void
        writeLong(v: long): void
        writeShort(v: short): void
        writeUTF(s: String): void
        ```

- `BufferedInputStream` / `BufferedOutputStream`：
    - 没有包含新方法，所有方法继承自 `InputStream` / `OutputStream` 类
    - 但它们利用缓冲区加速 I/O
    - 构造函数：

        ```java
        // Create a BufferedInputStream
        public BufferedInputStream(InputStream in)
        public BufferedInputStream(InputStream in, int bufferSize)

        // Create a BufferedOutputStream
        public BufferedOutputStream(OutputStream out)
        public BufferedOutputStream(OutputStreamr out, int bufferSize)
        ```

- `Reader` 是读取字符流的抽象类，`Writer` 是写入字符流的抽象类

    ```java
    /** Reader */
    // 读取单个字符
    int read()
    // 将字符读入数组
    int read(char[] cbuf)
    // 将字符读入数组的某一部分
    abstract int read(char[] cbuf, int off, int len)
    // 跳过字符
    long skip(long n)
    // 关闭该流并释放与之关联的所有资源
    abstract void close()

    /** Writer */
    // 写入字符数组
    void write(char[] cbuf)
    // 写入字符数组的某一部分
    abstract void write(char[] cbuf, int off, int len)
    // 写入单个字符
    void write(int c)
    // 写入字符串
    void write(String str)
    // 写入字符串的某一部分
    void write(String str, int off, int len)
    // 将指定字符添加到此 writer
    Writer append(char c)
    // 将指定字符序列添加到此 writer
    Writer append(CharSequence csq)
    // 将指定字符序列的子序列添加到此 writer
    Writer append(CharSequence csq, int start, int end)
    // 关闭此流，但要先刷新它
    abstract void close()
    // 刷新该流的缓冲
    abstract void flush()
    ```

    - `InputStreamReader`：字节流转字符流

        ```java
        // 构造方法:
        // 创建一个使用默认字符集的 InputStreamReader
        InputStreamReader(InputStream in)

        // 创建使用给定字符集的 InputStreamReader
        InputStreamReader(InputStream in, Charset cs)

        // 创建使用给定字符集解码器的 InputStreamReader
        InputStreamReader(InputStream in, CharsetDecoder dec)

        // 创建使用指定字符集的 InputStreamReader
        InputStreamReader(InputStream in, String charsetName)

        // 特有方法:
        // 返回此流使用的字符编码的名称
        String getEncoding()
        ```

    - `OutputStreamWriter`：字符流转字节流

        ```java
        // 构造方法:
        // 创建一个使用默认字符编码的 OutputStreamWriter
        OutputStreamWriter(OutputStream out)

        // 创建使用给定字符集的 OutputStreamWriter
        OutputStreamWriter(OutputStream out, Charset cs)

        // 创建使用给定字符集编码器的 OutputStreamWriter
        OutputStreamWriter(OutputStream out, CharsetEncoder enc)

        // 创建使用指定字符集的 OutputStreamWriter
        OutputStreamWriter(OutputStream out, String charsetName)

        // 特有方法:
        // 返回此流使用的字符编码的名称
        String getEncoding()
        ```

    - `BufferedReader`、`BufferedWriter`：字符缓冲流

        ```java
        /** BufferedReader */
        // 构造方法:
        // 创建一个使用默认大小输入缓冲区的缓冲字符输入流
        BufferedReader(Reader in)
        // 创建一个使用指定大小输入缓冲区的缓冲字符输入流
        BufferedReader(Reader in, int sz)
        // 特有方法:
        // 读取一个文本行
        String readLine()

        /** BufferedWriter */
        // 构造方法:
        // 创建一个使用默认大小输出缓冲区的缓冲字符输出流
        BufferedWriter(Writer out)
        // 创建一个使用给定大小输出缓冲区的缓冲字符输出流
        BufferedWriter(Writer out, int sz)
        // 特有方法:
        // 写入一个行分隔符
        void newLine()
        ```

    - `FileReader`：`InputStreamReader` 类的直接子类，用来读取字符文件，使用默认字符编码

        ```java
        // 构造函数
        FileReader(File file)             // 用 File 对象来构造 FileReader
        FileReader(FileDescriptor fd)     // 用文件描述符构造 FileReader
        FileReader(String fileName)       // 用文件的路径名来构造FileReader

        public String getEncoding()       // 返回这个流使用的编码方式
        ```

    - `FileWriter`：`OutputStreamWriter` 类的直接子类，用来写入字符文件，使用默认字符编码

        ```java
        // 还是用 File 对象构造，如果第二个参数为 true 的话，
        // 表示以追加的方式写数据，从文件尾部开始写起
        FileWriter(File file, boolean append)
        // 用文件描述符来构造 FileWriter
        FileWriter(FileDescriptor fd)
        // 用文件描述符来构造，第二个参数为 true 的话，表示以追加的形式写入数据
        FileWriter(FileDescriptor fd, boolean append)
        // 用文件的路径名来构造 FileWriter
        FileWriter(String fileName)
        // 用文件路径名来构造 FileWriter，第二个参数为 true 的话，表示以追加的形式写入文件
        FileWriter(String fileName, boolean append)
        ```


### Object I/O

`ObjectInputStream` / `ObjectOutputStream` 能执行对象的 I/O：

- `ObjectInputStream` 继承自 `InputStream`，并实现了 `ObjectInput` 和 `ObjectStreamConstants` 接口
- `ObjectOutputStream` 继承自 `OutputStream`，并实现了 `ObjectOutput` 和 `ObjectStreamConstants` 接口
- 构造函数：

    ```java
    // Create an ObjectInputStream
    public ObjectInputStream(InputStream in)

    // Create an ObjectOutputStream
    public ObjectOutputStream(OutputStream out)
    ```


### `#!java Serializable`

- `#!java Serializable` 接口：
    - 并非所有对象都可以写入输出流，而可以写入对象流的对象被认为是**可序列化的**(serializable)
    - 可序列化对象是 `java.io.Serializable` 接口的实例，因此可序列化对象的类必须实现 `#!java Serializable`
    - `#!java Serializable` 接口是一个**标记接口**(markder interface)，它没有方法，因此您需要在实现 `#!java Serializable` 的类中添加额外代码
    - 实现此接口使 Java 序列化机制能够自动处理存储对象和数组的过程
    - 凡是实现 `Serializable` 接口的类都有一个表示序列化版本标识符的静态 `#!java long` 类型变量：`#!java private static final long serialVersionUID`，它是根据类名、接口名、成员方法及属性等生成的一个 64 位哈希字段

- `#!java trasient` 关键字：
    - 一个包含非可序列化的实例数据字段的 `#!java Serializable` 的对象**不可以**被序列化
    - 要使此类对象能够被序列化，可以使用 `#!java transient` 关键字标记这些数据字段，以告诉 JVM 在将对象写入对象流时忽略这些字段

    ??? example "例子"

        ```java
        public class Foo implements java.io.Serializable {
            private int v1;
            private static double v2;
            private transient A v3 = new A();
        }
        class A { } // A is not serializable
        ```

        - 当 `Foo` 类的对象被序列化时，只有变量 `v1` 被序列化
        - 变量 `v2` 没有被序列化，因为它是一个静态变量
        - 变量 `v3` 没有被序列化，因为它被标记为 `#!java transient`
        - 如果 `v3` 没有被标记为 `#!java transient`，将会发生 `java.io.NotSerializableException`

- 序列化数组：
    - 当数组中的所有元素可序列化时，该数组可序列化
    - 此时整个数组可以通过 `writeObject` 写入文件，稍后使用 `readObject` 恢复

    ??? example "例子"

        ```java
        public class TestObjectStreamForArray {
            public static void main(String[] args)
                throws ClassNotFoundException, IOException {
                int[] numbers = {1, 2, 3, 4, 5};
                String[] strings = {"John", "Susan", "Kim"};

                try ( // 为 array.dat 创建一个输出流
                    ObjectOutputStream output = new ObjectOutputStream(new 
                        FileOutputStream("array.dat", true));
                ) {
                    // 将数组写入对象输出流
                    output.writeObject(numbers);
                    output.writeObject(strings);
                }

                try ( // 为 array.dat 创建一个输入流
                    ObjectInputStream input = 
                        new ObjectInputStream(new FileInputStream("array.dat"));
                ) {
                    int[] newNumbers = (int[])(input.readObject());
                    String[] newStrings = (String[])(input.readObject());

                    // 显示数组内容
                    for (int i = 0; i < newNumbers.length; i++)
                        System.out.print(newNumbers[i] + " ");
                    System.out.println();

                    for (int i = 0; i < newStrings.length; i++)
                        System.out.print(newStrings[i] + " ");
                }
            }
        }
        ```

- 反序列化后的对象**不需要**调用构造函数重新构造
- 序列前的对象与序列化后的对象**地址不同**，并且实现了**深拷贝**


### The `RandomAccessFile` Class

前面介绍的所有流被称为**只读**或**只写**流，而且这些流的外部文件是**顺序**(sequential)文件，无法在不创建新文件的情况下进行更新，通常需要修改文件或向文件中插入新记录。而 Java 提供了 `RandomAccessFile` 类，支持从随机位置读取和写入文件。

```java
RandomAccessFile(file: File, mode: String)
RandomAccessFile(name: String, mode: String)
close(): void
// 返回从文件开头到下一个 read 或 write 发生位置的偏移量（以字节为单位）
getFilePointer(): long
length(): long
read(): int
read(b: byte[]): int
read(b: byte[], off: int, len: int): int
// 设置从流的开始到下一个 read 或 write 发生的位置的偏移量（以 pos 中指定的字节为单位）
seek(pos: long): void
// 为文件设置新长度
setLength(newLength: long): void
// 跳过 n 字节的输入
skipBytes(int n): int
write(b: byte[]): void
write(b: byte[], off: int, len: int): void
```

随机访问文件中有一个特殊的标记，称为**文件指针**(file pointers)。

- 读写操作发生在文件指针的位置
- 当文件被打开时，文件指针设置在文件的开头
- 向文件读取或写入数据时，文件指针会向前移动到下一个数据

许多 `RandomAccessFile` 中的方法与 `DataInputStream` 和 `DataOutputStream` 中的方法相同，比如 `readInt()`、`readLong()`、`writeDouble()`、`readLine()`、`writeInt()` 和 `writeLong()` 可以在数据输入流或数据输出流以及 `RandomAccessFile` 流中使用。


### Piped I/O

`PipedOutputStream` 和 `PipedInputStream` 分别是管道输出流和管道输入流，它们的作用是**让多线程可以通过管道进行线程间的通讯**。在使用管道通信时，必须将 `PipedOutputStream` 和 `PipedInputStream` 配套使用。

使用管道通信时，大致的流程是：

- 在线程 A 中向 `PipedOutputStream` 中写入数据，这些数据会自动的发送到与 `PipedOutputStream对` 应的 `PipedInputStream`中，进而存储在 `PipedInputStream` 的缓冲中
- 此时，线程 B 通过读取 `PipedInputStream` 中的数据，这样就可以实现线程 A 和线程 B 的通信

`PipedReader` 和 `PipedWriter` 也是管道输入流和输出流。它们和 `PipedInputStream`/`PipedOutputStream` 区别是前者操作的是**字符**，后者是字节。两者的 API 几乎相同，都能输出各种形式的数据，构造函数也几乎相同。


## Collections

**容器对象**(collection object)是指能存储任意数量的其他对象的对象。常用的容器对象包括：

- `List`：以特定顺序存储元素
- `Set`：不允许有重复元素
- `Map`：一组“键-值”对象对

容器类是**泛型类**(generic class)。

```java
private ArrayList<String> notes;
```

要定义一个容器类的变量，我们需要指定两种类型：

- **集合本身**的类型（此处为 `ArrayList`）
- 存储在集合中的**元素**类型（此处为 `String`）

由于 Java 有类型推断功能，所以无需在 `#!java new` 中重复表述元素类型：

```java
import java.util.ArrayList;
public class Notebook {
    private ArrayList<String> notes = new ArrayList();
}
```

相应的对象结构如下：

<div style="text-align: center">
    <img src="images/lec4/3.png" width=60%>
</div>


### Iteration

在容器对象上迭代：

- **索引**

    ```java
    for ( int i = 0; i < lst.size(); i++ ) {
        s += lst.get(i);
    }
    ```

- **for-each**

    ```java
    for ( var x : lst ) {
        s += x;
    }

    public voidlistNotes() {
        for (String note : notes) {
            System.out.println(note);
        }
    }
    ```

- **迭代器**(iterator)

    ```java
    public void listNotes() {
        Iterator<String> it = notes.iterator();
        while (it.hasNext()) {
            System.out.println(it.next());
        }
    }
    ```

    - 迭代器是一种对象，它提供了遍历容器对象中所有元素的功能
    - 此时客户端程序员无需了解或关心该被迭代序列的底层结构
    - 迭代器的工作流程：
        1. 通过调用名为 `#!java iterator()` 的方法，向容器请求一个迭代器；这个迭代器将在首次调用其 `#!java next()` 方法时，准备好返回序列中的第一个元素
        2. 使用 `#!java next()` 获取序列中的下一个对象
        3. 要想检查序列中是否还有更多对象，使用 `#!java hasNext()` 方法
        4. 利用 `#!java remove()` 移除迭代器最后返回的元素


### Implementation

容器实现：实现集合接口的类通常以 `<Implementation-style><Interface>` 的形式命名。下表总结了常见容器的实现：

| Interface | Hash Table | Resizable Array | Balanced Tree | Linked List | Hash Table + Linked List |
| :--------- | :---------- | :--------------- | :------------- | :------------ | :------------------------ |
| Set | `HashSet` |  | `TreeSet` |  | `LinkedHashSet` |
| List |  | `ArrayList` |  | `LinkedList` |  |
| Deque |  | `ArrayDeque` |  | `LinkedList` |  |
| Map | `HashMap` |  | `TreeMap` |  | `LinkedHashMap` |


??? abstract "容器相关术语"

    <div style="text-align: center">
        <img src="images/lec4/4.png" width=40%>
    </div>


### Utilities

`Collections` 类的静态成员：

- `#!java min(Collection)`，`#!java max(Collection)`
- `#!java reverse()`
- `#!java copy(List dest, List src)`
- `#!java fill(List list, Object o)`


### Lists

常用的 List 容器有：

- `List`（接口）：以特定顺序维护元素
- `ArrayList`：使用数组实现，插入和删除偏慢
- `LinkedList`：插入和删除成本低，但随机访问慢

???+ abstract "和其他相近容器的比较"

    ```
    Collection
    ├─ List <- 有序、可重复、带索引
    │ ├─ ArrayList
    │ ├─ LinkedList <- 同时也实现了 Deque
    │ └─ Vector
    │     └─ Stack <- Vector 的子类（古老、同步、官方不推荐）
    ├─Queue <- 一端进、一端出，典型 FIFO
    │  ├─ Deque <- 双端队列，两头都能进出
    │  │   ├─ ArrayDeque <- 数组实现，非同步，最快
    │  │   └─ LinkedList <- 链表实现，也能当 List 用
    │  │
    │  ├─ PriorityQueue <- 按优先级出队，不是 FIFO
    │  └─ ConcurrentLinkedQueue...（并发包里的实现）
    ```


#### ArrayList

>官方文档：<https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html>

下面罗列 `ArrayList` 常用的 API：

- 添加

    ```java
    boolean add(E e)
    void add(int index, E element)
    boolean addAll(Collection<? extends E> c)
    boolean addAll(int index, Collection<? extends E> c)
    ```

- 删除

    ```java
    E remove(int index)
    boolean remove(Object o)
    boolean removeAll(Collection<?> c)
    boolean removeIf(Predicate<? super E> filter)
    protected void removeRange(int fromIndex, int toIndex)
    void clear()
    boolean retainAll(Collection<?> c)
    ```

- 修改

    ```java
    E set(int index, E element)
    void replaceAll(UnaryOperator<E> operator)
    ```

- 查找

    ```java
    E get(int index)
    int indexOf(Object o)
    int lastIndexOf(Object o)
    boolean contains(Object o)
    boolean containsAll(Collection<?> c)
    ```

- 信息

    ```java
    boolean isEmpty()
    int size()
    ```

- 容量

    ```java
    void ensureCapacity(int minCapacity)
    void trimToSize()
    ```

- 生成

    ```java
    Object[] toArray()
    <T> T[] toArray(T[] a)
    Object clone()
    void sort(Comparator<? super E> c)
    List<E> subList(int fromIndex, int toIndex)
    ```

- 迭代

    ```java
    Iterator<E> iterator()
    ListIterator<E> listIterator()
    ListIterator<E> listIterator(int index)
    ```

- 流

    ```java
    Stream<E> stream()
    Stream<E> parallelStream()
    void forEach(Consumer<? super E> action)
    ```

???+ note "`ArrayList` v.s. `Vector`"

    >对于新代码，推荐使用 `ArrayList` 或 `CopyOnWriteArrayList`/`Collections.synchronizedList`，而非 `Vector`。

    实际选型：

    - 单线程 -> `ArrayList`
    - 多线程且读远多于写 -> `CopyOnWriteArrayList`
    - 多线程读写均衡 -> `Collections.synchronizedList(new ArrayList<>())`
    - 老代码/需要与遗留 API 对接 -> 才继续用 `Vector`


### Sets

常用的 Set 容器有：

- `Set`（接口）：加入 `Set` 的所有元素都是唯一的
- `HashSet`：对象必须定义 `hashCode()`
- `TreeSet`：由树结构支持的有序集合

???+ example "例子"

    ```java
    import java.util.HashSet;
    import java.util.Iterator;
    //...
    HashSet<String> mySet = new HashSet<String>();
    mySet.add("one");
    mySet.add("two");
    mySet.add("three");
    Iterator<String> it = mySet.iterator();
    while(it.hasNext()) {
        //call it.next() to get the next object
        //do something with that object
    }
    ```

如何选择合适的 Sets？

- 日常去重：`HashSet`
- 去重 + 插入顺序：`LinkedHashSet`
- 去重 + 排序/区间：`TreeSet`（单线程）或 `ConcurrentSkipListSet`（并发）
- 并发去重：首选 `#!java ConcurrentHashMap.newKeySet()`（JDK8 + 工厂方法），或 `ConcurrentSkipListSet`
- 读多写少且集合小：`CopyOnWriteArraySet`
- `#!java enum` 专用：`#!java EnumSet.allOf(MyEnum.class)`

如果要将用户自定义对象放入 `Set` 中，需注意：

- 必须
    - 正确覆写 `#!java equals()`，包括以下约定（`Object` 规范节选）：
        - 自反：`#!java x.equals(x)` 必须 `#!java true`
        - 对称：`#!java x.equals(y)` <=> `#!java y.equals(x)`
        - 传递：`#!java x.equals(y) && y.equals(z)` => `#!java x.equals(z)`
        - 一致：多次调用结果不变
        - 与 `#!java null` 比较必须返回 `#!java false`

        ???+ code "实现模板（字段比较 + `#!java null` 安全）"

            ```java
            @Override
            public boolean equals(Object o) {
                if (this == o) return true;
                if (!(o instanceof MyKey)) return false;
                MyKey other = (MyKey) o;
                return Objects.equals(this.name, other.name) && this.age == other.age;
            }
            ```

    - 一致地覆写 `#!java hashCode()`
        - 规则：相等对象必须返回相同哈希值，不相等对象尽量分散
        - 一旦对象进入 `HashSet` ，不要修改参与 `hash`/`equals` 的字段，否则“内存泄漏”式丢失对象

        ???+ code "实现模板"

            ```java
            @Override
            public int hashCode() {
                return Objects.hash(name, age);  // 内部调用 Arrays.hashCode
            }
            ```

- 可选（若想让 `TreeSet` / `ConcurrentSkipListSet` 能排序，以下两者二选一即可）
    - 实现 `Comparable<T>`

        ```java
        class MyKey implements Comparable<MyKey> {
            public int compareTo(MyKey o) {
                int c = this.name.compareTo(o.name);
                return (c != 0) ? c : Integer.compare(this.age, o.age);
            }
        }
        ```

    - 提供外部 `Comparator`

        ```java
        Set<MyKey> set = new TreeSet<>(
            Comparator.comparing(MyKey::getName)
                .thenComparingInt(MyKey::getAge));
        ```

???+ example "完整示例"

    ```java
    public final class MyKey implements Comparable<MyKey> {
        private final String name; // 参与 hash/equals/compare
        private final int age;

        public MyKey(String name, int age) {
            this.name = name;
            this.age = age;
        }

        @Override
        public boolean equals(Object o) { /* 见上 */ }

        @Override
        public int hashCode() { /* 见上 */ }
        
        @Override
        public int compareTo(MyKey o) { /* 见上 */ }
        }
    ```


### Maps

常用的 Map 容器有（和 Set 类似）：

- `Map`（接口）
- `HashMap`
- `TreeMap`

???+ example "例子"

    ```java
    HashMap <String, String> phoneBook = new HashMap<String, String>();
    phoneBook.put("Charles Nguyen", "(531) 9392 4587");
    phoneBook.put("Lisa Jones", "(402) 4536 4674");
    phoneBook.put("William H. Smith", "(998) 5488 0123");
    String phoneNumber = phoneBook.get("Lisa Jones");
    System.out.println(phoneNumber);
    ```

哈希(hashing)和哈希码(hash code)：

- 键需要有 `#!java hashCode()` 方法
- 要想将用户自定义类作为 `HashMap` 的键，必须覆写 `#!java equals()` 和 `#!java hashCode()`

???+ note "选择 Map 类"

    === "单线程场景（非同步，最快）"

        | 实现类 | 底层结构 | Key 可为 null | 有序性 | 备注 |
        | :------ | :---------- | :------------ | :------ | :---- |
        | `HashMap` | 数组 + 链表 + 红黑树（JDK8+） | 允许一个 | 无顺序 | 默认首选，O(1) |
        | `LinkedHashMap` | 继承 `HashMap`，再串一条双向链表 | 允许 | 插入顺序或访问顺序（LRU） | 适合做缓存 |
        | `TreeMap` | 红黑树 | 不可 | 键自然顺序或自定义 `Comparator` | O(log n)，支持区间查询 |

    === "多线程场景（并发级别由低到高）"

        | 实现类 | 同步方式 | Key 可为 null | 并发度 | 备注 |
        | :------ | :---------- | :------------ | :------ | :---- |
        | `Hashtable` | 全表锁 | 不可 | 低 | 上古类，别用 |
        | `#!java Collections.synchronizedMap(new HashMap<>())` | 包装后全表锁 | 不可 | 低 | 简单兼容旧代码 |
        | `ConcurrentHashMap` | 分段锁（JDK7）→桶级锁/无锁（JDK8+） | 不可 | 高 | 读写并行，默认首选 |

    === "特殊用途"

        | 实现类 | 特点 |
        | :------ | :------ |
        | `WeakHashMap` | 键是弱引用，GC 自动清理，适合做“键生命周期随对象”的缓存 |
        | `IdentityHashMap` | 用 `==` 比较键，而不是 `equals`，用于图算法、对象拓扑复制 |
        | `EnumMap` | 键必须是同一 `enum` 类型，内部用数组，比 `HashMap` 快且内存省 |

    ---
    tldr 版：

    - 单线程 / 常规：默认 `HashMap`
    - 需要插入/访问顺序：`LinkedHashMap`
    - 需要排序/区间：`TreeMap`（单线程）或 `ConcurrentSkipListMap`（并发）
    - 并发：首选 `ConcurrentHashMap`；别再 `#!java new Hashtable()`


## Generic

关于**泛型**(generic)：

- 泛型提供了一种向编译器传递容器类型信息的方式，以便进行**类型检查**
- 除了**枚举**、**匿名内部类**和 **`Exception` 类**之外，所有类型都可以拥有泛型参数


**泛型类**(generic class)必须指定两种类型：集合本身的类型（此处为 `ArrayList`），以及存储在集合中的元素类型（此处为 `String`）。

```java
private ArrayList<String> notes;
```

---
将类型作为参数：

```java
class Pair<T> {
    T first;
    T second;
}
```

- `T` 是占位符，生成对象时传具体类型
- 实际上 Java 常用占位符为 `E` 而非 `T`（`E` 代表 element）

---
多类型参数：类型参数数量不限制，按位置对应

```java
class Triple<A, B, C> { }
Triple<String, Integer, Double> t = new Triple<>("Hi", 42, 3.14);
```

---
接口可能也会用到泛型类型：

```java
interface Codec<T> {
    T decode(String s);
}

enum IntCodec implements Codec<Integer> {
    INSTANCE;
    public Integer decode(String s) {
        return Integer.valueOf(s);
    }
}
```

---
定义一个简单的泛型类：

```java
public interface List<E> {
    void add(E x);
    Iterator<E> iterator();
}

public interface Iterator<E> {
    E next();
    boolean hasNext();
}
```

---
泛型类里的静态方法：

- 方法前写 `<T>` ，编译器帮你推

```java
public static <T> List<T> asList(T... a) {
    return Arrays.asList(a);
}

// 类型推断
List<String> names = asList("A", "B");
```

???+ example "例子"

    ```java
    public final class Box<T> {
        private T value;
        public Box(T value) { this.value = value; }
        public T get() { return value; }
        public void set(T value){ this.value = value;}
        
        // 静态泛型工厂，方便创建
        public static <E> Box<E> of(E value) { return new Box<>(value); }

        public static void main(String[] args) {
            Box<String> sBox = Box.of("Hello");
            System.out.println(sBox.get()); // Hello
            Box<Integer> iBox = new Box<>(42);
            iBox.set(iBox.get() + 1);
            System.out.println(iBox.get()); // 43
        }
    }
    ```

---
Java 的泛型方式：

- 代码没有多个副本
- 泛型类型声明一次性编译，并转换为一个单独的类文件
- 泛型声明有形式类型参数
- 为形式类型参数使用简洁（如果可能的话，单字符）且富有启发性的名称

---
泛型与子类型(subtyping)：如果 `Foo` 是 `Bar` 的一个子类型（子类或子接口），而 `G` 是某种泛型类型声明，那么 `G<Foo>` **并不是** `G<Bar>` 的子类型。

```java
List<String> ls = new ArrayList<String>();
List<Object> lo = ls;
lo.add(new Object());
String s = ls.get(0);
```

---
**通配符**(wildcard)：

```java
void printCollection(Collection<?> c) {
    for (Object e : c) {
        System.out.println(e);
    }
}

Collection<?> c = new ArrayList<String>();
c.add(new Object());
```

???+ example "例子"

    以下代码实现 Shape 类及其子类：

    <div style="text-align: center">
        <img src="images/lec4/5.png" width=40%>
    </div>


    ```java
    public abstract class Shape {
        public abstract void draw(Canvas c);
    }

    public class Circle extends Shape {
        private int x, y, radius;
        public void draw(Canvas c) { ... }
    }

    public class Rectangle extends Shape {
        private int x, y, width, height;
        public void draw(Canvas c) { ... }
    }

    // To draw them on a canvas
    public void draw(Shape s) {
        s.draw(this);
    }

    public void drawAll(List<Shape> shapes) {
        for (Shape s: shapes) {
            s.draw(this);
        }
    }

    // Bounded wildcards
    public void drawAll(List<? extends Shape> shapes) { ...}
    double sum(List<? extends Number> nums) { /* 只读 */ }
    void fill(List<? super Integer> ints) { /* 只写 */ }
    ```

???+ note "`#!java extends` v.s. `#!java super`"

    `#!java extends` 只能"读"，`#!java super` 只能"写”（相对变量而言）

    | 界限 | 英文含义 | 能放什么 | 能拿什么 | 典型场景 |
    | :------ | :------ | :------ | :------ | :------ |
    | `#!java ? extends Integer` | 上界通配符 | 什么也不能放（除 null） | 只能读出 `Integer` 或其子类 | 消费数据，如求和 |
    | `#!java ? super Integer` | 下界通配符 | 可以写 `Integer` 及其子类 | 只能拿出 `Object`（丧失具体类型） | 生产数据，如填充 |

    ???+ example "例子"

        ```java
        List<? extends Integer> upper = new ArrayList<Integer>();
        Integer i = upper.get(0);  // 读
        upper.add(3);              // 编译失败，不知道具体是 Integer 的哪一级子类型

        List<? super Integer> lower = new ArrayList<Number>();
        lower.add(3);              // 写
        Number n = lower.get(0);   // 读出只能是 Object/Number，丢失具体类型
        ```

---
运行时擦除：

- 泛型只存在于编译期
- 编译后擦除到 `Object` 或通配上限

???+ example "例子"

    ```java
    class Pair<T> {
        T first;
        T second;
    }
    ```

    ```
    $ javap -c -v -p Pair

    T first; // 字节码里 T 被擦成 Object
    descriptor: Ljava/lang/Object;
    ```

对于：

```java
class NumBox<T extends Number> { private T v; }

private java.lang.Number v; // 擦除到 Number，而非 Object
```

OpenJDK 24 的 `javap -p -v` （ 或 `-c -v` ）为了可读性 ，把擦除后的 `Object` / `Number` 又显示成原泛型符号 `T`，但 `Signature` 属性 `Object` 和字节码指令里仍然是 `Object`。

---
泛型不能做的事：

- `#!java new T()`：擦除后无构造
- `#!java T.class`：无具体类型信息
- `#!java List<int>`：基本类型不能用