---
counter: true
---

# Basic Java

## Elementary Programming

### Identifiers

**标识符**(identifiers)是一个包括字母、数字、下划线(underscores)（`_`）和美元符号（`$`）的字符序列。

- 不能以数字开头
- 不能是保留字，`#!java true`、`#!java false` 和 `#!java null` 也不行
- 可以使任意长度
- 区分大小写


### Variables

变量的声明、赋值和初始化语法和 C/C++ 基本一样。但不同之处在于

- Java **不区分变量的声明和定义**
- Java **不会**对方法内的局部变量赋予一个**默认值**，而使用未初始化的变量会发生**编译错误**


### `#!java final`

`#!java final` 的三种用法：

- 修饰**变量**：
    - `#!java final` 变量是**不可改变的**，但它的值可以在运行时初始化，也可以在编译时初始化，甚至可以放在构造函数中初始化，而不必在声明的时候初始化，所以下面的语句均合法：

        ```java
        final int i = 1;                            // 编译时
        final int i2 = (int)(Math.Random() * 10);   // 运行时
        final int i3;                               // 构造函数里再初始化
        ```

    - 如果修饰类对象，表示这个变量**不可再赋成其它对象**，而不是表示这个对象不可更改

        ```java
        final Value v = new Value(); 
        v = new Value();  // 不允许！
        ```

- 修饰**方法**：表示一个函数不可更改，也就是**不能被重载**了，而不是修饰返回值的
- 修饰**类**：表示**整个类不能被继承**了（自然里面的所有方法也相当于被加了 `#!java final`）

>注：Java 有保留字 `#!java const`，但是没有任何实际功能。


### Numerical Data Types

数值基本类型：

|类型|大小|最小值|最大值|
|:-|:-|:-|:-|
|`#!java byte`|1B|-128|127|
|`#!java short`|2B|-32768|32767|
|`#!java int`|4B|–2,147,483,648|2,147,483,647|
|`#!java long`|8B|–9,223,372,036,854,775,808|9,223,372,036,854,775,807|
|`#!java float`|4B|大约 –3.4E+38，有 7 个有效位|大约 3.4E+38，有 7 个有效位|
|`#!java double`|8B|大约 –1.7E+308，有 15 个有效位|约 1.7E+308，有 15 个有效位|

Java 中整型的范围**与**运行 Java 代码的**机器无关**，解决了平台移植的问题。

读取数字：

```java
nextByte()      // reads an integer of the byte type
nextShort()     // reads an integer of the short type
nextInt()       // reads an integer of the int type
nextLong()      // reads an integer of the long type
nextFloat()     // reads a number of the float type
nextDouble()    // reads a number of the double type
```

数值运算符和 C/C++ 基本一致，故不展开介绍。
    
特殊的数字格式：

```java
145_345.23  // 可以在数字里的任何地方放下划线
0b11001011  // 二进制
// 0x：十六进制；0：八进制
```


### Literals

- 整数字面量
    - 只能赋给整数变量
    - 当字面量太大，变量无法容纳时将会发生编译错误
    - 默认为 `#!java int` 类型；若要指定为 `#!java long` 类型，需要在附加一个 `L` 或 `l` 后缀
- 浮点数字面量
    - 默认为 `#!java double` 类型
    - 若要指定为 `#!java float` 类型，需要在附加一个 `F` 或 `f` 后缀；或者附加一个 `D` 或 `d` 后缀来显式指定 `#!java double`
    - 特殊的浮点数值：
        - 正无穷大：`#!java Double.POSITIVE_INFINITY`
        - 负无穷大：`#!java Double.NEGATIVE_INFINITY`
        - NaN（不是一个数字）：`#!java Double.NaN`
            - 用 `#!java Double.isNaN` 来判断是否是数字


### Type Casting

<figure style=" width: 60%" markdown="span">
    ![](images/lec2/2_dark.png#only-dark)
    ![](images/lec2/2_light.png#only-light)
    <figcaption></figcaption>
</figure>

>实线表示无信息丢失的转换，虚线表示可能有精度损失的转换。

**类型转换**(type casting)分为：

- **隐式**(implicit)转换：
    - 类型拓宽：`#!java double d = 3`
- **显式**(explicit)转换：
    - 类型缩窄：`#!java int i = (int)3.0;`
    - 小数部分截断：`#!java int i = (int)3.9;`

四舍五入：

```java
double x = 9.997;
int nx = (int) Math.round(x);   // 因为 round 返回值为 long，所以还要转换到 int 上
```


## Selections

布尔类型：

- 关键字为 `#!java boolean`，取值只有 `#!java true` 和 `#!java false`
- **整型与布尔值之间不能相互进行转换**
    - 所以当 `even` 为 `#!java boolean` 变量时，`#!java if (even != 0)` 是错的

if-else 语句：

- 基本上和 C/C++ 语法一致
- `#!java else` 自己匹配相同块内最近的 `#!java if` 语句

    ???+ example "例子"

        <div style="text-align: center">
            <img src="images/lec2/3.png" width=60%>
        </div>

switch-case 语句：

- 基本上和 C/C++ 语法一致
- `#!java switch` 语句必须得到 `#!java char / byte / short / int` 类型的值
- `#!java case` 语句的值的类型必须和 `#!java switch` 语句的值相同，且仅支持常量表达式（不能在表达式中包含变量）

条件运算符：`#!java boolean-expression ? exp1 : exp2`

运算符优先级：

``` linenums="1"
var++, var--
+, - (Unary plus and minus), ++var, --var
(type) Casting
! (Not)
*
, /, % (Multiplication, division, and remainder)
+, - (Binary addition and subtraction)
<, <=, >, >= (Relational operators)
==, != (Equality)
^ (Exclusive OR)
&& (Conditional AND) Short-circuit AND
|| (Conditional OR) Short-circuit OR
=, +=, -=, *=, /=, %= (Assignment operator)
```

如果具有相同优先级的运算符彼此相邻，它们的结合性决定了计算顺序：**除了赋值运算符**（它是**右结合**的(right-associative)）之外，所有二元运算符都是**左结合**的(left-associative)。


## Mathematical Functions, Characters, and Strings

### `java.lang.Math` 

- 类常量：`PI`、`E`
- 类方法：
    - 三角函数：

        ```java
        sin(double a)
        cos(double a)
        tan(double a)
        acos(double a)
        asin(double a)
        atan(double a)
        ```

    - 指数函数：

        ```java
        exp(double a)
        log(double a)
        log10(double a)
        pow(double a, double b)
        sqrt(double a)
        ```

    - 舍入函数：

        ```java
        double ceil(double x)
        double floor(double x)
        double rint(double x)     // 舍入到最近的整数；如果离两个整数一样近，那就舍入到偶数
        int round(float x)        // (int) Math.floor(x + 0.5) 
        long round(double x)      // (long) Math.floor(x + 0.5)
        ```

    - `#!java max(a, b)` 和 `#!java min(a, b)`
    - `#!java abs(a)`
    - 随机函数：`random()`，返回 `[0.0, 1.0)` 范围内的随机 `#!java double` 值


### Character Data Type

- Java 字符使用 **Unicode**，占用 **2 个字节**，以 `\u` 开头，表示为四个十六进制数字，从 `\u0000` 到 `\uFFFF`
- 递增运算符 `++` 和递减运算符 `--` 也可以用于 `#!java char` 变量，以获取下一个或前一个 Unicode 字符
- 字符和整数类型间的转换：

    ```java
    int i = 'a';    // Same as int i = (int)'a';
    char c = 97;    // Same as char c = (char)97;
    ```

- 字符类方法：

    ```java
    isDigit(ch)             // 是否为数字
    isletter(ch)            // 是否为字母
    isletterOrDigit(ch)     // 是否为字母或数字
    isLowerCase(ch)         // 是否为小写字母
    isUpperCase(ch)         // 是否为大写字母
    tolowerCase(ch)         // 转小写字母
    toUpperCase(ch)         // 转大写字母
    ```


### `String` Type

- `String` 实际上是 Java 库中的一个预定义类，被称为**引用类型**(reference type)，而不是基本类型(primitive type)
- `String` 对象的简单方法（**实例方法**(instance methods)）：

    ```java
    length()            // 字符串长度
    charAt(index)       // 指定索引下的字符
    concat(s1)          // 和另一个字符串拼接
    toUpperCase()       // 所有字母转大写
    toLowerCase()       // 所有字母转小写
    trim()              // 移除字符串两边的空白字符
    ```

    - 调用实例方法的语法：`referenceVariable.methodName(arguments)`
    - 非实例方法被称为**静态方法**(static methods)，可以在不使用对象的情况下调用

- 比较字符串：

    ```java
    equals(s1)                  // 两个字符串是否相等
    equalsIgnoreCase(s1)        // 同 equals，但大小写不敏感
    compareTo(s1)               // 字符串是否大于 s1，返回一个整数，
                                // 正数/0/负数分别表示比 s1 大/相等/小
    compareToIgnoreCase(s1)     // 同 compareToIgnoreCase，但大小写不敏感
    startswith(prefix)          // 字符串是否以特定前缀开始
    endsWith(suffix)            // 字符串是否以特定后缀结束
    ```

    - 注意：使用 `==` 是在比较两个引用是否指向同一个对象（一般不会这么做，往往是搞错用法了）

- 获取子字符串：

    ```java
    substring(beginIndex)               // 从 beginIndex 开始到最后的子字符串
    substring(beginIndex, endIndex)     // 从 beginIndex 开始到 endIndex - 1
                                        // （不包括 **endIndex**）的子字符串
    ```

- 在字符串中寻找字符或子字符串

    ```java
    indexOf(ch)                 // 字符 ch 第一次出现时的索引，若没找到返回 -1
    indexof(ch, fromIndex)      // 从 fromIndex 开始，字符 ch 第一次出现时的索引，若没找到返回 -1
    indexOf(s)                  // 字符串 s 第一次出现时的索引，若没找到返回 -1
    indexOf(s, fromIndex)       // 从 fromIndex 开始，字符串 s 第一次出现时的索引，若没找到返回 -1

    // 寻找最后一次出现的索引，和前 4 个方法对应
    lastIndexOf(ch)
    lastIndexOf(ch, fromIndex)
    lastIndexOf(s)
    lastIndexOf(s, fromIndex)
    ```

- 字符串与数字的转换：

    ```java
    // 字符串 —> 数字
    int intValue = Integer.parseInt(intString);
    double doubleValue = Double.parseDouble(doubleString);

    // 数字 -> 字符串
    String s1 = String.valueOf(number1);
    String s2 = number2 + "";
    ```

    - 实际上 `valueOf` 做的事是直接调用并返回该对象的 `toString()` 方法（除了 `null` 对象返回字符串 `"null"`），后者是由 `Object` 定义的
        - 对于自定义类，我们可以重写 `toString()` 方法，返回一个包含人类可读的字符串，并能合理描述类的对象的 `String` 对象

- 替换和分割字符串：

    ```java
    // 返回一个新的字符串，将此字符串中所有匹配的字符替换为新字符
    replace(oldChar: char, newChar: char): String
    // 返回一个新的字符串，该字符串将此字符串中的第一个匹配子串替换为新子串
    replaceFirst(oldString: String, newString: String): String
    // 返回一个新的字符串，该字符串将此字符串中所有匹配的子字符串替换为新子字符串
    replaceAll(oldString: String, newString: String): String
    // 返回由 delimiter（分隔符）分割的子字符串组成的字符串数组
    split(delimiter: String): String[]
    ```

    - 支持**正则表达式**(regular expressions)（包括 `matches` 方法）

- 字符串格式：`#!java String.format(format, item1, item2, ..., itemk)`

- `+` 运算（拼接）：

    ```java
    "I’m " + 18     // "I’m 18"
    1 + 2 + "age"   // "3age"
    "age" + 1 + 2   // "age12"
    ```

- 块(block)语法（和 Python 类似）：

    ```java
    String html = """
                    <html>
                    <body>
                        <p>Hello, world</p>
                    </body>
                    </html>
                    """;
    ```

    - 起止各一行 `"""` ，单独占一行（开头 `"""` 后不能直接跟内容）
    - 内容自动去掉公共前缀空白，保留相对缩进

- `String` 是**不可变的**(immutable)，即创建 `String` 实例后内容无法再更改
    - 因此没有任何函数能改变字符串的内容
    - 但声明为 `String` 引用的变量可以在任何时候改变以指向其他 `String` 对象

    ??? info "为什么要“不可变”"

        - 并发/线程安全
            - 无状态：对象只读，天然支持多线程共享，无需同步
            - Race-free：写并发代码时不用担心“读到一半被修改”
        - 哈希与索引
            - hashCode 缓存：计算一次后缓存到字段 `hash` ，后续 `HashMap/get` 直接复用，复杂度从 O(n) -> O(1)
            - Key 可信：作为 `HashMap` / `HashSet` 的 key 时，中途内容变化导致哈希漂移的灾难不可能发生（对比 `char[]` 或 `StringBuilder`）
        - 字符串常量池（StringTable）
            - `intern()` 复用：字面量自动入池，相同内容全局一份，节省堆内存
            - 地址比较：`"foo"=="foo"` 直接返回 `true`，JVM 级别优化
        - 安全性与完整性
            - 类加载器隔离：类名、文件路径、权限字符串一旦传入就无法被篡改，防止“在 check 之后、use 之前”被恶意代码改掉
            - 网络/文件句柄：`new URL("http://xxx")` 的协议、主机名不可变，避免校验后地址被替换
        - 编译器 & JVM 优化
            - 字符串折叠：编译期常量表达式 `"a" + "b"` 直接变成 `"ab"` ，减少运行时拼接
            - 栈上优化：逃逸分析后不可变对象可拆成标量替换，消灭堆分配
            - 共享子串：JDK 7 以前 substring 共享底层 `char[]`（offset + count），避免复制；JDK 7 之后虽然改为复制，但仍保留不可变语义，让 JIT 放心做循环不变量外提等优化

    - 除不可变的 `String` 类型外，还有两个常用的可修改的字符串类型：
        - `StringBuffer`：线程安全，同步，性能稍慢
        - `StringBuilder`：非线程安全，不同步，性能更快

        ```java
        // StringBuilder 示例（单线程）
        StringBuilder sb1 = new StringBuilder("Hello");
        sb1.append(" World");

        // StringBuffer 示例（多线程）
        StringBuffer sb2 = new StringBuffer("Hello");
        sb2.append(" World");
        ```

    - 如果需要不断运算逐渐形成大的字符串，应该使用 `StringBuffer`

        ```java
        StringBuffer sb = new StringBuffer();
        for (int i = 0; i < 100; i++)
            sb.append("" + i);
        String s = sb.toString();
        ```

>更多 `String` 的 API 见[官方文档](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html)。


### Input: The `Scanner` Class

使用步骤：

1. 导入包：`#!java import java.util.Scanner;`
2. 创建对象：连接到输入流（如 `System.in`）
3. 读取数据：调用相应的方法获取输入
4. 关闭资源：使用完毕后关闭流（良好的编程习惯）

???+ example "例子"

    ```java
    import java.util.Scanner;

    public class Test {
        public static void main(String[] args) {
            // 1. 创建 Scanner 对象，读取标准输入
            Scanner sc = new Scanner(System.in);

            System.out.println("请输入一个整数：");
            // 2. 读取数据
            if (sc.hasNextInt()) {
                int num = sc.nextInt();
                System.out.println("你输入的是：" + num);
            }

            // 3. 关闭资源
            sc.close();
        }
    }
    ```

常用读取方法：

- `next()`：读取下一个标记(token)，以空白符（空格、回车等）作为分隔
- `nextLine()`：读取整行内容，直到遇到回车符
- `nextInt()`：将下一个标记解析为 `#!java int` 类型
- `nextDouble()`：将下一个标记解析为 `#!java double` 类型
- `hasNext...()`：判断是否还有下一个指定类型的内容，常用于校验输入

!!! warning "注意事项"

    - `nextInt()` 与 `nextLine()` 混用问题：
        - 当先调用 `nextInt()` 再调用 `nextLine()` 时，`nextInt()` 只会读取数字，而数字后面的回车换行符会留在缓冲区；接着调用的 `nextLine()` 会直接读取到这个回车符，导致看起来好像“跳过”了输入
        - 解决方法：在 `nextInt()` 之后多写一行额外的 `nextLine()` 来消费掉那个多余的回车符
    - 性能问题：内部使用正则表达式进行匹配，虽然功能强大且方便，但读取速度较慢
        - 如果对性能需求敏感，建议改用 `BufferedReader` 以获得更好的性能


### Formatted Output

格式化输出语句：`#!java System.out.printf(format, items)`。其中 `format` 是一个包含字符串和格式说明符的字符串。**格式说明符**(format specifier)指定 item（可能是一个数值、字符、布尔值或字符串）应该如何显示，且都以百分号开始。

常用说明符：

- `%b`：布尔值
- `%c`：字符
- `%d`：整数
- `%f`：浮点数
- `%e`：采用标准科学计数法的数字
- `%s`：字符串

<figure style=" width: 70%" markdown="span">
    ![](images/lec2/4_dark.png#only-dark)
    ![](images/lec2/4_light.png#only-light)
    <figcaption></figcaption>
</figure>

占位符完整格式为：`%[index$][标识]*[最小宽度][.精度]转换符`。

- `%`：占位符的起始字符，若要在占位符内部使用 `%`，则需要写成 `%%`
- `[index$]`：位置索引从 1 开始计算，用于指定对索引相应的实参进行格式化并替换掉该占位符
- `[标识]`：用于增强格式化能力，可同时使用多个 `[标识]`，但某些标识是不能同时使用的
- `[最小宽度]`：用于设置格式化后的字符串最小长度，若使用 `[最小宽度]` 而无设置 `[标识]`，那么当字符串长度小于最小宽度时，则以左边补空格的方式凑够最小宽度
- `[.精度]`：对于浮点数类型格式化使用，设置保留小数点后多少位
- `转换符`：用于指定格式化的样式，和限制对应入参的数据类型

字符、字符串的格式化：

- 占位符格式：`%[index$][标识][最小宽度][转换符]`
- 可用标识：
    - `-`：在最小宽度内左对齐，右边用空格补上
- 可用转换符：
    - `s`：字符串类型
    - `c`：字符类型，实参必须为 `#!java char` 或 `#!java int`、`#!java short` 等可转换为 `#!java char` 类型的数据类型，否则抛 `IllegalFormatConversionException` 异常
    - `b`：布尔类型，只要实参为非 `#!java false` 的布尔类型，均格式化为字符串 `#!java true`，否则为字符串 `#!java false`
    - `n`：平台独立的换行符（与通过 `System.getProperty("line.separator")` 是一样的）

整数的格式化：

- 占位符格式：`%[index$][标识]*[最小宽度]转换符`
- 可用标识：
    - `-`：在最小宽度内左对齐，不可以与 `0` 标识一起使用
    - `0`：若内容长度不足最小宽度，则在左边用 `0` 来填充
    - `#`：对 8 进制和 16 进制，8 进制前添加一个 `0`，16 进制前添加 `0x`
    - `+`：结果总包含一个 `+` 或 `-` 号
    - 空格：正数前加空格，负数前加 `-` 号
    - `,`：只用于十进制，每 3 位数字间用 `,` 分隔
    - `(`：若结果为负数，则用括号括住，且不显示符号

- 可用转换符：
    - `b`：布尔类型
    - `d`：整数类型（十进制）
    - `x`：整数类型（十六进制）
    - `o`：整数类型（八进制）
    - `n`：平台独立的换行符，也可通过 `System.getProperty("line.separator")` 获取

浮点数的格式化：

- 占位符格式：`%[index$][标识][最小宽度][.精度]转换符`
- 可用标识：同整数
- 可用转换符：
    - `b`：布尔类型
    - `n`：换行符
    - `f`：浮点数型（十进制），显示 9 位有效数字，且会进行四舍五入
    - `a`：浮点数型（十六进制）
    - `e`：指数类型（如 9.38e+5）
    - `g`：浮点数型没，比 `%f`，`%a` 长度短些，显示 6 位有效数字，且会进行四舍五入

日期时间的格式化：

- 占位符格式：`%[index$]t转换符`
- 日期转换符：
    - `c`：星期六 十月 27 14:21:20 CST 2007
    - `F`：2007-10-27
    - `D`：10/27/07
    - `r`：02:25:51 下午
    - `T`：14:28:16
    - `R`：14:28
    - `b`：月份简称
    - `B`：月份全称
    - `a`：星期简称
    - `A`：星期全称
    - `C`：年前两位（不足两位补零）
    - `y`：年后两位（不足两位补零）
    - `j`：当年的第几天
    - `m`：月份（不足两位补零）
    - `d`：日期（不足两位补零）
    - `e`：日期（不足两位不补零）

- 时间转换符：
    - `H`：24 小时制的小时（不足两位补零）
    - `k`：24 小时制的小时（不足两位不补零）
    - `I`：12 小时制的小时（不足两位补零）
    - `i`：12 小时制的小时（不足两位不补零）
    - `M`：分钟（不足两位补零）
    - `S`：秒（不足两位补零）
    - `L`：毫秒（不足三位补零）
    - `N`：毫秒（不足 9 位补零）
    - `p`：小写字母的上午或下午标记，如中文为“下午”，英文为pm
    - `z`：相对于 GMT 的时区偏移量，如 +0800
    - `Z`：时区缩写，如 CST
    - `s`：自 1970-1-1 00:00:00 起经过的秒数
    - `Q`：自 1970-1-1 00:00:00 起经过的毫秒


## Loops

- `#!java while` 循环和`#!java do-while` 循环基本上和 C/C++ 一致
- 带标签的 `#!java break` 语句，实现智能跳出语句块（而非跳入）
    - 标签可用在任何语句中，甚至在 `#!java if` 或块语句中

    ```java
    first:for (int j = 0; j < 5; j++) {
        second:for (int i = 0; i < 5; i++) {
            if (i == 0) {
                System.out.println(i);
                break first;
            }
        }
    }
    ```

- `#!java for` 循环除了有一套和 C/C++ 基本一致的版本外，Java 5 引入了更加简洁的 `for-in` 语法，用于数组和容器：

    ```java
    int[] arr = {1, 2, 3, 4, 5};
    for (int num : arr)
        System.out.println(num);
    ```


## Methods

**方法**(methods)是一个被分组在一起以执行某一操作的语句集合。

<div style="text-align: center">
    <img src="images/lec2/5.png" width=70%>
</div>

- **方法签名**(method signature)：方法名和参数列表的组合
- **形式参数**(formal parameters)（形参）：方法头中定义的变量
- **实际参数**(actual parameters)（实参）：调用方法时传递的参数值
- 返回值类型

Java 方法是**按值传参**的，传递的是变量或引用的副本，所以在方法内对参数修改不会改变方法外的变量或引用。

方法的**重载**(overloading)是指在一个类中可以定义多个**名称相同但参数列表不同**的方法。注意区分重载和**重写**(overriding)：

| 特性 | 方法重载 | 方法重写 |
| :--- | :--- | :--- |
| 发生范围 | 同一个类中 | 父子类之间 |
| 方法名 | 必须相同 | 必须相同 |
| 参数列表 | 必须不同 | 必须相同 |
| 返回值 | 可以不同 | 必须相同（或其子类） |
| 判定时间 | 编译阶段 | 运行阶段 |

**模糊调用**(ambiguous invocation)：有时对于方法的调用可能会有两个或更多可能的匹配，但编译器无法确定最具体的匹配，这是一个**编译错误**。

???+ example "例子"

    ```java
    public class AmbiguousOverloading {
        public static void main(String[] args) {
            System.out.println(max(1, 2));
        }

        public static double max(int num1, double num2) {
            if (num1 > num2)
                return num1;
            else
                return num2;
        }

        public static double max(double num1, int num2) {
            if (num1 > num2)
                return num1;
            else
                return num2;
        }
    }
    ```


## Arrays

**数组**(array)是一种表示相同类型数据集合的数据结构。


### Single-Dimensional Arrays

- 数组变量声明：

    ```java
    datatype[] arrayRefVar;
    datatype arrayRefVar[];      // 可以这么写，但不推荐
    ```

- 创建数组：`#!java arrayRefVar = new datatype[arraySize];`
- 一步完成数组的声明和创建：`#!java datatype[] arrayRefVar = new datatype[arraySize];`
- 数组创建后长度固定不变，其值为 `rrayRefVar.length`；并且所有元素会被赋予**默认值**
    - 数值基础类型：`0`
    - `#!java char` 类型：`\u0000`
    - `#!java boolean` 类型：`#!java false`

- 通过索引访问数组元素：`arrayRefVar[index]`，`index` 范围为 `[0, arrayRefVar.length-1]`
- 数组**初始化器**(intializer)：一步完成声明、创建和初始化的简写语法，注意一定要在一条语句内完成，不能拆成多句

    ```java
    double[] myList = {1.9, 2.9, 3.4, 3.5};

    // 以下语句是错误的！
    double[] myList;
    myList = {1.9, 2.9, 3.4, 3.5};
    ```

- 数组分配在**堆**上
- `[]` 运算符被预定义为**检查数组边界**，而且没有指针运算，就不能通过 `a+1` 得到下一个元素
- `main` 函数中的 `String[] args` 参数表示命令行参数；注意 `args[0]` 就是第一个参数，程序名没有存储在 `args` 中
- 复制数组：
    - 如果直接使用赋值语句（比如 `list2 = list1;`），那么这只是让 `list2` 同时引用了 `list1` 的对象，并没有真的创建数组副本（**浅拷贝**）

        <div style="text-align: center">
            <img src="images/lec2/6.png" width=60%>
        </div>

    - 正确实现（**深拷贝**）：
        - 手动实现：新建数组，利用循环逐元素复制

            ```java
            int[] sourceArray = {2, 3, 1, 5, 10};
            int[] targetArray = new int[sourceArray.length];
            for (int i = 0; i < sourceArrays.length; i++)
                targetArray[i] = sourceArray[i];
            ```

        - `#!java System.arraycopy(sourceArray, src_pos, targetArray, tar_pos, length)` 函数
            - 例子：`#!java System.arraycopy(sourceArray, 0, targetArray, 0, sourceArray.length);`
        
        - `#!java Arrays.copyOf(array, length)` 方法
            - 第 2 个参数是新数组的长度，这个方法通常用来改变数组的大小
                - 如果数组元素是数值型，则多余的元素被赋值为 `0`；若是布尔型，则赋值为 `#!java false`
                - 如果长度小于原始数组长度，则只拷贝前面的元素
            - 例子：
            
                ```java
                int[] copiedLuckyNumbers = Arrays.copyOf(luckNumbers, 2 * luckyNumbers.length);
                ```

- **匿名数组**(anonymous array)：数组没有对应的显式引用变量
    - 例子：`#!java printArray(new int[]{3, 1, 2, 6, 4, 2});`（`printArray()` 是自定义函数）

- 虽说 Java **按值传递**参数，但对于数组这种引用类型而言，复制到方法中的参数值是指向数组实际内容的引用，因此修改数组参数是**会实际影响到数组内容的**


### MultiDimensional Arrays

- 声明/创建二维数组：

    ```java
    // 声明
    dataType[][] refVar;

    // 创建数组并赋值
    refVar = new dataType[10][10];
    // 注意：声明时可以缺省第二维的长度，但必须要指明第一维的长度
    refVar = new dataType[10][];    // OK
    refVar = new dataType[][10];    // Error!

    // 二合一
    dataType[][] refVar = new dataType[10][10];

    // 另一种语法
    dataType refVar[][] = new dataType[10][10];
    ```

- 数组初始化器：使用简写记号完成声明 + 创建 + 初始化

    ```java
    int[][] array = {
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9},
        {10, 11, 12}
    };
    ```

- 长度：

    <div style="text-align: center">
        <img src="images/lec2/7.png" width=60%>
    </div>

- 二维数组的每一行可以有不同的长度，这样的数组称为**锯齿状数组**(ragged array)

    ```java
    int[][] matrix = {
        {1, 2, 3, 4, 5},
        {2, 3, 4, 5},
        {3, 4, 5},
        {4, 5},
        {5}
    };

    /**
    matrix.length is 5
    matrix[0].length is 5
    matrix[1].length is 4
    matrix[2].length is 3
    matrix[3].length is 2
    matrix[4].length is 1
    */
    ```


## Wrapper Classes

- **包装类**(wrapper class)：一个其对象包装或包含基本数据类型的类。当我们创建一个包装类的对象时，它包含一个字段，在这个字段中我们可以存储基本数据类型。换句话说，我们可以将基本值包装进包装类对象中。
    - 包装类包括：

        ```java
        Byte
        Short
        Integer
        Long
        Float
        Double
        Char
        Boolean
        ```

- 创建包装对象
    - 所有包装类型的 `#!java public` 构造器 已在 JDK 9 被标记为 `#!java @Deprecated(since="9", forRemoval=true)`，并在 JDK 16 正式移除；现在无论 `#!java new Integer(123)` 还是 `#!java new Double(3.14)` 都会编译失败
    - 官方理由：
        - 构造函数每次强制生成新对象，浪费内存
        - `#!java valueOf` 工厂方法利用内部缓存（-128~127 默认缓存在 IntegerCache）
        - 字符串驻留、`#!java Boolean` 的 `#!java true`/`#!java false` 单例（类的对象有且仅有一个）保持一致语义
        - 为未来值类型（Valhalla）铺路，彻底消灭包装对象
        - 正确的做法：

            ```java
            // 1. 工厂方法（推荐）
            Integer a = Integer.valueOf(123);

            // 2. 自动装箱（语法糖，底层仍调 valueOf）
            Integer b = 123;

            // 3. 字符串解析
            Integer c = Integer.valueOf("123");

            // 4. 若需要创建“绝对新对象”——几乎没这需求，真需要就 new 完后别放入任何缓存
            // （JDK 16 以后已无法做到，必须反射或 MethodHandles，但属于黑魔法）
            ```

- **自动装箱**(auto-box)和**自动拆箱**(auto-unbox)：包装类型和对应的基础类型之间可以直接赋值

    ```java
    class Geeks {
        public static void main(String[] args) {
            int b; // Primitive data type
            Integer a; // Integer wrapper class

            b = 357; // assigning value to primitive

            a = b; // auto-boxing or auto wrapping converting primitive int to Integer object
            
            System.out.println("The primitive int b is: " + b);
            System.out.println("The Integer object a is: " + a);
        }
    }
    ```

- **预生成对象**(pre-created object)：落在以下范围内，用的还是同一对象，否则就会创建新的对象
    - 对于整数类型：-128~127
    - 对于字符类型：0~127
    - 对于布尔：`#!java true` 和 `#!java false`
    - 对于浮点数：没有预生成对象

    ```java
    Integer i1 = 12; // what if 1200
    Integer i2 = 12; // what if 1200
    System.out.println(i1 == i2);  // == 判断两个指针是否指向同一个对象
    // true，如果是 1200（超范围了）就是 false
    ```


## Classes and Objects

### Object-Oriented Programming

**面向对象编程**(object-oriented programming, OOP)是指使用**对象**的编程。

- **对象**(objects)：现实世界中能被唯一识别的实体
    - 一个对象有唯一的身份、状态和行为
    - 对象的**状态**(state)由一组带有当前值的**数据字段**(data fields)（又称为**属性**(properties)）构成
    - 对象的**行为**(behavior)由一组方法定义

- **类**(classes)是定义相同类型对象的构造
    - Java 类使用**变量**来定义数据字段和用于定义行为的方法

???+ example "例子"

    ```java
    class Circle {
        // Data field
        /** The radius of this circle */
        double radius = 1.0;
        
        // Consturctors
        /** Construct a circle object */
        Circle() {
        }

        /** Construct a circle object */
        Circle(double newRadius) {
            radius = newRadius;
        }
        
        // Method
        /** Return the area of this circle */
        double getArea() {
            return radius * radius * 3.14159;
        }
    }
    ```


### Constructors

另外，类提供了一组叫做**构造函数**(constructors)的特殊方法，用于从类中构造对象，并起到初始化对象的作用。

- 没有参数的构造函数被称为**无参构造函数**(no-arg constructor)
- 构造函数名必须与类名相同
- 构造函数没有返回类型，连 `#!java void` 也没有
- 创建对象时要用 `#!java new` 运算符调用构造函数
- **默认构造函数**(default constructors)
    - 定义类时可能没有构造函数，此时一个带有空的函数体的无参构造函数会被**隐式**(implicitly)定义，该函数就是默认构造函数
    - 该函数仅在没有任何显式定义的构造函数时自动提供

- 声明对象引用变量：`#!java ClassName objectRefVar;`
- 声明 + 创建：`#!java ClassName objectRefVar = new ClassName();`
- 访问对象成员：
    - 引用对象数据：`#!java objectRefVar.data`
    - 调用对象方法：`#!java objectRefVar.methodName(arguments)`

- 数据字段的默认值
    - 数据字段的默认值为：
        - 引用类型：`#!java null`
        - 数值类型：`0`
        - 布尔类型：`#!java false`
        - 字符类型：`#!java \u0000`

    - 注意：Java **不会**为方法内的局部变量赋予默认值，直接使用会发生编译错误

- Java 中数据成员的初始化过程：
    1. 先**默认初始化**（实际上是把刚分配的对象内存都置零）
    2. 进行定义处的初始化（**指定初始化**）
    3. **构造函数初始化**

- 基本数据类型和对象类型在拷贝变量操作上的区别：

    <div style="text-align: center">
        <img src="images/lec2/8.png" width=70%>
    </div>


### Garbage Collection

**垃圾回收**(garbage collection)：JVM 自动回收不再被引用的对象所占的空间。

如果程序员知道不再需要的对象，也可以通过将引用变量显式赋值为 `#!java null`，提示 JVM 来回收。

???+ example "案例研究"

    ```java hl_lines="19-23"
    import java.util.Arrays;
    import java.util.EmptyStackException;

    // Can you spot the "memory leak"?
    public class Stack {
        private Object[] elements;
        private int size = 0;
        private static final int DEFAULT_INITIAL_CAPACITY = 16;

        public Stack() {
            elements = new Object[DEFAULT_INITIAL_CAPACITY];
        }

        public void push(Object e) {
            ensureCapacity();
            elements[size++] = e;
        }

        public Object pop() {
            if (size == 0)
                throw new EmptyStackException();
            return elements[--size];
        }

        /**
         * Ensure space for at least one more element, roughly
         * doubling the capacity each time the array needs to grow.
         */
        private void ensureCapacity() {
            if (elements.length == size)
                elements = Arrays.copyOf(elements, 2 * size + 1);
        }
    }
    ```

    高亮区域的代码存在**内存泄漏**的风险，因为弹出的 `elements` 元素是不再使用的对象，但 `pop()` 函数并没有释放 `elements` 数组对它的引用。

内存泄漏的来源：

- 类自己管理内存
- 缓存：当把对象引用放到缓存中，就容易被遗忘
    - 解决方案：可以用**软引用**(soft reference)（用来描述一些还有用但并非必须的对象；在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收）来实现缓存

当垃圾回收器准备释放用于存储对象的内存时，它将首先调用其 `finalize()` 方法（最新版本的 Java 已移除该方法）。


### Special Classes

- `java.util.Date`：一个与系统无关的日期和时间封装
    - 使用 `Date` 类创建关于当前日期和时间的实例，并用 `toString()` 方法返回日期和时间的字符串形式

    <div style="text-align: center">
        <img src="images/lec2/9.png" width=70%>
    </div>

- `java.util.Random`：提供一组随机数生成器

    <div style="text-align: center">
        <img src="images/lec2/10.png" width=70%>
    </div>

    - 如果两个 `Random` 对象有相同的种子，它们将会生成相同的数字序列


### Static Variables, Constants, and Methods

??? info "实例变量和方法"

    - 实例变量属于特定的实例
    - 实例方法由类的实例调用

声明静态变量/方法/常量要用 `#!java static` 关键字。

- **静态变量**(static variables)为类的所有实例共享
- **静态方法**(static methods)不与特定对象绑定
    - **只能访问静态变量和调用其他静态方法**，而不能访问实例变量，也不能调用其他实例方法
    - 实例方法都可以访问/调用
- **静态常量**(static constants)（全局常量）是所有类实例共享的 `#!java final` 变量（`#!java final static`）

???+ note "类和对象的生命周期"

    - 当程序运行的时候，第一次 `#!java new` 创建一个类的对象，或通过类名访问静态变量或静态方法时，Java 会**将类加载进内存，为这个类分配一块空间**（其实是方法区），这块空间会包括类的定义、它的变量和方法信息，还有类的静态变量，**并对静态变量赋值**
    - 类加载进内存后，一般不会释放，直到程序结束
    - 一般情况，**类只会加载一次**，所以静态变量在内存中只存在一份
    - 通过 `#!java new` 创建一个对象时，对象产生，在内存中会存储这个对象的实例变量值；每 `#!java new` 一次，都会产生一个对象，会有一份独立的实例变量

???+ note "变量的作用域"

    - **实例**和**静态**变量的作用域是整个类；它们可以在类内的任意地方被声明
    - **局部**变量的作用域从其声明开始，延续到包含该变量的代码块结束；在可以使用之前，必须显式初始化局部变量


### Visibility Modifiers and Accessor/Mutator Methods

默认情况下，类、变量和方法能被**同一个包内的其他任何类**访问。

修饰符：

- 默认情况下无修饰符
- `#!java public`：类、数据和方法对**任何包内的任何类**可见
- `#!java private`：数据和方法**仅能被声明它们的类**访问
    - 利用 get 和 set 式的方法实现对 `#!java private` 属性的读取和修改

- `#!java protected`（有些 "friendly"）：派生类以及同一个包内的类能够访问

???+ example "例子"

    <div style="text-align: center">
        <img src="images/lec2/11.png" width=80%>
    </div>

`#!java private` 的构造函数：

- **不能创建类的实例**，类只能被静态访问
    - 例子：Java 提供的 `Math` 类的构造函数就是 `#!java private Math() {}`

- 能创建类的实例，但**只能被类的静态方法调用**
    - 常见场景：单例模式

        ??? example "例子"

            ```java
            public class Runtime {
                private static Runtime currentRuntime = new Runtime();

                /**
                 * Returns the runtime object associated with the current Java application.
                * Most of the methods of class <code>Runtime</code> are instance
                * methods and must be invoked with respect to the current runtime object.
                *
                * @return  the <code>Runtime</code> object associated with the current
                * Java application.
                */
                public static Runtime getRuntime() {
                    return currentRuntime;
                }

                /** Don't let anyone else instantiate this class */
                private Runtime() {}
            }
            ```

- 只能被其他构造函数调用，用于减少重复代码


### Immutable Objects and Classes

- **不可变对象**(immutable objects)：一个对象的内部内容在创建后不能被更改
- 它的类被称为**不可变类**(immutable classes)
    - 同时满足以下条件的类是不可变的：
        - 不要提供任何会修改对象状态的方法（mutator）
        - 被 `#!java final` 修饰的类，这样保证类不会被扩展，防止粗心或恶意的子类假装对象的状态已改变
        - 所有字段用 `#!java final` 或 `#!java private` 修饰
        - 没有返回可变数据字段对象引用的访问器方法

    - 优点：
        - 不可变对象比较简单，可以只有一种状态，即被创建时的状态
        - 不可变对象本质上是**线程安全**的
        - 不可变的类可以提供静态工厂，把频繁被请求的实例**缓存**起来
        - 不需要进行保护性拷贝，因为拷贝始终都是原始的对象

    - 缺点：对于每一个不同的值都需要一个单独的对象

    - Java 提供的不可变类：
        - `String`
        - 基本类型的包装类（如 `Integer`, `Long` 等）
        - `BigInteger` 和 `BigDecimal`
        - `LocalDate`, `LocalTime`, `LocalDateTime`（Java 8 引入）

???+ example "例子"

    === "例1"

        ```java hl_lines="15-17"
        public class Student {
            private int id;
            private BirthDate birthDate;

            public Student(int ssn,
                        int year, int month, int day) {
                id = ssn;
                birthDate = new BirthDate(year, month, day);
            }

            public int getId() {
                return id;
            }

            public BirthDate getBirthDate() {
                return birthDate;
            }
        }
        ```

        必要时进行保护性拷贝。对于上面的代码，将高亮区域代码替换为：

        ```java
        public BirthDate getBirthDate() {
            return new BirthDate(birthDate.getYear(),birthDate.getMonth(),
                                    birthDate.getDay());
        }
        ```

    === "例2"

        类具有公有的静态 `#!java final` 数组域，或者返回这种域的访问方法，这是安全漏洞的一个常见根源。

        ```java
        // Potential security hole!
        public static final Thing[] VALUES = {...};
        ```

        修正问题的两种方法：

        ```java
        private static final Thing[] PRIVATE_VALUES = {...};
        public static final List<Thing> VALUES = 
            Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));
        ```

        ```java
        private static final Thing[] PRIVATE_VALUES = {...};
        public static final Thing[] values() {
            return PRIVATE_VALUES.clone();
        }
        ```

### The `#!java this` Keyword

`#!java this` 关键字是指代对象自身的引用名称。常见用法有：

- 引用类的隐藏数据字段
- 能让构造函数调用相同类的其他构造函数

???+ example "例子"

    ```java
    public class Circle {
        private double radius;
        public Circle(double radius) {
            // this must be explicitly used to reference the data
            // field radius of the object being constructed
            this.radius = radius;  
        }

        public Circle() {
            // this is used to invoke another constructor
            this(1.0);
        }

        public double getArea() {
            // Every instance variable belongs to an instance represented by this,
            // which is normally omitted
            return this.radius * this.radius * Math.PI;
        }
    }
    ```


### Packages

**包**(package)是一个为了方便管理组织 Java 文件的目录结构，并防止不同 Java 文件之间发生命名冲突。

- `#!java package` 语句作为 Java 源文件的第一条语句（若缺省该语句，则指定为无名包）
- 约定俗成地，给包起名为把公司域名倒过来写，并用 `.` 来指明包（目录）的层次
- Java 编译器把包对应于文件系统的目录管理
- 例子：`#!java package com.sun;`，该文件中所有的类位于 `.\com\sun` 目录下
- 类的导入：
    - 在每个类前添加完整的包名：`#!java java.time.LocalDate today = java.time.LocalDate.now();`
    - 使用 `#!java import` 语句

        ```java
        import java.time.*;
        LocalDate today = LocalDate.now();
        ```

        - 使用 `*` 对代码的大小也没有任何负面的影响
        - 也可以只导入包中的特定类：`#!java import java.time.LocalDate;`
        - 当导入的多个包中存在同名类时，可以通过指定包名来区分
        - `#!java import` **不会递归**，只会引入当前包下的直接类；试图嵌套引入的形式也是无效的，如 `#!java import java.util.*.*`
        - 经常使用的 `System.out` 类无需 `#!java import`，是因为编译器都会自动补上
        - 静态导入：导入静态方法和静态域
            - 例子：`#!java import static java.lang.System.*;`

- 将类放入包中
    - 要将类放到包中，必须将包的名字放在源文件的开始
    - 如果没有放置 `#!java package` 语句，则这个类被放置在**默认包**中
    - 需要将类文件放置在其所属包对应的相对路径下，编译器也会将 `.class` 文件放到相同的目录结构中
    - 编译器在编译源文件时不检查目录结构
    - 当 JVM 加载某个 `class` 时，它首先找到环境变量 `CLASSPATH`，将其中的目录作为查找 `.class` 文件的根目录

    ???+ example "例子"

        ```java title="Employee.java"
        package com.horstmann.corejava

        public class Employee {
            ...
        }
        ```

        需要将 `Employee.java` 放到 `com/horstmann/corejava` 目录下。


### JAR

**JAR** 全称 Java 归档(archive)。它将一组 Java 类和支持文件组合成一个使用 ZIP 格式压缩的单个文件，并赋予 `.JAR` 扩展名。

- 优点：
    - 压缩 -> 下载更快
    - 只有一个文件 -> 更简洁
    - 可执行

- 创建：`jar -cvf filename.jar files`
- 运行：`java -jar filename.jar`
- manifest 文件：用于创建可运行的 JAR 程序
- 可为 JAR 嵌入外部资源，比如图像、音频、输入数据文件等


## Thinking in Objects

**类抽象**(class abstraction)意味着将类的实现与类的使用分开。

- 类的创建者提供了对该类的描述，并让用户知道如何使用该类
- 类的用户不需要了解该类是如何实现的；实现细节被**封装**(encapsulated)并隐藏在用户之外


### Association, Aggregation and Composition

- **关联**(association)：两个对象之间的关系，即定义了对象之间的多重性(multiplicity)，比如一对一、一对多、多对一和多对多
- **聚合**(aggregation)：关联的一种特殊情况，表示对象之间的有向关联，是一种 "has-a" 关系（一个对象包含了另一个对象）
    - 聚合可能出现在相同类的对象中
- **组合**(composition)：聚合的一种特殊情况，此时被包含的对象无法在容器对象不存在的情况下独立存在

这三种关系在 UML 类图中分别用以下箭头表示（从左到右）：

<div style="text-align: center">
    <img src="images/lec2/12.png" width=70%>
</div>


### Wrapper Classes

**包装类**(wrapper classes)是一种将基本数据类型封装为对象的类，包括：

```java
Boolean
Character
Short
Byte
Integer
Long
Float
Double
```

- 包装类没有无参构造函数
- 所以包装类的实例是不可变的，也就是说一旦对象创建后其内部值无法改变

关于数值包装类：

- `Integer` 和 `Double` 类的属性和方法：

    <div style="text-align: center">
        <img src="images/lec2/13.png" width=80%>
    </div>

- 构造函数：既可以从基本数据类型构造，也可从表示数值的字符串构造包装类对象，比如有以下构造函数：

    ```java
    public Integer(int value)
    public Integer(String s)
    public Double(double value)
    public Double(String s)
    ```

- 常量：每个数值包装类都有常量 `MAX_VALUE` 和 `MIN_VALUE`
    - `MAX_VALUE` 表示对应基本数据类型的最大值
    - `MIN_VALUE`
        - `Byte`, `Short`, `Integer`, `Long`：分别对应 `#!java byte`, `#!java short`, `#!java int`, `#!java long` 的最小值
        - `Float`, `Double`：分别表示最小的 `#!java float` 和 `#!java double` 的最小**正数**

- 转换方法：由 `Number` 类定义了 `doubleValue`, `floatValue`, `intValue`, `longValue` 和 `shortValue` 的抽象方法，将对象转换为基本类型值
- 静态的 `#!java valueOf(String s)` 方法：创建新对象，根据指定字符串初始化值

    ```java
    Double doubleObject = Double.valueOf("12.4");
    Integer integerObject = Integer.valueOf("12");
    ```

- 将字符串解析为数字的方法：
    - `parseInt`：将数值字符串解析为 `#!java int` 值
    - `parseDouble`：将数值字符串解析为 `#!java double` 值
    - 每个数值包装类都有两个**重载**的解析方法，用于将数字字符串解析为适当的数字值

        ```java
        String str = "123";
        int num = Integer.parseInt(str);

        String hexStr = "0x1a";
        int hexNum = Integer.parseInt(hexstr, 16);
        ```

- JDK 1.5 支持基本类型和包装类的自动转换

    <div style="text-align: center">
        <img src="images/lec2/14.png" width=70%>
    </div>

    - **自动装箱**(auto-boxing)：基本类型 -> 包装类
    - **自动拆箱**(auto-unboxing)：包装类 -> 基本类型
    - 自动装箱会带来额外的性能开销，在需要频繁装箱和拆箱的场合，建议使用基本类型

- `BigInteger` 和 `BigDecimal`：
    - 来自 `java.math` 包，用于计算非常大的整数或高精度的浮点值
    - 这两个类都是不可变的
    - 它们都扩展了 `Number` 类并实现了 `Comparable` 接口

    ??? example "例子"

        ```java
        BigInteger a = new BigInteger("9223372036854775807");
        BigInteger b = new BigInteger("2");
        BigInteger c = a.multiply(b); // 9223372036854775807 * 2
        System.out.println(c);

        BigDecimal a = new BigDecimal(1.0);
        BigDecimal b = new BigDecimal(3);
        BigDecimal c = a.divide(b, 20, BigDecimal.ROUND_UP);
        System.out.println(c);
        ```


### Interned Strings

由于字符串是不可变的并且经常被使用，为了提高效率和节省内存，JVM 为具有相同字符序列的字符串字面量使用唯一的实例。这样的实例称为 **interned**（驻留）。

对于 `#!java String s = "java"`，在编译成 `.class` 时能够识别为同一字符串的，自动优化成常量。所以如果有多个字符串`"java"`，则它们都会引用自同一 `String` 对象。也就是说 `String s = "java"` 其中 `"java"` 值在程序编译期就确定下来了的。

???+ example "例子"

    === "例1"

        <div style="text-align: center">
            <img src="images/lec2/15.png" width=70%>
        </div>

        - 若使用 `#!java new` 运算符则会创建新的对象
        - 若使用字符串初始化器(initializer)，如果驻留对象已创建，那么就不会创建新的对象
        - 第一个返回 `#!java false`，第二个返回 `#!java true`

    === "例2"

        ```java
        package test;

        public class ConstantPool2 {

            public static void main(String[] args) {
                String s1 = "Hello";
                String s2 = "Hello";
                String s3 = "Hel" + "lo";
                String s4 = "Hel" + new String("lo");
                String s5 = new String("Hello");
                String s6 = s5.intern();
                String s7 = "H";
                String s8 = "ello";
                String s9 = s7 + s8;

                System.out.println(s1 == s2);
                System.out.println(s1 == s3);
                System.out.println(s1 == s4);
                System.out.println(s1 == s9);
                System.out.println(s4 == s5);
                System.out.println(s1 == s6);
            }
        }
        ```

        输出为：

        ```
        true
        true
        false
        false
        false
        true
        ```

        - 像这种字符串拼接的情况，如果不能在编译器常量化得到结果的化，则会编译到 `StringBuilder` 来拼接，并在最后返回时创建一个新的字符串对象，这种时候是不会被自动池化的，需要显式调用 `intern()` 方法
        - `s1 == s6` 这两个相等完全归功于 `intern` 方法，`s5` 在堆中，内容为 `Hello`，`intern` 方法会尝试将 `Hello` 字符串添加到常量池中，并返回其在常量池中的地址，因为常量池中已经有了 `Hello` 字符串，所以 `intern` 方法直接返回地址；而 `s1` 在编译期就已经指向常量池了，因此 `s1` 和 `s6` 指向同一地址，相等




### Constant Pool

Java 中的**常量池**(constant pool)技术，是为了方便快捷地创建某些对象而出现的。

- 当需要一个对象时，就可以从池中取一个出来，如果池中没有则创建一个；相较于重复创建相等变量节省了很多时间
- 常量池其实也就是一个内存空间，存在于**方法区**中
- JVM 的编译器将源程序编译成 `class` 文件后，会用一部分字节分类存储常量；这些常量集中在 `class` 中的一个区域存放，一个紧接着一个，这就是常量池
- 基本类型的包装类的大部分都实现了常量池技术，只有两种浮点数类型的包装类没有实现
- 但 `Byte`, `Short`, `Integer`, `Long`, `Character` 这 5 种整型的包装类也只是对从 -128 到 127 的对象使用对象池，也即对象不负责创建和管理大于 127 和小于 -128 的这些类的对象
- 利用**缓存**机制实现常量池：为了减少不必要的内存消耗和内存开辟次数，`Integer` 里做了一个缓存，缓存了从 -128 到 127 之间的 `Integer` 对象，总共是 256 个对象

???+ example "例子"

    <div style="text-align: center">
        <img src="images/lec2/16.png" width=70%>
    </div>

    划红框的两个部分的区别是：
    
    - 前者可以在编译器优化
    - 后者则在运行自动拆箱并计算