---
counter: true
---

# Copying and Moving

## Copying

**拷贝**(copying)：从已有对象中创建新的对象。

??? example "例子"

    ```cpp
    // Currency as pass-by-value argument
    void func(Currency p) {
        cout << "X = " << p.dollars();
    }
    ...
    Currency bucks(100, 0);
    func(bucks);  // bucks is copied into p
    ```

**拷贝构造函数**(copy constructor)：负责拷贝操作的实现
    - 它有唯一的签名：`#!cpp T::T(const T&);`
    - 根据引用调用的防护被用于显式实参上
    - 如果我们没有提供拷贝构造函数的话，C++ 会自动创建拷贝构造函数。它会考虑每一个成员变量的拷贝，对数值、对象和数组而言是不错的，但只这会让数据变得可以共享
    - 如果构造函数里面包含指针的话，那么拷贝的指针和原指针指向的是同一个对象

>这里有一个 Person 类的例子，也许要整理？

拷贝的开销：

- 编译器在确保安全的情况下会对拷贝进行优化
- 程序员需要假设编译器没那么聪明，且随时做好优化的准备

拷贝 v.s. 赋值：

- 每个对象只会被构造一次
- 每个对象需要被销毁一次
    - 可能需要多次调用 `delete()`
- 一旦对象被构建后，它就称为多个赋值操作的目标

在**默认**的拷贝构造函数中，编译器会对所有的成员变量递归调用拷贝构造函数，所以默认情况下就是按成员的初始化。

拷贝构造函数的准则：

- 一般情况下，请显式声明，不要依赖默认的构造函数，要创建自己的构造函数
- 如果你不需要的话，那也要创建一个私有的拷贝构造函数，以阻止默认构造函数的创造；且当尝试按值传递时，就会产生一个编译错误

---
关于函数参数和返回值的类型：

- 参数：
    - 如果想要存储对象的话，那就传递一个对象（拷贝）
    - 如果仅希望获取该对象的值的话，那么就传递一个 `const` 的指针或引用
    - 如果要对对象做一些操作的话，那么就传递一个指针或引用
- 返回值：
    - 如果在函数中创建了一个对象，那就返回这个对象
    - 返回传入的指针或引用
    - 不要将通过 `new` 创建的指针作为返回值


## Moving

移动拷贝函数：参数为右值引用的拷贝构造函数

`std::move()`

`std::swap()`