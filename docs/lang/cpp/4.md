---
counter: true
---

# Inside Object

对象 = 属性（数据：性质/状态）+ 服务（操作：函数）


## Access Control

类的成员可以被归为三类，分别用以下修饰符表示：

- `public`：这类成员可在类的外部被访问
- `private`：这类成员仅在类的内部被访问
- `protected`

类默认采用 `private`，而结构体默认采用 `public`。

**友元**(friend)：

- 是一种显式授予<u>非结构体成员函数</u>访问权限的方式
- 类本身控制哪些代码可以访问其成员
- 可以将全局函数声明为友元，也可以将另一个类的成员函数，甚至将整个类声明为友元



## Objects in Different Places

### Local Objects

- 局部变量(local variables)定义在方法内，作用域被局限在方法内
- 一个与字段同名的局部变量会阻止在方法内部访问该字段

!!! note "字段、参数和局部变量"

    - 这三种变量都能够存储符合它们定义类型的值
    - **字段**(fields)
        - 在构造函数和方法外定义
        - 用于存储持续存在于对象的生命周期的数据（比如可以用来维护对象的当前状态）
        - 作用域为类作用域，因此可被类内的构造函数或方法使用
        - 用 `private` 字段定义字段后，该字段不得在类之外的区域被访问

    - **形参**(formal parameters)和局部变量的生命周期仅在构造函数或方法的调用内，调用结束后就消失了，因此它们是临时变量
    - 形参：
        - 定义在在构造函数或方法的开头，接收来自外部的值，被初始化为实参值，构成了构造函数或方法调用的一部分
        - 作用域限制在定义它们的构造函数或方法内

    - 局部变量：
        - 定义在构造函数或方法的主体内，仅能通过构造函数或方法内的主体来初始化和使用变量
        - 由于局部变量没有被赋予默认值，在表达式中使用局部变量时必须先初始化
        - 局部变量的作用域限制在定义它们的块内，在块外面无法访问它们


### Global Objects

全局对象(global objects)：

- 全局对象的**构造函数**(constructor)需要在进入 `main()` 函数之前被调用，声明顺序即为代码书写顺序，因此 `main()` 不再是程序中第一个被调用的函数
- 全局对象的**析构函数**(destructor)在 `main()` 退出或 `exit()` 调用时被调用


### Static

**静态初始化依赖性**(static initialization dependency)：

- 单个文件内的对象构造顺序是已知的，但是多个文件之间的构造顺序是未指定的
- 那么当位于不同文件的非局部静态对象有依赖关系时，就会带来问题
- **非局部静态变量**(non-local static object)的特点：
    - 定义于全局或名称空间作用域内
    - 在类中或文件作用域内声明为静态变量

- 解决方案：
    - 避免非局部静态变量的依赖关系
    - 按正确的顺序在单个文件内定义静态对象

关于**静态**(static)

- 两个基本含义：静态存储、限制访问
- 在一段固定的地址上分配空间：名称可见性(visibility of a name)、内部链接(internal linkage)
- 在 C++ 中，除了在函数或类内，不要使用静态变量。下面给出一些使用场景和意义：
    - 静态自由函数：内部链接（已弃用）
    - 静态全局变量：内部链接（已弃用）
    - 静态局部变量：持续存储
    - 静态成员变量：实例间共享
    - 静态成员函数：实例间共享，仅被静态成员访问

文件之间的全局静态关系：（缺少配图）

在函数内的静态变量：

- 整个程序内都会记住该变量值
- 仅初始化一次
- 举例：可用于记录函数调用次数

声明静态对象：

- 构造过程在对象定义时发生
    - 构造函数至多调用一次
    - 构造函数的参数必须满足要求
- 析构过程在退出程序时发生
    - 编译器保证析构函数的 LIFO 顺序（函数调用记录存储在栈内）




静态成员(static member)：




## Reference



## Const



## Operator `new` and `delete`