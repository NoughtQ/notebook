<!DOCTYPE html>
<html class="no-js" lang="zh">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width,initial-scale=1" name="viewport"/>
<meta content="NoughtQ的笔记本，主要记录一些 CS 相关的笔记" name="description"/>
<meta content="NoughtQ" name="author"/>
<link href="https://notebook.noughtq.top/system/db/10.html" rel="canonical"/>
<link href="9.html" rel="prev"/>
<link href="11.html" rel="next"/>
<link href="../../feed_rss_created.xml" rel="alternate" title="RSS 订阅" type="application/rss+xml"/>
<link href="../../feed_rss_updated.xml" rel="alternate" title="已更新内容的 RSS 订阅" type="application/rss+xml"/>
<link href="../../assets/favicon.png" rel="icon"/>
<meta content="mkdocs-1.6.1, mkdocs-material-9.6.14" name="generator"/>
<title>Lec 10: Indexing - NoughtQ的笔记本</title>
<link href="../../assets/stylesheets/main.342714a4.min.css" rel="stylesheet"/>
<link href="../../assets/stylesheets/palette.06af60db.min.css" rel="stylesheet"/>
<link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect"/>
<link href="https://fonts.googleapis.com/css?family=JetBrains+Mono,+LXGW+WenKai+Screen+GB+Screen:300,300i,400,400i,700,700i%7CJetBrains+Mono,+Consolas:400,400i,700,700i&amp;display=fallback" rel="stylesheet"/>
<style>:root{--md-text-font:"JetBrains Mono, LXGW WenKai Screen GB Screen";--md-code-font:"JetBrains Mono, Consolas"}</style>
<link href="../../css/heti.css" rel="stylesheet"/>
<link href="../../css/toc_extra.css" rel="stylesheet"/>
<link href="../../css/timeline.css" rel="stylesheet"/>
<link href="../../css/card.css" rel="stylesheet"/>
<link href="../../css/custom.css" rel="stylesheet"/>
<link href="../../css/extra_changelog.css" rel="stylesheet"/>
<link href="https://unpkg.com/katex@0/dist/katex.min.css" rel="stylesheet"/>
<link href="https://gcore.jsdelivr.net/npm/lxgw-wenkai-screen-webfont@1.1.0/style.css" rel="stylesheet"/>
<link href="https://gcore.jsdelivr.net/npm/lxgw-wenkai-webfont@1.1.0/style.css" rel="stylesheet"/>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&amp;display=swap" rel="stylesheet"/>
<script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
<script id="__analytics">function __md_analytics(){function e(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],e("js",new Date),e("config","G-43NH8CVRCJ"),document.addEventListener("DOMContentLoaded",(function(){document.forms.search&&document.forms.search.query.addEventListener("blur",(function(){this.value&&e("event","search",{search_term:this.value})}));document$.subscribe((function(){var t=document.forms.feedback;if(void 0!==t)for(var a of t.querySelectorAll("[type=submit]"))a.addEventListener("click",(function(a){a.preventDefault();var n=document.location.pathname,d=this.getAttribute("data-md-value");e("event","feedback",{page:n,data:d}),t.firstElementChild.disabled=!0;var r=t.querySelector(".md-feedback__note [data-md-value='"+d+"']");r&&(r.hidden=!1)})),t.hidden=!1})),location$.subscribe((function(t){e("config","G-43NH8CVRCJ",{page_path:t.pathname})}))}));var t=document.createElement("script");t.async=!0,t.src="https://www.googletagmanager.com/gtag/js?id=G-43NH8CVRCJ",document.getElementById("__analytics").insertAdjacentElement("afterEnd",t)}</script>
<script>"undefined"!=typeof __md_analytics&&__md_analytics()</script>
</head>
<body data-md-color-accent="indigo" data-md-color-primary="indigo" data-md-color-scheme="slate" dir="ltr">
<input autocomplete="off" class="md-toggle" data-md-toggle="drawer" id="__drawer" type="checkbox"/>
<input autocomplete="off" class="md-toggle" data-md-toggle="search" id="__search" type="checkbox"/>
<label class="md-overlay" for="__drawer"></label>
<div data-md-component="skip">
<a class="md-skip" href="#lec-10-indexing">
          跳转至
        </a>
</div>
<div data-md-component="announce">
</div>
<header class="md-header" data-md-component="header">
<nav aria-label="页眉" class="md-header__inner md-grid">
<a aria-label="NoughtQ的笔记本" class="md-header__button md-logo" data-md-component="logo" href="../.." title="NoughtQ的笔记本">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M9.05 9H7.06V6h1.99V4.03H7.06v-1c0-1.11.89-1.99 1.99-1.99h5.98V8l2.47-1.5L20 8V1.04h1c1.05 0 2 .96 2 1.99V17c0 1.03-.95 2-2 2H9.05c-1.05 0-1.99-.95-1.99-2v-1h1.99v-2H7.06v-3h1.99zM1 18h2v-3H1v-2h2v-3H1V8h2V5h2v3H3v2h2v3H3v2h2v3H3v2h2v1h16v2H5a2 2 0 0 1-2-2v-1H1z"></path></svg>
</a>
<label class="md-header__button md-icon" for="__drawer">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"></path></svg>
</label>
<div class="md-header__title" data-md-component="header-title">
<div class="md-header__ellipsis">
<div class="md-header__topic">
<span class="md-ellipsis">
            NoughtQ的笔记本
          </span>
</div>
<div class="md-header__topic" data-md-component="header-topic">
<span class="md-ellipsis">
            
              Lec 10: Indexing
            
          </span>
</div>
</div>
</div>
<form class="md-header__option" data-md-component="palette">
<input aria-label="Dark Mode" class="md-option" data-md-color-accent="indigo" data-md-color-media="(prefer-color-scheme: dark)" data-md-color-primary="indigo" data-md-color-scheme="slate" id="__palette_0" name="__palette" type="radio"/>
<label class="md-header__button md-icon" for="__palette_1" hidden="" title="Dark Mode">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="m17.75 4.09-2.53 1.94.91 3.06-2.63-1.81-2.63 1.81.91-3.06-2.53-1.94L12.44 4l1.06-3 1.06 3zm3.5 6.91-1.64 1.25.59 1.98-1.7-1.17-1.7 1.17.59-1.98L15.75 11l2.06-.05L18.5 9l.69 1.95zm-2.28 4.95c.83-.08 1.72 1.1 1.19 1.85-.32.45-.66.87-1.08 1.27C15.17 23 8.84 23 4.94 19.07c-3.91-3.9-3.91-10.24 0-14.14.4-.4.82-.76 1.27-1.08.75-.53 1.93.36 1.85 1.19-.27 2.86.69 5.83 2.89 8.02a9.96 9.96 0 0 0 8.02 2.89m-1.64 2.02a12.08 12.08 0 0 1-7.8-3.47c-2.17-2.19-3.33-5-3.49-7.82-2.81 3.14-2.7 7.96.31 10.98 3.02 3.01 7.84 3.12 10.98.31"></path></svg>
</label>
<input aria-label="Light Mode" class="md-option" data-md-color-accent="indigo" data-md-color-media="(prefer-color-scheme: light)" data-md-color-primary="indigo" data-md-color-scheme="default" id="__palette_1" name="__palette" type="radio"/>
<label class="md-header__button md-icon" for="__palette_0" hidden="" title="Light Mode">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 7a5 5 0 0 1 5 5 5 5 0 0 1-5 5 5 5 0 0 1-5-5 5 5 0 0 1 5-5m0 2a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3m0-7 2.39 3.42C13.65 5.15 12.84 5 12 5s-1.65.15-2.39.42zM3.34 7l4.16-.35A7.2 7.2 0 0 0 5.94 8.5c-.44.74-.69 1.5-.83 2.29zm.02 10 1.76-3.77a7.131 7.131 0 0 0 2.38 4.14zM20.65 7l-1.77 3.79a7.02 7.02 0 0 0-2.38-4.15zm-.01 10-4.14.36c.59-.51 1.12-1.14 1.54-1.86.42-.73.69-1.5.83-2.29zM12 22l-2.41-3.44c.74.27 1.55.44 2.41.44.82 0 1.63-.17 2.37-.44z"></path></svg>
</label>
</form>
<script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
<label class="md-header__button md-icon" for="__search">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"></path></svg>
</label>
<div class="md-search" data-md-component="search" role="dialog">
<label class="md-search__overlay" for="__search"></label>
<div class="md-search__inner" role="search">
<form class="md-search__form" name="search">
<input aria-label="搜索" autocapitalize="off" autocomplete="off" autocorrect="off" class="md-search__input" data-md-component="search-query" name="query" placeholder="搜索" required="" spellcheck="false" type="text"/>
<label class="md-search__icon md-icon" for="__search">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"></path></svg>
<svg viewbox="0 0 320 512" xmlns="http://www.w3.org/2000/svg"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256l137.3-137.4c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"></path></svg>
</label>
<nav aria-label="查找" class="md-search__options">
<a aria-label="分享" class="md-search__icon md-icon" data-clipboard="" data-clipboard-text="" data-md-component="search-share" href="javascript:void(0)" tabindex="-1" title="分享">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9a3 3 0 0 0-3 3 3 3 0 0 0 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.15c-.05.21-.08.43-.08.66 0 1.61 1.31 2.91 2.92 2.91s2.92-1.3 2.92-2.91A2.92 2.92 0 0 0 18 16.08"></path></svg>
</a>
<button aria-label="清空当前内容" class="md-search__icon md-icon" tabindex="-1" title="清空当前内容" type="reset">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"></path></svg>
</button>
</nav>
</form>
<div class="md-search__output">
<div class="md-search__scrollwrap" data-md-scrollfix="" tabindex="0">
<div class="md-search-result" data-md-component="search-result">
<div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
<ol class="md-search-result__list" role="presentation"></ol>
</div>
</div>
</div>
</div>
</div>
<div class="md-header__source">
<a class="md-source" data-md-component="source" href="https://github.com/noughtq/notebook" title="前往仓库">
<div class="md-source__icon md-icon">
<svg viewbox="0 0 448 512" xmlns="http://www.w3.org/2000/svg"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81"></path></svg>
</div>
<div class="md-source__repository">
    NoughtQ/Notebook
  </div>
</a>
</div>
</nav>
</header>
<div class="md-container" data-md-component="container">
<nav aria-label="标签" class="md-tabs" data-md-component="tabs">
<div class="md-grid">
<ul class="md-tabs__list">
<li class="md-tabs__item">
<a class="md-tabs__link" href="../../index.html">
          
  
  
    
  
  🏫主页

        </a>
</li>
<li class="md-tabs__item">
<a class="md-tabs__link" href="../../lang/index.html">
          
  
  
    
  
  🔡语言

        </a>
</li>
<li class="md-tabs__item">
<a class="md-tabs__link" href="../../math/index.html">
          
  
  
    
  
  📊数学相关

        </a>
</li>
<li class="md-tabs__item">
<a class="md-tabs__link" href="../../algorithms/index.html">
          
  
  
    
  
  🧮算法相关

        </a>
</li>
<li class="md-tabs__item">
<a class="md-tabs__link" href="../../software/index.html">
          
  
  
    
  
  💾软件相关

        </a>
</li>
<li class="md-tabs__item md-tabs__item--active">
<a class="md-tabs__link" href="../index.html">
          
  
  
    
  
  💻系统相关

        </a>
</li>
<li class="md-tabs__item">
<a class="md-tabs__link" href="../../web/index.html">
          
  
  
    
  
  🌏Web相关

        </a>
</li>
<li class="md-tabs__item">
<a class="md-tabs__link" href="../../sec/ctf-101/index.html">
          
  
  
    
  
  🛡️信息安全

        </a>
</li>
<li class="md-tabs__item">
<a class="md-tabs__link" href="../../ai/index.html">
          
  
  
    
  
  🤖人工智能

        </a>
</li>
<li class="md-tabs__item">
<a class="md-tabs__link" href="../../misc/index.html">
          
  
  
    
  
  🗃️杂项

        </a>
</li>
<li class="md-tabs__item">
<a class="md-tabs__link" href="../../tools/index.html">
          
  
  
    
  
  🛠️工具

        </a>
</li>
<li class="md-tabs__item">
<a class="md-tabs__link" href="../../papers/index.html">
          
  
  
    
  
  📑论文阅读

        </a>
</li>
</ul>
</div>
</nav>
<main class="md-main" data-md-component="main">
<div class="md-main__inner md-grid">
<div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav aria-label="导航栏" class="md-nav md-nav--primary md-nav--lifted" data-md-level="0">
<label class="md-nav__title" for="__drawer">
<a aria-label="NoughtQ的笔记本" class="md-nav__button md-logo" data-md-component="logo" href="../.." title="NoughtQ的笔记本">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M9.05 9H7.06V6h1.99V4.03H7.06v-1c0-1.11.89-1.99 1.99-1.99h5.98V8l2.47-1.5L20 8V1.04h1c1.05 0 2 .96 2 1.99V17c0 1.03-.95 2-2 2H9.05c-1.05 0-1.99-.95-1.99-2v-1h1.99v-2H7.06v-3h1.99zM1 18h2v-3H1v-2h2v-3H1V8h2V5h2v3H3v2h2v3H3v2h2v3H3v2h2v1h16v2H5a2 2 0 0 1-2-2v-1H1z"></path></svg>
</a>
    NoughtQ的笔记本
  </label>
<div class="md-nav__source">
<a class="md-source" data-md-component="source" href="https://github.com/noughtq/notebook" title="前往仓库">
<div class="md-source__icon md-icon">
<svg viewbox="0 0 448 512" xmlns="http://www.w3.org/2000/svg"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81"></path></svg>
</div>
<div class="md-source__repository">
    NoughtQ/Notebook
  </div>
</a>
</div>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
<a class="md-nav__link" href="../../index.html">
<span class="md-ellipsis">
    🏫主页
    
  </span>
<span class="md-nav__icon md-icon"></span>
</a>
</li>
<li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
<a class="md-nav__link" href="../../lang/index.html">
<span class="md-ellipsis">
    🔡语言
    
  </span>
<span class="md-nav__icon md-icon"></span>
</a>
</li>
<li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
<a class="md-nav__link" href="../../math/index.html">
<span class="md-ellipsis">
    📊数学相关
    
  </span>
<span class="md-nav__icon md-icon"></span>
</a>
</li>
<li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
<a class="md-nav__link" href="../../algorithms/index.html">
<span class="md-ellipsis">
    🧮算法相关
    
  </span>
<span class="md-nav__icon md-icon"></span>
</a>
</li>
<li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
<a class="md-nav__link" href="../../software/index.html">
<span class="md-ellipsis">
    💾软件相关
    
  </span>
<span class="md-nav__icon md-icon"></span>
</a>
</li>
<li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
<input checked="" class="md-nav__toggle md-toggle" id="__nav_6" type="checkbox"/>
<div class="md-nav__link md-nav__container">
<a class="md-nav__link" href="../index.html">
<span class="md-ellipsis">
    💻系统相关
    
  </span>
</a>
<label class="md-nav__link" for="__nav_6" id="__nav_6_label" tabindex="">
<span class="md-nav__icon md-icon"></span>
</label>
</div>
<nav aria-expanded="true" aria-labelledby="__nav_6_label" class="md-nav" data-md-level="1">
<label class="md-nav__title" for="__nav_6">
<span class="md-nav__icon md-icon"></span>
            💻系统相关
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
<a class="md-nav__link" href="../csapp/index.html">
<span class="md-ellipsis">
    CSAPP
    
  </span>
<span class="md-nav__icon md-icon"></span>
</a>
</li>
<li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
<a class="md-nav__link" href="../dld/index.html">
<span class="md-ellipsis">
    数字逻辑设计
    
  </span>
<span class="md-nav__icon md-icon"></span>
</a>
</li>
<li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
<a class="md-nav__link" href="../co/index.html">
<span class="md-ellipsis">
    计算机组成
    
  </span>
<span class="md-nav__icon md-icon"></span>
</a>
</li>
<li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
<a class="md-nav__link" href="../ca/index.html">
<span class="md-ellipsis">
    计算机体系结构
    
  </span>
<span class="md-nav__icon md-icon"></span>
</a>
</li>
<li class="md-nav__item md-nav__item--active md-nav__item--nested">
<input checked="" class="md-nav__toggle md-toggle" id="__nav_6_6" type="checkbox"/>
<div class="md-nav__link md-nav__container">
<a class="md-nav__link" href="index.html">
<span class="md-ellipsis">
    数据库系统
    
  </span>
</a>
<label class="md-nav__link" for="__nav_6_6" id="__nav_6_6_label" tabindex="0">
<span class="md-nav__icon md-icon"></span>
</label>
</div>
<nav aria-expanded="true" aria-labelledby="__nav_6_6_label" class="md-nav" data-md-level="2">
<label class="md-nav__title" for="__nav_6_6">
<span class="md-nav__icon md-icon"></span>
            数据库系统
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="1.html">
<span class="md-ellipsis">
    Lec 1: Introduction
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="2.html">
<span class="md-ellipsis">
    Lec 2: Relational Model
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="3.html">
<span class="md-ellipsis">
    Lec 3: Introduction to SQL
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="4.html">
<span class="md-ellipsis">
    Lec 4: Intermediate SQL
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="5.html">
<span class="md-ellipsis">
    Lec 5: Advanced SQL
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="6.html">
<span class="md-ellipsis">
    Lec 6: Database Design Using the E-R Model
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="7.html">
<span class="md-ellipsis">
    Lec 7: Relational Database Design
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="8.html">
<span class="md-ellipsis">
    Lec 8: Physical Storage Systems
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="9.html">
<span class="md-ellipsis">
    Lec 9: Database Storage Structures
    
  </span>
</a>
</li>
<li class="md-nav__item md-nav__item--active">
<input class="md-nav__toggle md-toggle" id="__toc" type="checkbox"/>
<label class="md-nav__link md-nav__link--active" for="__toc">
<span class="md-ellipsis">
    Lec 10: Indexing
    
  </span>
<span class="md-nav__icon md-icon"></span>
</label>
<a class="md-nav__link md-nav__link--active" href="10.html">
<span class="md-ellipsis">
    Lec 10: Indexing
    
  </span>
</a>
<nav aria-label="目录" class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">
<span class="md-nav__icon md-icon"></span>
        目录
      </label>
<ul class="md-nav__list" data-md-component="toc" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="#ordered-indices">
<span class="md-ellipsis">
      Ordered Indices
    </span>
</a>
<nav aria-label="Ordered Indices" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#dense-and-sparse-indices">
<span class="md-ellipsis">
      Dense and Sparse Indices
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#multilevel-indices">
<span class="md-ellipsis">
      Multilevel Indices
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#index-update">
<span class="md-ellipsis">
      Index Update
    </span>
</a>
<nav aria-label="Index Update" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#insertion">
<span class="md-ellipsis">
      Insertion
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#deletion">
<span class="md-ellipsis">
      Deletion
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#secondary-indices">
<span class="md-ellipsis">
      Secondary Indices
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#b-tree-index-files">
<span class="md-ellipsis">
      B+ Tree Index Files
    </span>
</a>
<nav aria-label="B+ Tree Index Files" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#structure">
<span class="md-ellipsis">
      Structure
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#quries">
<span class="md-ellipsis">
      Quries
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#updates">
<span class="md-ellipsis">
      Updates
    </span>
</a>
<nav aria-label="Updates" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#insertion_1">
<span class="md-ellipsis">
      Insertion
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#deletion_1">
<span class="md-ellipsis">
      Deletion
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#complexity">
<span class="md-ellipsis">
      Complexity
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#nonunique-search-keys">
<span class="md-ellipsis">
      Nonunique Search Keys
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#b-tree-extension">
<span class="md-ellipsis">
      B+ Tree Extension
    </span>
</a>
<nav aria-label="B+ Tree Extension" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#b-tree-file-organization">
<span class="md-ellipsis">
      B+ Tree File Organization
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#secondary-indices-and-record-relocation">
<span class="md-ellipsis">
      Secondary Indices and Record Relocation
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#indexing-strings">
<span class="md-ellipsis">
      Indexing Strings
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#bulk-loading-of-b-tree-indices">
<span class="md-ellipsis">
      Bulk Loading of B+ Tree Indices
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#design-choice">
<span class="md-ellipsis">
      Design Choice
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#optimizations">
<span class="md-ellipsis">
      Optimizations
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#b-tree-index-files_1">
<span class="md-ellipsis">
      B Tree Index Files
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#indexing-on-flash-storage">
<span class="md-ellipsis">
      Indexing on Flash Storage
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#indexing-in-main-memory">
<span class="md-ellipsis">
      Indexing in Main Memory
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#hash-indices">
<span class="md-ellipsis">
      Hash Indices
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#multiple-key-access">
<span class="md-ellipsis">
      Multiple-Key Access
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#indices-in-sql">
<span class="md-ellipsis">
      Indices in SQL
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#write-optimized-index-structure">
<span class="md-ellipsis">
      Write-Optimized Index Structure
    </span>
</a>
<nav aria-label="Write-Optimized Index Structure" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#lsm-trees">
<span class="md-ellipsis">
      LSM Trees
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#buffer-trees">
<span class="md-ellipsis">
      Buffer Trees
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#bvarepsilon-trees">
<span class="md-ellipsis">
      B\(\varepsilon\)-Trees
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#bitmap-indices">
<span class="md-ellipsis">
      Bitmap Indices
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="11.html">
<span class="md-ellipsis">
    Lec 11: Query Processing
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="12.html">
<span class="md-ellipsis">
    Lec 12: Query Optimization
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="13.html">
<span class="md-ellipsis">
    Lec 13: Transactions
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="14.html">
<span class="md-ellipsis">
    Lec 14: Concurrency Control
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="15.html">
<span class="md-ellipsis">
    Lec 15: Recovery System
    
  </span>
</a>
</li>
</ul>
</nav>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
<a class="md-nav__link" href="../../web/index.html">
<span class="md-ellipsis">
    🌏Web相关
    
  </span>
<span class="md-nav__icon md-icon"></span>
</a>
</li>
<li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
<a class="md-nav__link" href="../../sec/ctf-101/index.html">
<span class="md-ellipsis">
    🛡️信息安全
    
  </span>
<span class="md-nav__icon md-icon"></span>
</a>
</li>
<li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
<a class="md-nav__link" href="../../ai/index.html">
<span class="md-ellipsis">
    🤖人工智能
    
  </span>
<span class="md-nav__icon md-icon"></span>
</a>
</li>
<li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
<a class="md-nav__link" href="../../misc/index.html">
<span class="md-ellipsis">
    🗃️杂项
    
  </span>
<span class="md-nav__icon md-icon"></span>
</a>
</li>
<li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
<a class="md-nav__link" href="../../tools/index.html">
<span class="md-ellipsis">
    🛠️工具
    
  </span>
<span class="md-nav__icon md-icon"></span>
</a>
</li>
<li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
<a class="md-nav__link" href="../../papers/index.html">
<span class="md-ellipsis">
    📑论文阅读
    
  </span>
<span class="md-nav__icon md-icon"></span>
</a>
</li>
</ul>
</nav>
</div>
</div>
</div>
<div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav aria-label="目录" class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">
<span class="md-nav__icon md-icon"></span>
        目录
      </label>
<ul class="md-nav__list" data-md-component="toc" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="#ordered-indices">
<span class="md-ellipsis">
      Ordered Indices
    </span>
</a>
<nav aria-label="Ordered Indices" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#dense-and-sparse-indices">
<span class="md-ellipsis">
      Dense and Sparse Indices
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#multilevel-indices">
<span class="md-ellipsis">
      Multilevel Indices
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#index-update">
<span class="md-ellipsis">
      Index Update
    </span>
</a>
<nav aria-label="Index Update" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#insertion">
<span class="md-ellipsis">
      Insertion
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#deletion">
<span class="md-ellipsis">
      Deletion
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#secondary-indices">
<span class="md-ellipsis">
      Secondary Indices
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#b-tree-index-files">
<span class="md-ellipsis">
      B+ Tree Index Files
    </span>
</a>
<nav aria-label="B+ Tree Index Files" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#structure">
<span class="md-ellipsis">
      Structure
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#quries">
<span class="md-ellipsis">
      Quries
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#updates">
<span class="md-ellipsis">
      Updates
    </span>
</a>
<nav aria-label="Updates" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#insertion_1">
<span class="md-ellipsis">
      Insertion
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#deletion_1">
<span class="md-ellipsis">
      Deletion
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#complexity">
<span class="md-ellipsis">
      Complexity
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#nonunique-search-keys">
<span class="md-ellipsis">
      Nonunique Search Keys
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#b-tree-extension">
<span class="md-ellipsis">
      B+ Tree Extension
    </span>
</a>
<nav aria-label="B+ Tree Extension" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#b-tree-file-organization">
<span class="md-ellipsis">
      B+ Tree File Organization
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#secondary-indices-and-record-relocation">
<span class="md-ellipsis">
      Secondary Indices and Record Relocation
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#indexing-strings">
<span class="md-ellipsis">
      Indexing Strings
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#bulk-loading-of-b-tree-indices">
<span class="md-ellipsis">
      Bulk Loading of B+ Tree Indices
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#design-choice">
<span class="md-ellipsis">
      Design Choice
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#optimizations">
<span class="md-ellipsis">
      Optimizations
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#b-tree-index-files_1">
<span class="md-ellipsis">
      B Tree Index Files
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#indexing-on-flash-storage">
<span class="md-ellipsis">
      Indexing on Flash Storage
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#indexing-in-main-memory">
<span class="md-ellipsis">
      Indexing in Main Memory
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#hash-indices">
<span class="md-ellipsis">
      Hash Indices
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#multiple-key-access">
<span class="md-ellipsis">
      Multiple-Key Access
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#indices-in-sql">
<span class="md-ellipsis">
      Indices in SQL
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#write-optimized-index-structure">
<span class="md-ellipsis">
      Write-Optimized Index Structure
    </span>
</a>
<nav aria-label="Write-Optimized Index Structure" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#lsm-trees">
<span class="md-ellipsis">
      LSM Trees
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#buffer-trees">
<span class="md-ellipsis">
      Buffer Trees
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#bvarepsilon-trees">
<span class="md-ellipsis">
      B\(\varepsilon\)-Trees
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#bitmap-indices">
<span class="md-ellipsis">
      Bitmap Indices
    </span>
</a>
</li>
</ul>
</nav>
</div>
</div>
</div>
<div class="md-content" data-md-component="content">
<article class="md-content__inner md-typeset">
<a class="md-content__button md-icon" href="https://github.com/noughtq/notebook/edit/master/docs/system/db/10.md" title="编辑此页">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M10 20H6V4h7v5h5v3.1l2-2V8l-6-6H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h4zm10.2-7c.1 0 .3.1.4.2l1.3 1.3c.2.2.2.6 0 .8l-1 1-2.1-2.1 1-1c.1-.1.2-.2.4-.2m0 3.9L14.1 23H12v-2.1l6.1-6.1z"></path></svg>
</a>
<a class="md-content__button md-icon" href="https://github.com/noughtq/notebook/raw/master/docs/system/db/10.md" title="查看本页的源代码">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M17 18c.56 0 1 .44 1 1s-.44 1-1 1-1-.44-1-1 .44-1 1-1m0-3c-2.73 0-5.06 1.66-6 4 .94 2.34 3.27 4 6 4s5.06-1.66 6-4c-.94-2.34-3.27-4-6-4m0 6.5a2.5 2.5 0 0 1-2.5-2.5 2.5 2.5 0 0 1 2.5-2.5 2.5 2.5 0 0 1 2.5 2.5 2.5 2.5 0 0 1-2.5 2.5M9.27 20H6V4h7v5h5v4.07c.7.08 1.36.25 2 .49V8l-6-6H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h4.5a8.2 8.2 0 0 1-1.23-2"></path></svg>
</a>
<h1 id="lec-10-indexing">Lec 10: Indexing<a class="headerlink" href="#lec-10-indexing" title="Permanent link">⚓︎</a></h1>
<div style="margin-top: -30px; font-size: 0.9em; opacity: 0.7;">
<p><span class="twemoji"><svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 2A10 10 0 0 0 2 12a10 10 0 0 0 10 10 10 10 0 0 0 10-10h-2a8 8 0 0 1-8 8 8 8 0 0 1-8-8 8 8 0 0 1 8-8zm6.78 1a.7.7 0 0 0-.48.2l-1.22 1.21 2.5 2.5L20.8 5.7c.26-.26.26-.7 0-.95L19.25 3.2c-.13-.13-.3-.2-.47-.2m-2.41 2.12L9 12.5V15h2.5l7.37-7.38z"></path></svg></span> 约<span class="heti-skip"><span class="heti-spacing"> </span>12632<span class="heti-spacing"> </span></span>个字 <span class="twemoji"><svg viewbox="0 0 640 512" xmlns="http://www.w3.org/2000/svg"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M392.8 1.2c-17-4.9-34.7 5-39.6 22l-128 448c-4.9 17 5 34.7 22 39.6s34.7-5 39.6-22l128-448c4.9-17-5-34.7-22-39.6m80.6 120.1c-12.5 12.5-12.5 32.8 0 45.3l89.3 89.4-89.4 89.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0l112-112c12.5-12.5 12.5-32.8 0-45.3l-112-112c-12.5-12.5-32.8-12.5-45.3 0zm-306.7 0c-12.5-12.5-32.8-12.5-45.3 0l-112 112c-12.5 12.5-12.5 32.8 0 45.3l112 112c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L77.3 256l89.4-89.4c12.5-12.5 12.5-32.8 0-45.3"></path></svg></span> <span>18<span class="heti-spacing"> </span></span>行代码 <span class="twemoji"><svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 20c4.42 0 8-3.58 8-8s-3.58-8-8-8-8 3.58-8 8 3.58 8 8 8m0-18c5.5 0 10 4.5 10 10s-4.5 10-10 10C6.47 22 2 17.5 2 12S6.5 2 12 2m.5 11H11V7h1.5v4.26l3.7-2.13.75 1.3z"></path></svg></span> 预计阅读时间<span class="heti-skip"><span class="heti-spacing"> </span>63<span class="heti-spacing"> </span></span>分钟</p>
</div>
<details class="abstract">
<summary>核心知识</summary>
<ul>
<li>顺序索引：稠密<span class="heti-skip"><span class="heti-spacing"> </span>/<span class="heti-spacing"> </span></span>稀疏索引、多级索引、插入<span class="heti-skip"><span class="heti-spacing"> </span>/<span class="heti-spacing"> </span></span>删除、二级索引</li>
<li><span>B+<span class="heti-spacing"> </span></span>树索引<ul>
<li>数据结构</li>
<li>插入（分裂<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>、删除（合并）</li>
<li>复杂度分析</li>
<li><span>B+<span class="heti-spacing"> </span></span>树文件组织</li>
<li>一些优化方法</li>
</ul>
</li>
<li>哈希索引</li>
<li>索引的<span class="heti-skip"><span class="heti-spacing"> </span>SQL<span class="heti-spacing"> </span></span>语法</li>
<li>位图索引</li>
</ul>
</details>
<!-- head 元素一定要放在一级标题下面，不然标题就显示不出来了 -->
<p></p>
<script crossorigin="anonymous" integrity="sha512-EKW5YvKU3hpyyOcN6jQnAxO/L8gts+YdYV6Yymtl8pk9YlYFtqJgihORuRoBXK8/cOIlappdU6Ms8KdK6yBCgA==" referrerpolicy="no-referrer" src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.7/katex.min.js">
</script>
<link href="https://cdn.jsdelivr.net/npm/pseudocode@latest/build/pseudocode.min.css" rel="stylesheet"/>
<script src="https://cdn.jsdelivr.net/npm/pseudocode@latest/build/pseudocode.min.js">
</script>
<p>数据库系统中的<strong>索引</strong><span>(indices)<span class="heti-spacing"> </span></span>由表中部分组织好的或排好序的列构成，用于高效访问数据库的内容。<span>DBMS<span class="heti-spacing"> </span></span>能够确保表格内容和索引在逻辑上是同步的。</p>
<p>数据库中会经常用到以下两类基本的索引：</p>
<ul>
<li><strong>顺序索引</strong>(ordered indices)：基于排序后的值</li>
<li><strong>哈希索引</strong>(hash indices)：基于值在一些桶<span class="heti-skip"><span class="heti-spacing"> </span>(buckets)<span class="heti-spacing"> </span></span>里的均匀分布，值被分配到的桶是由哈希函数决定的</li>
</ul>
<p>我们先回介绍顺序索引用到的一些技术，这些技术没有最好的，各自都有适用的地方。可以用以下指标来衡量这些方法：</p>
<ul>
<li><strong>访问类型</strong>：包括寻找带有指定属性，或者指定属性值范围的记录</li>
<li><strong>访问时间</strong>：寻找单个或多个数据项所需的时间</li>
<li><strong>插入时间</strong>：包括寻找新数据插入的正确位置，以及更新索引结构所需的时间</li>
<li><strong>删除时间</strong>：包括寻找要被删除的数据项，以及更新索引结构所需的时间</li>
<li><strong>空间开销</strong>：索引结构占据的额外空间，假如该空间不大的话，那么值得用这点空间换取性能的提升</li>
</ul>
<p>单个或多个用于查找文件内记录的属性被称为<strong>搜索键</strong>(search key)，每一个索引对应一个特定的搜索键。</p>
<h2 id="ordered-indices">Ordered Indices<a class="headerlink" href="#ordered-indices" title="Permanent link">⚓︎</a></h2>
<p><strong>顺序索引</strong><span>(ordered indices)<span class="heti-spacing"> </span></span>按排好的顺序存储搜索键的值，并和每个被记录包含的搜索键关联起来。而这些记录也有可能是按顺序排序的。如果是由搜索键定义文件内的顺序的话，那么称对应的索引为<strong>聚集索引</strong><span>(clustering index)<span class="heti-spacing"> </span></span>或<strong>一级索引</strong>(primary index)，而对应的文件被称为<strong>索引顺序文件</strong>(index-sequential files)。通常，聚集索引的搜索键是一个主键（但也可能不是<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>。而对于搜索键顺序和文件内顺序不同的索引，我们称之为<strong>非聚集索引</strong><span>(nonclustering index)<span class="heti-spacing"> </span></span>或<strong>二级索引</strong>(secondary index)。</p>
<h3 id="dense-and-sparse-indices">Dense and Sparse Indices<a class="headerlink" href="#dense-and-sparse-indices" title="Permanent link">⚓︎</a></h3>
<p>一个<strong>索引项</strong><span>(index entry)<span class="heti-spacing"> </span></span>或<strong>索引记录</strong><span>(index record)<span class="heti-spacing"> </span></span>是由搜索键值，以及指向具有和搜索键值相同值的一条或多条记录构成的。而这个指针包含了硬盘块的标识符，以及硬盘块内的偏移量，用于识别块内的具体记录。</p>
<p>顺序索引可分为以下两类：</p>
<ul>
<li>
<p><strong>稠密索引</strong>(dense index)：对于文件内的每个搜索键值都有对应的索引项</p>
<ul>
<li>
<p>在稠密聚集索引里，索引记录包含了搜索键值和指向第一条带有该搜索键值的记录的指针，而其余具有相同搜索键值的记录就按顺序排在这第一条记录的后面</p>
<p></p><div style="text-align: center">
<img src="images/lec10/1.png" width="80%/"/>
</div>
</li>
<li>
<p>在稠密非聚集索引里，索引必须将全部指向带有相同搜索键值的记录的指针存储在列表里</p>
</li>
</ul>
</li>
<li>
<p><strong>稀疏索引</strong>(sparse index)：文件内只有部分搜索键值有对应的索引项</p>
<ul>
<li>此时<strong>只允许聚集索引</strong></li>
<li>每个索引项包含了搜索键值和指向第一条带有该搜索键值的记录的指针</li>
<li>为了找到记录，就要找到小于等于我们要找的搜索键值中最大的搜索键值对应的索引项。然后从这条记录出发，顺着指针在文件中寻找，直到找到想要的记录</li>
</ul>
<p></p><div style="text-align: center">
<img src="images/lec10/2.png" width="80%/"/>
</div>
</li>
</ul>
<p>这种设计中，处理数据库请求的主要成本是将数据块从硬盘带到主存所需的时间。如果索引小到能够放入主存的话，那么搜索的时间就会降低不少。</p>
<h3 id="multilevel-indices">Multilevel Indices<a class="headerlink" href="#multilevel-indices" title="Permanent link">⚓︎</a></h3>
<p>当索引很大的时候，查找索引的过程就特别耗时间。为了解决这个问题，我们可以将索引看作文件中的记录，然后为这个索引构建一个稀疏索引。其中原来的索引称为内部索引，而新构建的索引称为外部索引，如下所示：</p>
<div style="text-align: center">
<img src="images/lec10/3.png" width="60%/"/>
</div>
<p>要找到某条记录，我们现在外层索引上使用<strong>二分查找</strong>，找到不超过该记录的搜索键值的最大搜索键值对应的记录，对应有一个指向内部索引块的指针。然后在这个内部索引块内找到不超过该记录的搜索键值的最大搜索键值对应的记录，对应有一个指向文件块的指针，这个文件块包含了我们想要寻找的记录。</p>
<p>当索引变得很大很大时，我们可以使用更多级的索引，这称为<strong>多级索引</strong>(multilevel indices)。相比只用二分查找而言，在多级索引上寻找记录能够显著减少<span class="heti-skip"><span class="heti-spacing"> </span>I/O<span class="heti-spacing"> </span></span>操作。</p>
<h3 id="index-update">Index Update<a class="headerlink" href="#index-update" title="Permanent link">⚓︎</a></h3>
<h4 id="insertion">Insertion<a class="headerlink" href="#insertion" title="Permanent link">⚓︎</a></h4>
<ul>
<li>首先，系统通过搜索键找到插入记录的地方</li>
<li>然后根据不同类型的索引采取不同操作<ul>
<li>稠密索引：<ul>
<li>如果搜索键值不出现在索引里，那么系统将在合适的位置上插入一个带有该搜索键的新索引</li>
<li>否则的话，<ul>
<li>如果索引项存储了指向所有带有相同搜索键的记录的指针，那么系统将在索引项中添加一个指向新记录的指针</li>
<li>否则的话，索引只存储指向第一个带有该搜索键的记录的指针，此时系统将新记录插入到和它搜索键值相同的记录后面</li>
</ul>
</li>
</ul>
</li>
<li>稀疏索引：<ul>
<li>假设索引为每个块存储一个项。如果系统创建了新的块，那么就将新的块中得到的搜索键值放入索引中</li>
<li>如果新记录的搜索键值在块内是最小的话，那么系统就讲索引的入口更新到该块上；如果不是的话就不做改动</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="deletion">Deletion<a class="headerlink" href="#deletion" title="Permanent link">⚓︎</a></h4>
<p>删除过程和插入类似：</p>
<ul>
<li>首先，系统要找到要被删除的记录</li>
<li>然后根据不同类型的索引采取不同操作<ul>
<li>稠密索引：<ul>
<li>如果被删除的记录是搜索键值对应的唯一的记录，那么系统将删除掉对应的索引项</li>
<li>否则的话，<ul>
<li>如果索引项存储了指向所有带有相同搜索键的记录的指针，那么系统将删除指向被删除记录的指针</li>
<li>否则的话，索引只存储指向第一个带有该搜索键的记录的指针，此时系统将更新索引项，让它指向下一条记录</li>
</ul>
</li>
</ul>
</li>
<li>稀疏索引：<ul>
<li>假设索引为每个块存储一个项。如果系统创建了新的块，那么就将新的块中得到的搜索键值放入索引中</li>
<li>否则的话，<ul>
<li>如果被删除的记录是该搜索键对应的唯一记录，那么系统将对应的索引记录替换为下一个搜索键值的索引记录。如果下一个搜索键值有索引系那个的话，那么就直接删除，不用被替换</li>
<li>否则的话，指向该记录的搜索键值对应的索引记录会被删除，直接指向下一个有相同搜索键值的记录</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr/>
<p>上述插入和删除的操作同样适用于多级索引中。</p>
<h3 id="secondary-indices">Secondary Indices<a class="headerlink" href="#secondary-indices" title="Permanent link">⚓︎</a></h3>
<p>前面介绍的二级索引只考虑稀疏索引的情况，事实上二级索引也可以是稠密索引，此时索引的项能够对应全部的搜索键值，并且有指向所有记录的指针。</p>
<p>在候选键上的二级索引好像一个稠密的聚集索引，但区别在于被索引中的连续值指向的一组记录并不是按顺序存储的。</p>
<p>如果一个关系中有多条记录的搜索键值是相同的，那么这样的搜索键称为<strong>非唯一搜索键</strong>(nonunique search key)。</p>
<p>一种在非唯一搜索键上实现二级索引的方法是：二级索引的指针不直接指向记录，而是让每个指针指向一个桶，这个桶里包含了指向文件的指针。下图展示了这样的结构：</p>
<div style="text-align: center">
<img src="images/lec10/4.png" width="80%/"/>
</div>
<p>这种方法有一些缺陷：</p>
<ul>
<li>索引访问时间变得更长</li>
<li>如果搜索键的重复不多的话，那么会有很多空间被浪费掉</li>
</ul>
<p>由于二级搜索键的顺序和物理搜索键的顺序不同，所以如果尝试按二级搜索键的顺序扫描文件，那么读取每条记录就好像读取硬盘中的每个块，速度相当慢。</p>
<p>前面介绍的插入和删除过程同样适用于二级索引。</p>
<p>总的来说，二级索引改善了使用除聚集索引的搜索键之外的键进行查询时的表现，但是会为数据库的修改带来额外开销。</p>
<h2 id="b-tree-index-files">B+ Tree Index Files<a class="headerlink" href="#b-tree-index-files" title="Permanent link">⚓︎</a></h2>
<p>索引顺序文件组织的主要缺点是：随着文件规模的增长，索引查找和数据顺序扫描的性能会下降。尽管可通过对文件的重新组织来解决这一问题，但是频繁的重复组织是不能被接受的。因此，我们转而采用 <strong><span>B+<span class="heti-spacing"> </span></span>树</strong>这一被广泛使用的索引结构，它能够保证在插入和删除数据的情况下仍然能维持效率。尽管<span class="heti-skip"><span class="heti-spacing"> </span>B+<span class="heti-spacing"> </span></span>树会带来额外的插入和删除操作，以及额外空间的开销，但由于能够避免文件的重新组织，因而这点开销是可以被接受的。</p>
<h3 id="structure">Structure<a class="headerlink" href="#structure" title="Permanent link">⚓︎</a></h3>
<ul>
<li><span>B+<span class="heti-spacing"> </span></span>树是一种<strong>平衡树</strong>(balanced tree)，即从根节点出发到叶子节点的所有路径都是等长的。正是这种平衡性质，才让<span class="heti-skip"><span class="heti-spacing"> </span>B+<span class="heti-spacing"> </span></span>树在查找、插入和删除上具有不错的表现</li>
<li>
<p>下图展示了<span class="heti-skip"><span class="heti-spacing"> </span>B+<span class="heti-spacing"> </span></span>树某个节点的内容，其中有<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n-1\)</span><span class="heti-spacing"> </span></span>个搜索键值<span><span class="heti-spacing"> </span><span class="arithmatex">\(K_1, K_2, \dots, K_{n-1}\)</span></span>，以及<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n\)</span><span class="heti-spacing"> </span></span>个指针<span><span class="heti-spacing"> </span><span class="arithmatex">\(P_1, P_2, \dots, P_n\)</span></span>，且搜索键值是排好序的，即对于<span><span class="heti-spacing"> </span><span class="arithmatex">\(i &lt; j\)</span></span>，有<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(K_i &lt; K_j\)</span><span class="heti-spacing"> </span></span>成立</p>
<p></p><div style="text-align: center">
<img src="images/lec10/5.png" width="70%/"/>
</div>
</li>
<li>
<p>先考虑<strong>叶子节点</strong><span>(leaf node)<span class="heti-spacing"> </span></span>的结构：对于<span><span class="heti-spacing"> </span><span class="arithmatex">\(i = 1, \dots, n - 1\)</span></span>，<span><span class="arithmatex">\(P_i\)</span><span class="heti-spacing"> </span></span>指向搜索键值为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(K_i\)</span><span class="heti-spacing"> </span></span>的文件记录（元组<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>；而<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(P_n\)</span><span class="heti-spacing"> </span></span>指向下一个叶子节点，以实现高效的顺序文件处理。叶子节点至少有<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\lceil \dfrac{n-1}{2} \rceil\)</span><span class="heti-spacing"> </span></span>个值。</p>
<ul>
<li>对于叶子节点<span><span class="heti-spacing"> </span><span class="arithmatex">\(L_i, L_j\ (i &lt; j)\)</span></span>（即<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(L_i\)</span><span class="heti-spacing"> </span></span>在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(L_j\)</span><span class="heti-spacing"> </span></span>的左边<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，<span><span class="arithmatex">\(L_i\)</span><span class="heti-spacing"> </span></span>内的每一个搜索键值<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(v_i\)</span><span class="heti-spacing"> </span></span>均比<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(L_j\)</span><span class="heti-spacing"> </span></span>内的每一个搜索键值<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(v_j\)</span><span class="heti-spacing"> </span></span>小</li>
</ul>
<p></p><div style="text-align: center">
<img src="images/lec10/6.png" width="90%/"/>
</div>
<details class="info">
<summary>注</summary>
<ul>
<li>
<p>也有<span class="heti-skip"><span class="heti-spacing"> </span>B+<span class="heti-spacing"> </span></span>树的叶子节点有两个指针，分别指向上一个和下一个叶子节点</p>
<p></p><div style="text-align: center">
<img src="images/lec10/27.png" width="70%/"/>
</div>
</li>
<li>
<p>叶子节点的值也可以是记录的<span><span class="heti-spacing"> </span>ID</span>，而且这种实现相当常见</p>
</li>
</ul>
</details>
</li>
<li>
<p>而<span class="heti-skip"><span class="heti-spacing"> </span>B+<span class="heti-spacing"> </span></span>树的<strong>非叶子节点</strong>(nonleaf nodes)（有时也称为<strong>内部节点</strong>(internal nodes)）构成了叶子节点的多级（稀疏）索引   </p>
<ul>
<li>非叶子节点的结构和叶子节点的类似，只是它的指针指向的都是树内节点</li>
<li>每个非叶子节点（不包括根节点）的孩子数量的范围为<span><span class="heti-spacing"> </span><span class="arithmatex">\([\lceil \dfrac{n}{2} \rceil, n]\)</span></span>，而根节点孩子数量的范围为<span><span class="heti-spacing"> </span><span class="arithmatex">\([2, n]\)</span></span></li>
<li>节点的指针数称为<strong>扇出</strong>(fanout)</li>
<li>假如某个节点包含<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(m (m \le n)\)</span><span class="heti-spacing"> </span></span>个指针，指针<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(P_i\)</span><span class="heti-spacing"> </span></span>指向搜索键值比<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(K_i\)</span><span class="heti-spacing"> </span></span>小而且不小于<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(K_{i-1}\)</span><span class="heti-spacing"> </span></span>的子树；指针<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(P_m\)</span><span class="heti-spacing"> </span></span>指向搜索键值不小于<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(K_{m-1}\)</span><span class="heti-spacing"> </span></span>的子树；指针<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(P_1\)</span><span class="heti-spacing"> </span></span>指向搜索键值比<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(K_1\)</span><span class="heti-spacing"> </span></span>小的子树</li>
<li>内部节点的<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(K_i\)</span><span class="heti-spacing"> </span></span>值为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(P_{i+1}\)</span><span class="heti-spacing"> </span></span>所指子树的第一个叶子节点的第一个搜索键值</li>
</ul>
</li>
</ul>
<details class="example">
<summary>例子：<span>B+<span class="heti-spacing"> </span></span>数索引结构</summary>
<p><span><span class="arithmatex">\(n = 4\)</span><span class="heti-spacing"> </span></span>时的<span class="heti-skip"><span class="heti-spacing"> </span>B+<span class="heti-spacing"> </span></span>树：</p>
<p></p><div style="text-align: center">
<img src="images/lec10/7.png" width="90%/"/>
</div>
<p><span><span class="arithmatex">\(n = 6\)</span><span class="heti-spacing"> </span></span>时的<span class="heti-skip"><span class="heti-spacing"> </span>B+<span class="heti-spacing"> </span></span>树：</p>
<p></p><div style="text-align: center">
<img src="images/lec10/8.png" width="90%/"/>
</div>
</details>
<p>前面假设的都是搜索键不重复的情况。如果有重复的搜索键，那么就需要调整一下结构的定义：</p>
<ul>
<li>比如将<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(i &lt; j\)</span><span class="heti-spacing"> </span></span>时<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(K_i &lt; K_j\)</span><span class="heti-spacing"> </span></span>的条件改为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(K_i \le K_j\)</span><span class="heti-spacing"> </span></span>这样就可以让叶子节点存储重复值了。但这样做会让内部节点也有重复的搜索键值，使得插入和删除操作变得极复杂又昂贵</li>
<li>另一种方法是为每个搜索键值用一组记录指针，但这种方法过于复杂，且使访问变得更加低效</li>
<li>其实大多数数据库的做法是再拿出一个主键<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A_p\)</span><span class="heti-spacing"> </span></span>和搜索键属性<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(a_i\)</span><span class="heti-spacing"> </span></span>并起来，形成一个唯一的复合搜索键<span><span class="heti-spacing"> </span><span class="arithmatex">\((a_i, A_p)\)</span></span></li>
</ul>
<h3 id="quries">Quries<a class="headerlink" href="#quries" title="Permanent link">⚓︎</a></h3>
<p>下面是在<span class="heti-skip"><span class="heti-spacing"> </span>B+<span class="heti-spacing"> </span></span>树的查询算法：</p>
<pre class="pseudocode" linenumber="true">
\begin{algorithm}
\caption{Querying a B+ Tree}
\begin{algorithmic}
\PROCEDURE{find}{$v$}
    \STATE
    \COMMENT{Assume no duplicate keys, and returns pointer to the record with}
    \STATE
    \COMMENT{search key value $v$ if such a record exists, and null otherwise}
    \STATE Set $C$ = root node
    \WHILE{($C$ is not a leaf node)}
        \STATE Let $i$ = smallest number such that $v \le C.K_i$
        \IF{there is no such number $i$}
            \STATE $P_m$ = last non-null pointer in the node
            \STATE Set $C = C.P_m$
        \ELIF{($v = C.K_i$)}
            \STATE Set $C = C.K_i$
        \ELSE
            \STATE Set $C = C.P_i$       
            \COMMENT{$v &lt; C.K_i$}
        \ENDIF
    \ENDWHILE
    \STATE
    \COMMENT{$C$ is a leaf node}
    \IF{for some $i$, $K_i = v$}
        \RETURN $P_i$
    \ELSE
        \RETURN null   
        \COMMENT{No record with key value $v$ exists}
    \ENDIF
\ENDPROCEDURE
\end{algorithmic}
\end{algorithm}
</pre>
<blockquote>
<p>个人感觉还是比较好理解的，所以就不做解释了。</p>
</blockquote>
<p>此外，我们还能在<span class="heti-skip"><span class="heti-spacing"> </span>B+<span class="heti-spacing"> </span></span>树上查找特定范围<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\([lb, ub]\)</span><span class="heti-spacing"> </span></span>内的搜索键值对应的记录，这样的查询称为<strong>范围查询</strong>(range queries)，对应的算法如下所示：</p>
<pre class="pseudocode" linenumber="true">
\begin{algorithm}
\caption{Range query on B+ tree}
\begin{algorithmic}
\PROCEDURE{findRange}{$lb, ub$}
    \STATE
    \COMMENT{Returns all records with search key value $V$ such that $lb \le V \le ub$}
    \STATE Set resultSet = \{\}
    \STATE Set $C$ = root node
    \WHILE{($C$ is not a leaf node)}
        \STATE Let $i$ = smallest number such that $lb \le C.K_i$
        \IF{there is no such number $i$}
            \STATE $P_m$ = last non-null pointer in the node
            \STATE Set $C = C.P_m$
        \ELIF{($lb = C.K_i$)}
            \STATE Set $C = C.K_i$
        \ELSE
            \STATE Set $C = C.P_i$       
            \COMMENT{$lb &lt; C.K_i$}
        \ENDIF
    \ENDWHILE
    \STATE
    \COMMENT{$C$ is a leaf node}
    \STATE Let $i$ be the least value such that $K_i \ge lb$
    \IF{there is no such $i$}
        \STATE Set $i$ = 1 + number of keys in $C$
        \COMMENT{To force move to next leaf}
    \ENDIF
    \STATE Set done = \FALSE
    \WHILE{(not done)}
        \STATE Let $n$ = number of keys in $C$
        \IF{($i \le n$ \AND $C.K_i \le ub$)}
            \STATE Add $C.P_i$ to resultSet
            \STATE Set i = i + 1
        \ELIF{($i \le n$ \AND $C.K_i &gt; ub$)}
            \STATE done = \TRUE
        \ELIF{($i &gt; n$ \AND $C.P_{n+1}$ is not null)}
            \STATE Set $C = C.P_{n+1}$, and i = 1
            \COMMENT{Move to next leaf}
        \ELSE
            \STATE Set done = \TRUE
            \COMMENT{No more leaves to the right}
        \ENDIF
    \ENDWHILE
    \RETURN resultSet
\ENDPROCEDURE
\end{algorithmic}
\end{algorithm}
</pre>
<p>该算法首先执行类似<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(find(lb)\)</span><span class="heti-spacing"> </span></span>的操作，找到起始的叶子节点；然后遍历叶子节点，将那些搜索键值在范围内的记录收集起来，直到发现搜索键值大于<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(ub\)</span><span class="heti-spacing"> </span></span>时，或者已经没有可遍历的记录时停止；最后返回收集起来的记录<span><span class="heti-spacing"> </span><span class="arithmatex">\(resultSet\)</span></span>。</p>
<p>现在我们来考虑一下查询<span class="heti-skip"><span class="heti-spacing"> </span>B+<span class="heti-spacing"> </span></span>数索引的成本：</p>
<ul>
<li>可以发现，如果一共有<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(N\)</span><span class="heti-spacing"> </span></span>个记录的话，那么<span class="heti-skip"><span class="heti-spacing"> </span>B+<span class="heti-spacing"> </span></span>树的路径长度不超过<span><span class="heti-spacing"> </span><span class="arithmatex">\(\lceil \log_{\lceil n/2 \rceil} N\rceil\)</span></span></li>
<li>一般情况下，节点大小和硬盘块的大小是一致的（大概在<span class="heti-skip"><span class="heti-spacing"> </span>4KB<span class="heti-spacing"> </span></span>左右）</li>
<li>相比一般的树状结构而言，<span>B+<span class="heti-spacing"> </span></span>树的每个节点都很大，所以<span class="heti-skip"><span class="heti-spacing"> </span>B+<span class="heti-spacing"> </span></span>树长得又胖又矮</li>
<li>在遍历到最底层的叶子节点时，要查询唯一的搜索键值的话就需要一次额外的随机<span class="heti-skip"><span class="heti-spacing"> </span>I/O<span class="heti-spacing"> </span></span>访问</li>
<li>范围查询需要额外的成本，因为在到达叶子节点后，还要再检索范围内指针。假如要检索<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(M\)</span><span class="heti-spacing"> </span></span>个指针，那么需要访问至多<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\lceil M / (n/2) \rceil + 1\)</span><span class="heti-spacing"> </span></span>个叶子节点。而且，对于二级索引而言，在最坏情况下会带来<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(M\)</span><span class="heti-spacing"> </span></span>次的随机<span class="heti-skip"><span class="heti-spacing"> </span>I/O<span class="heti-spacing"> </span></span>操作</li>
</ul>
<p>对于非唯一搜索键，如果想要检索给定搜索键值<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(v\)</span><span class="heti-spacing"> </span></span>下的全部记录，那么可以利用过程<span><span class="heti-spacing"> </span><span class="arithmatex">\(findRange(lb, ub)\)</span></span>，其中<span><span class="heti-spacing"> </span><span class="arithmatex">\(lb = (v, -\infty), ub = (v, \infty)\)</span></span>，而<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(-\infty, \infty\)</span><span class="heti-spacing"> </span></span>分别指代最小和最大的主键值<span><span class="heti-spacing"> </span><span class="arithmatex">\(A_p\)</span></span>。</p>
<h3 id="updates">Updates<a class="headerlink" href="#updates" title="Permanent link">⚓︎</a></h3>
<p>我们可以将更新记录的过程拆解为：删除旧记录，之后再插入更新后的记录。</p>
<p>在<span class="heti-skip"><span class="heti-spacing"> </span>B+<span class="heti-spacing"> </span></span>树中，插入和删除会更加麻烦，因为要在插入或删除后保留<span class="heti-skip"><span class="heti-spacing"> </span>B+<span class="heti-spacing"> </span></span>树的平衡性，可能因插入后节点过大需要<strong>分裂</strong><span>(split)<span class="heti-spacing"> </span></span>开来，也有可能因删除后节点过小需要和其他节点<strong>合并</strong>(coalesce/merge)。这里先暂且不去考虑这些问题，让我们先来大致了解插入和删除的思路：</p>
<ul>
<li><strong>插入</strong>：使用<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(find()\)</span><span class="heti-spacing"> </span></span>函数找到插入的叶子节点的位置，然后将搜索键值插入，并确保叶子节点内的搜索键仍然有序</li>
<li><strong>删除</strong>：也使用<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(find()\)</span><span class="heti-spacing"> </span></span>函数找到要被删除的搜索键值。若存在多个相同的搜索键值，则需要将它们全部找出来并删掉。删掉后还要将被删掉的搜索键值右边的项全部向左移，确保项之间没有空缺</li>
</ul>
<p>下面详细介绍插入和删除的原理，以及算法。</p>
<h4 id="insertion_1">Insertion<a class="headerlink" href="#insertion_1" title="Permanent link">⚓︎</a></h4>
<p>为了方便理解，先来看些简单的例子。</p>
<details class="example">
<summary>例子</summary>
<div class="tabbed-set tabbed-alternate" data-tabs="1:2"><input checked="checked" id="__tabbed_1_1" name="__tabbed_1" type="radio"/><input id="__tabbed_1_2" name="__tabbed_1" type="radio"/><div class="tabbed-labels"><label for="__tabbed_1_1">例<span class="heti-skip"><span class="heti-spacing"> </span>1<span class="heti-spacing"> </span></span></label><label for="__tabbed_1_2">例<span><span class="heti-spacing"> </span>2</span></label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>这是原来的<span class="heti-skip"><span class="heti-spacing"> </span>B+<span class="heti-spacing"> </span></span>树：</p>
<p></p><div style="text-align: center">
<img src="images/lec10/7.png" width="90%/"/>
</div>
<p>插入<span class="heti-skip"><span class="heti-spacing"> </span>Adam<span class="heti-spacing"> </span></span>后的<span class="heti-skip"><span class="heti-spacing"> </span>B+<span class="heti-spacing"> </span></span>树：</p>
<p></p><div style="text-align: center">
<img src="images/lec10/9.png" width="90%/"/>
</div>
<p>继续插入<span class="heti-skip"><span class="heti-spacing"> </span>Lamport<span class="heti-spacing"> </span></span>后的<span class="heti-skip"><span class="heti-spacing"> </span>B+<span class="heti-spacing"> </span></span>树：</p>
<p></p><div style="text-align: center">
<img src="images/lec10/10.png" width="90%/"/>
</div>
</div>
<div class="tabbed-block">
<p>一组动画演示（两个不同的例子<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>：</p>
<details class="play">
<summary>动画演示<span><span class="heti-spacing"> </span>1</span></summary>
<p></p><div style="text-align: center">
<img src="images/lec10/28.gif" width="90%/"/>
</div>
</details>
<details class="play">
<summary>动画演示<span><span class="heti-spacing"> </span>2</span></summary>
<p></p><div style="text-align: center">
<img src="images/lec10/29.gif" width="90%/"/>
</div>
</details>
</div>
</div>
</div>
</details>
<p>插入操作可以概括为：</p>
<ol>
<li>找到正确的叶子节点<span><span class="heti-spacing"> </span><span class="arithmatex">\(L\)</span></span>。</li>
<li>按顺序在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(L\)</span><span class="heti-spacing"> </span></span>内插入新的项。<ul>
<li>如果<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(L\)</span><span class="heti-spacing"> </span></span>有足够空间的话，插入操作就此结束。</li>
<li>否则（<strong>上溢</strong>(overflow)）将<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(L\)</span><span class="heti-spacing"> </span></span>分裂成<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(L\)</span><span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(L_2\)</span><span class="heti-spacing"> </span></span>两个节点。将<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(L\)</span><span class="heti-spacing"> </span></span>中原有的项均匀分配到两个节点上，并将中间项复制给父节点。在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(L\)</span><span class="heti-spacing"> </span></span>的父节点里面插入一个指向<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(L_2\)</span><span class="heti-spacing"> </span></span>的项。</li>
</ul>
</li>
<li>如果要分裂内部节点的话，同样重新分配里面的项，不要忘记将中间项推到上一层的节点。</li>
</ol>
<p>插入操作的算法如下所示：</p>
<pre class="pseudocode" linenumber="true">
\begin{algorithm}
\caption{Insertion of entry in a B+ tree}
\begin{algorithmic}
\PROCEDURE{insert}{$value\ K, pointer\ P$}
    \IF{(tree is empty)}
        \STATE create an empty leaf node $L$, which is also the root
    \ELSE
        \STATE Find the leaf node $L$ that should contain key value $K$
    \ENDIF
    \IF{($L$ has less than $n-1$ key values)}
        \STATE insert\_in\_leaf($L, K, P$)
    \ELSE
        \STATE Create node $L'$
        \STATE Copy $L.P_1, \dots, L.K_{n-1}$ to a block of memory $T$ that can
        \STATE $\quad \quad$ hold $n$ (pointer, key-value) pairs
        \STATE insert\_in\_leaf($T, K, P$)
        \STATE Set $L'.P_n = L.P_n$; Set $L.P_n = L'$
        \STATE Erase $L.P_1$ through $L.K_{n-1}$ from $L$
        \STATE Copy $T.P_1$ through $L.K_{n-1}$ from $L$
        \STATE Copy $T.P_{\lceil n / 2\rceil + 1}$ through $T.K_n$ from $T$ into $L'$ starting at $L'.P_1$
        \STATE Let $K'$ be the smallest key-value in $L'$
        \STATE insert\_in\_parent($L, K', L'$)
    \ENDIF
\ENDPROCEDURE
\end{algorithmic}
\end{algorithm}
</pre>
<p>如果插入操作会导致节点分裂的话，那就要自底向上递归处理分裂的问题，直到没有节点分裂，或者创建了新的根节点为止。</p>
<p>该过程还用到了两个子过程<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(insert\_in\_leaf\)</span><span class="heti-spacing"> </span></span>和<span><span class="heti-spacing"> </span><span class="arithmatex">\(insert\_in\_parent\)</span></span>，算法如下： </p>
<pre class="pseudocode" linenumber="true">
\begin{algorithm}
\caption{Subsidiary procedures for insertion of entry in a B+ tree}
\begin{algorithmic}
\PROCEDURE{insertInLeaf}{$node\ L, value\ K, pointer\ P$}
    \STATE
    \COMMENT{Cannot use underlines in procedure names in pseudocode.js}
    \IF{($K &lt; L.K_1$)}
        \STATE insert $P, K$ into $L$ just before $L.P_1$
    \ELSE
        \STATE Let $K_i$ be the highest value in $L$ that is less than or equal to $K$
        \STATE Insert $P, K$ into $L$ just after $L.K_i$
    \ENDIF
\ENDPROCEDURE
\STATE $\quad$
\STATE $\quad$
\PROCEDURE{insertInParent}{$node\ L, value\ K', node\ N'$}
    \STATE
    \COMMENT{Cannot use underlines in procedure names in pseudocode.js}
    \IF{($N$ is the root of the tree)}
        \STATE Create a new node $R$ containing $N, K, N'$
        \COMMENT{$N, N'$ are pointers}
        \STATE Make $R$ the root of the tree
        \RETURN
    \ENDIF
    \STATE Let $P = parent(N)$
    \IF{($P$ has less than $n$ pointers)}
        \STATE Insert ($K', N'$) in $P$ just after $N$
    \ELSE
        \COMMENT{Split $P$}
        \STATE Copy $P$ to a block of memory $T$ that can hold $P$ and $(K', N')$
        \STATE Insert ($K', N'$) into $T$ just after $N$
        \STATE Erase all entries from $P$; Create node $P'$
        \STATE Copy $T.P_1, \dots, T.P_{\lceil (n+1) / 2 \rceil}$ into $P$
        \STATE Let $K'' = T.K_{\lceil (n+1) / 2 \rceil}$
        \STATE Copy $T.K_{\lceil (n+1) / 2 \rceil} \dots T.P_{n+1}$ into $P'$
        \STATE insert\_in\_parent($P, K'', P'$)
    \ENDIF
\ENDPROCEDURE
\end{algorithmic}
\end{algorithm}
</pre>
<h4 id="deletion_1">Deletion<a class="headerlink" href="#deletion_1" title="Permanent link">⚓︎</a></h4>
<p>同样为了便于理解，先来看这个例子：</p>
<details class="example">
<summary>例子</summary>
<div class="tabbed-set tabbed-alternate" data-tabs="2:2"><input checked="checked" id="__tabbed_2_1" name="__tabbed_2" type="radio"/><input id="__tabbed_2_2" name="__tabbed_2" type="radio"/><div class="tabbed-labels"><label for="__tabbed_2_1">例<span class="heti-skip"><span class="heti-spacing"> </span>1<span class="heti-spacing"> </span></span></label><label for="__tabbed_2_2">例<span><span class="heti-spacing"> </span>2</span></label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p>这是原来的<span class="heti-skip"><span class="heti-spacing"> </span>B+<span class="heti-spacing"> </span></span>树：</p>
<p></p><div style="text-align: center">
<img src="images/lec10/9.png" width="90%/"/>
</div>
<p>删掉<span class="heti-skip"><span class="heti-spacing"> </span>Srinivasan<span class="heti-spacing"> </span></span>后的<span class="heti-skip"><span class="heti-spacing"> </span>B+<span class="heti-spacing"> </span></span>树：</p>
<p></p><div style="text-align: center">
<img src="images/lec10/11.png" width="90%/"/>
</div>
<p>继续删掉<span class="heti-skip"><span class="heti-spacing"> </span>Singh<span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span>Wu<span class="heti-spacing"> </span></span>后的<span class="heti-skip"><span class="heti-spacing"> </span>B+<span class="heti-spacing"> </span></span>树：</p>
<p></p><div style="text-align: center">
<img src="images/lec10/12.png" width="90%/"/>
</div>
<p>继续删掉<span class="heti-skip"><span class="heti-spacing"> </span>Gold<span class="heti-spacing"> </span></span>后的<span class="heti-skip"><span class="heti-spacing"> </span>B+<span class="heti-spacing"> </span></span>树：</p>
<p></p><div style="text-align: center">
<img src="images/lec10/13.png" width="90%/"/>
</div>
</div>
<div class="tabbed-block">
<p>一组动画演示（两个不同的例子<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>：</p>
<details class="play">
<summary>动画演示<span><span class="heti-spacing"> </span>1</span></summary>
<p></p><div style="text-align: center">
<img src="images/lec10/30.gif" width="80%/"/>
</div>
</details>
<details class="play">
<summary>动画演示<span><span class="heti-spacing"> </span>2</span></summary>
<p></p><div style="text-align: center">
<img src="images/lec10/31.gif" width="90%/"/>
</div>
</details>
</div>
</div>
</div>
</details>
<p>删除操作的步骤如下：</p>
<ol>
<li>找到正确的叶子节点<span><span class="heti-spacing"> </span><span class="arithmatex">\(L\)</span></span>。</li>
<li>移除指定的项。<ul>
<li>如果<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(L\)</span><span class="heti-spacing"> </span></span>有一半还是满的话，删除操作到此为止。</li>
<li>否则（<strong>下溢</strong>(underflow)）需要先尝试和兄弟节点<strong>合并</strong>；如果合并失败的话（合并后项数超过节点容量）再<strong>重新分配</strong><span>(redistribute)<span class="heti-spacing"> </span></span>这两个节点（<span><span class="arithmatex">\(L\)</span><span class="heti-spacing"> </span></span>和兄弟节点）的内容（更准确的说法是从兄弟节点中“<strong>借</strong>”<span>(borrow)<span class="heti-spacing"> </span></span>一个项过来<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>。</li>
</ul>
</li>
<li>如果要合并的话，必须删除<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(L\)</span><span class="heti-spacing"> </span></span>父节点中指向<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(L\)</span><span class="heti-spacing"> </span></span>的那项。</li>
</ol>
<div class="admonition warning">
<p class="admonition-title">注意</p>
<p>由于删除操作是自底向上的，所以叶子节点删除哪个值，内部节点并不关心——它只在乎是否出现下溢的情况。因此可能存在某个项不在叶子节点，但是在内部节点的现象。</p>
<blockquote>
<p>感谢<a href="https://github.com/QiuLichao"><span class="heti-skip"><span class="heti-spacing"> </span>@QiuLichao<span class="heti-spacing"> </span></span></a>的解释！</p>
</blockquote>
</div>
<p>下面展示了删除操作的算法：</p>
<pre class="pseudocode" linenumber="true">
\begin{algorithm}
\caption{Deletion of entry from a B+ tree}
\begin{algorithmic}
\PROCEDURE{delete}{$value\ K, pointer\ P$}
    \STATE find the leaf node $L$ that contains $(K, P)$
    \STATE delete\_entry($L, K, P$)
\ENDPROCEDURE
\STATE $\quad$
\STATE $\quad$
\PROCEDURE{deleteEntry}{$node\ N, value\ K', pointer\ P$}
    \STATE delete($K, P$) from $N$
    \IF{($N$ is the root \AND $N$ has only one remaining child)}
        \STATE make the child of $N$ the new root of the tree and delete $N$
    \ELIF{($N$ has too few values/pointers)}
        \STATE Let $N'$ be the previous or next child of $parent(N)$
        \STATE Let $K'$ be the value between pointers $N$ and $N'$ in $parent(N)$
        \IF{(entries in $N$ and $N'$ can fit in a single node)}
            \STATE
            \COMMENT{Coalesce nodes}
            \IF{($N$ is predecessor of $N'$)}
                \STATE swap\_variables($N, N'$)
            \ENDIF
            \IF{($N$ is not a leaf)}
                \STATE append $K'$ and all pointers and values in $N$ to $N'$
            \ELSE
                \STATE append all $(K_i, P_i)$ pairs in $N$ to $N'$; set $N'.P_n = N.P_n$
            \ENDIF
            \STATE delete\_entry($parent(N), K', N$); delete node $N$
        \ELSE
            \STATE
            \COMMENT{Redistribution: borrow an entry from $N'$}
            \IF{($N'$ is a predecessor of $N$)}
                \IF{($N$ is a nonleaf node)}
                    \STATE let $m$ be such that $N'.P_m$ is the last pointer in $N'$
                    \STATE remove $(N'.K_{m-1}, N'.P_m)$ from $N'$
                    \STATE insert $(N'.P_m, K')$ as the first pointer and value in $N$,
                    \STATE $\quad \quad$ by shifting other pointers and values right
                    \STATE replace $K'$ in $parent(N)$ by $N'.K_{m-1}$
                \ELSE
                    \STATE let $m$ be such that $(N'.P_m, N'.K_m)$ is the last pointer/value
                    \STATE $\quad \quad$ pair in $N'$
                    \STATE remove $(N'.P_m, N'.K_m)$ from $N'$
                    \STATE insert $(N'.P_m, N'.K_m)$ as the first pointer and value in $N$,
                    \STATE $\quad \quad$ by shifting other pointers and values right
                    \STATE replace $K'$ in $parent(N)$ by $N'.K_m$
                \ENDIF
            \ELSE
                \STATE ... symmetric to the $\mathbf{if}$ case ...
            \ENDIF
        \ENDIF
    \ENDIF
\ENDPROCEDURE
\end{algorithmic}
\end{algorithm}
</pre>
<h3 id="complexity">Complexity<a class="headerlink" href="#complexity" title="Permanent link">⚓︎</a></h3>
<p>尽管<span class="heti-skip"><span class="heti-spacing"> </span>B+<span class="heti-spacing"> </span></span>树的插入和删除操作较为复杂，但是它们仅需相对较少的<span class="heti-skip"><span class="heti-spacing"> </span>I/O<span class="heti-spacing"> </span></span>操作，而且和树的高度成正比。</p>
<p>若已知记录数为<span><span class="heti-spacing"> </span><span class="arithmatex">\(N\)</span></span>，<span>B+<span class="heti-spacing"> </span></span>树节点最大指针数为<span><span class="heti-spacing"> </span><span class="arithmatex">\(n\)</span></span>（也就是说节点内最多可以放<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n-1\)</span><span class="heti-spacing"> </span></span>个搜索键值<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，那么树的高度计算公式为：</p>
<ul>
<li><strong>最好情况</strong>（每个节点都塞满<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>：<span class="arithmatex">\(H_{\min} = 1 + \lceil \log_n \lceil \dfrac{N}{n-1} \rceil \rceil\)</span></li>
<li><strong>最坏情况</strong>（根节点只有<span class="heti-skip"><span class="heti-spacing"> </span>2<span class="heti-spacing"> </span></span>个子树，其他节点只有最大扇出一半数量的子树<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>：<span class="arithmatex">\(H_{\max} = 2 + \lfloor \log_{\lceil n / 2 \rceil} \lceil \dfrac{1}{2} \cdot \dfrac{N}{(n-1) / 2} \rceil \rfloor\)</span></li>
</ul>
<p>虽然<span class="heti-skip"><span class="heti-spacing"> </span>B+<span class="heti-spacing"> </span></span>树仅能保证节点中至少有一半是满的（根据定义<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，但如果搜索键值是随机被插入进来的话，那么平均每个节点有<span class="heti-skip"><span class="heti-spacing"> </span>2/3<span class="heti-spacing"> </span></span>的内容是被填满的；如果是按顺序插入的话，那么还是只有一半是满的。</p>
<details class="example">
<summary>例子</summary>
<div class="tabbed-set tabbed-alternate" data-tabs="3:2"><input checked="checked" id="__tabbed_3_1" name="__tabbed_3" type="radio"/><input id="__tabbed_3_2" name="__tabbed_3" type="radio"/><div class="tabbed-labels"><label for="__tabbed_3_1">题目</label><label for="__tabbed_3_2">解答</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p></p><div style="text-align: center">
<img src="images/lec10/41.png" width="80%/"/>
</div>
</div>
<div class="tabbed-block">
<blockquote>
<p>答案由<span class="heti-skip"><span class="heti-spacing"> </span>Gemini 2.5 pro<span class="heti-spacing"> </span></span>生成，且经过笔者验证。</p>
</blockquote>
<p>答案：A</p>
<p>我们需要先确定<span class="heti-skip"><span class="heti-spacing"> </span>B+<span class="heti-spacing"> </span></span>树的阶数（或扇出率<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，才能计算其高度。</p>
<ol>
<li>
<p>计算内部节点的阶数<span><span class="heti-spacing"> </span>(p)</span></p>
<p>一个内部节点包含 <code>p-1</code> 个键值和 <code>p</code> 个指针。其大小必须小于等于节点大小。</p>
<div class="arithmatex">\[(p-1) \times 32B + p \times 8B \le 2048B\]</div>
<div class="arithmatex">\[32p - 32 + 8p \le 2048\]</div>
<div class="arithmatex">\[40p \le 2080\]</div>
<div class="arithmatex">\[p \le 52\]</div>
<p>所以，内部节点的阶数（最大扇出）为 <strong>52</strong>。</p>
</li>
<li>
<p>计算叶子节点能容纳的条目数<span><span class="heti-spacing"> </span>(k)</span></p>
<p>一个叶子节点包含多个 <code>(键值, 记录指针)</code> 对，以及一个指向下一个叶子节点的指针。</p>
<div class="arithmatex">\[k \times (32B + 8B) + 8B \le 2048B\]</div>
<div class="arithmatex">\[40k \le 2040\]</div>
<div class="arithmatex">\[k \le 51\]</div>
<p>所以，一个叶子节点最多能容纳 <strong>51</strong> 个索引条目。</p>
</li>
<li>
<p>计算树的高度<span><span class="heti-spacing"> </span>(h)</span></p>
<ul>
<li>
<p><strong>叶子节点数量</strong>: <code>总记录数 / 每个叶子节点的条目数</code> = <code>20,000 / 51</code> ≈ 392.15。因此，至少需要 <strong>393</strong> 个叶子节点。</p>
</li>
<li>
<p><strong>确定高度</strong><span>:<span class="heti-spacing"> </span></span>设树高为 <code>h</code>，根节点为第<span class="heti-skip"><span class="heti-spacing"> </span>1<span class="heti-spacing"> </span></span>层。第 <code>h</code> 层的节点数（叶子节点数）必须大于等于<span><span class="heti-spacing"> </span>393</span>。</p>
<ul>
<li>如果<span><span class="heti-spacing"> </span>h=2</span>，最多有 <code>52</code> 个叶子节点，<code>52 &lt; 393</code>，不够。</li>
<li>如果<span><span class="heti-spacing"> </span>h=3</span>，最多有 <code>52 * 52 = 2704</code> 个叶子节点，<code>2704 &gt; 393</code>，足够。</li>
</ul>
</li>
<li>
<p>因此，<span>B+<span class="heti-spacing"> </span></span>树的高度 <strong>h = 3</strong>。</p>
</li>
</ul>
</li>
</ol>
<div class="admonition warning">
<p class="admonition-title">注意</p>
<p><span>Gemini<span class="heti-spacing"> </span></span>只讨论了最理想的情况。我们还得考虑最坏情况——可以直接拿例子上面的公式计算：</p>
<div class="arithmatex">\[
h = 2 + \lfloor \log_{\lceil 26\rceil} \lceil \dfrac{1}{2} \cdot \dfrac{20000}{(25.5)} \rceil \rfloor = 3
\]</div>
</div>
<hr/>
<p>总开销<span class="heti-skip"><span class="heti-spacing"> </span>=<span class="heti-spacing"> </span></span>索引查询开销<span class="heti-skip"><span class="heti-spacing"> </span>+<span class="heti-spacing"> </span></span>数据块读取开销</p>
<ol>
<li>
<p>索引查询开销</p>
<ul>
<li>要到达叶子节点，需要从根节点开始，逐层向下访问。树的高度为<span><span class="heti-spacing"> </span>3</span>，所以需要读取<span class="heti-skip"><span class="heti-spacing"> </span>3<span class="heti-spacing"> </span></span>个节点（根节点、<span>1<span class="heti-spacing"> </span></span>个中间节点、<span>1<span class="heti-spacing"> </span></span>个叶子节点<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>。</li>
<li>每次读取一个新节点都需要一次 <code>seek</code>。</li>
<li>开销<span><span class="heti-spacing"> </span>:</span> <strong>3 seek + 3 transfer</strong></li>
</ul>
</li>
<li>
<p>数据块读取开销</p>
<ul>
<li>因为这是<strong>聚集索引</strong>，所以索引项指向的数据记录在物理上是连续存储的。</li>
<li>题目告知结果包含在 <strong><span>5<span class="heti-spacing"> </span></span>个</strong>数据块中。由于数据连续，我们只需要一次 <code>seek</code> 来定位到第一个数据块，然后就可以顺序读取这<span class="heti-skip"><span class="heti-spacing"> </span>5<span class="heti-spacing"> </span></span>个块。</li>
<li>开销<span><span class="heti-spacing"> </span>:</span> <strong>1 seek + 5 transfer</strong></li>
</ul>
</li>
<li>
<p>总开销</p>
<ul>
<li><strong>Total Seek</strong>: <code>3 (for index) + 1 (for data) = 4 seek</code></li>
<li><strong>Total Transfer</strong>: <code>3 (for index) + 5 (for data) = 8 transfer</code></li>
</ul>
</li>
</ol>
<p>最终的开销为<span><span class="heti-spacing"> </span>4 seek + 8 transfer</span>。</p>
</div>
</div>
</div>
</details>
<h3 id="nonunique-search-keys">Nonunique Search Keys<a class="headerlink" href="#nonunique-search-keys" title="Permanent link">⚓︎</a></h3>
<p>事实上，前面我们假设了搜索键值都是唯一的。而对于非唯一的搜索键，我们也了解了一种通过创建复合搜索键来使搜索键变得唯一的方法。通过修改<span class="heti-skip"><span class="heti-spacing"> </span>B+<span class="heti-spacing"> </span></span>树的结构，能够让<span class="heti-skip"><span class="heti-spacing"> </span>B+<span class="heti-spacing"> </span></span>树支持重复搜索键的查找、插入和删除操作，具体来说有以下几种方法：</p>
<ul>
<li>
<p>每个搜索键值仅存储一次，并为每个搜索键值保留一个记录指针的桶（或列表<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，以处理非唯一的搜索键。这种方法能够有效利用空间，但是它使得<span class="heti-skip"><span class="heti-spacing"> </span>B+<span class="heti-spacing"> </span></span>树的实现更为复杂，因为桶是变长的，且随叶子节点的变大而变大；而且如果将桶放在不同的硬盘块里，那么还会产生额外的<span class="heti-skip"><span class="heti-spacing"> </span>I/O<span class="heti-spacing"> </span></span>操作时间。</p>
<p></p><div style="text-align: center">
<img src="images/lec10/32.png" width="70%/"/>
</div>
</li>
<li>
<p>对每个记录只存储一次搜索键值。该方法能让分裂叶子节点操作保持不变。但它让分裂和查找中间节点的操作变得相当复杂，因为两个叶子可能会包含相同的搜索键值；且会带来更高的空间开销。</p>
<p></p><div style="text-align: center">
<img src="images/lec10/33.png" width="80%/"/>
</div>
</li>
</ul>
<p>而这两种方法的共同缺点是：影响了记录删除的效率，在最坏情况下删除的复杂度与记录数呈线性关系。而在搜索键是唯一的情况下时，记录删除在最坏情况下的复杂度与记录数呈对数关系。</p>
<p>因此，在大多数数据库系统中，<span>B+<span class="heti-spacing"> </span></span>树实现仅用于处理唯一的搜索键，且会通过自动增加记录<span class="heti-skip"><span class="heti-spacing"> </span>id<span class="heti-spacing"> </span></span>或别的属性来使搜索键变得唯一。</p>
<h2 id="b-tree-extension">B+ Tree Extension<a class="headerlink" href="#b-tree-extension" title="Permanent link">⚓︎</a></h2>
<h3 id="b-tree-file-organization">B+ Tree File Organization<a class="headerlink" href="#b-tree-file-organization" title="Permanent link">⚓︎</a></h3>
<p>前面介绍过索引顺序文件组织的主要缺点：随文件规模增长，性能不断降低。因此，我们将<span class="heti-skip"><span class="heti-spacing"> </span>B+<span class="heti-spacing"> </span></span>树直接作用在文件上来解决这一问题。具体来说，就是将文件中的真实记录存储在<span class="heti-skip"><span class="heti-spacing"> </span>B+<span class="heti-spacing"> </span></span>树的叶子节点上，我们称这样的文件组织为 <strong><span>B+<span class="heti-spacing"> </span></span>树文件组织</strong>(B+ tree file organization)。由于记录通常比指针大，因此能被存储在叶子节点内的记录的最大数量比非叶子节点的指针数量更少；可即便如此，我们仍然要求叶子节点有一半内容是满的。一种<span class="heti-skip"><span class="heti-spacing"> </span>B+<span class="heti-spacing"> </span></span>树文件组织如下所示：</p>
<div style="text-align: center">
<img src="images/lec10/14.png" width="80%/"/>
</div>
<p><span>B+<span class="heti-spacing"> </span></span>树文件组织的插入和删除操作和前面介绍过的方法无异，故不再赘述。</p>
<p>在使用<span class="heti-skip"><span class="heti-spacing"> </span>B+<span class="heti-spacing"> </span></span>树文件组织时，空间利用尤为重要，因为一条记录占据的空间远比一个搜索键或指针来的大。我们可以通过在分裂或合并时的重分配<span class="heti-skip"><span class="heti-spacing"> </span>(redistribution)<span class="heti-spacing"> </span></span>操作中<u>考虑更多的兄弟节点</u>来提升空间的利用，这种方法在叶子节点和非叶子节点上均可行。总的来说，如果在重分配时考虑到<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(m\)</span><span class="heti-spacing"> </span></span>个节点（<span><span class="arithmatex">\(m - 1\)</span><span class="heti-spacing"> </span></span>个兄弟节点<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，那么每个节点确保获得至少<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\lfloor (m-1)n / m\rfloor\)</span><span class="heti-spacing"> </span></span>个项。然而，考虑更多节点会让更新成本变得更高。</p>
<p>注意到无论是在<span class="heti-skip"><span class="heti-spacing"> </span>B+<span class="heti-spacing"> </span></span>树索引结构还是文件组织中，相邻的叶子节点有可能位于硬盘的不同位置上。尽管在一组新的记录上建立<span class="heti-skip"><span class="heti-spacing"> </span>B+<span class="heti-spacing"> </span></span>树时考虑到为相邻的叶子节点分配连续的硬盘块，但是在多次插入和删除操作后，这里的有序性就会被打破，从而导致硬盘访问时间的增加。因此可能需要通过重构来恢复这个有序性。</p>
<p><span>B+<span class="heti-spacing"> </span></span>树文件组织可以用于存储大对象（比如<span class="heti-skip"><span class="heti-spacing"> </span>SQL<span class="heti-spacing"> </span></span>的<span class="heti-skip"><span class="heti-spacing"> </span>clobs<span class="heti-spacing"> </span></span>和<span><span class="heti-spacing"> </span>blobs</span><heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，具体做法是将大对象拆分为多个小记录，这些记录按顺序编号，作为<span class="heti-skip"><span class="heti-spacing"> </span>B+<span class="heti-spacing"> </span></span>树上的搜索键。</p>
<h3 id="secondary-indices-and-record-relocation">Secondary Indices and Record Relocation<a class="headerlink" href="#secondary-indices-and-record-relocation" title="Permanent link">⚓︎</a></h3>
<p>对于<span class="heti-skip"><span class="heti-spacing"> </span>B+<span class="heti-spacing"> </span></span>树这样的文件组织，有时会遇到即使没有更新记录内容，也会导致记录位置被改变的情况。比如<span class="heti-skip"><span class="heti-spacing"> </span>B+<span class="heti-spacing"> </span></span>树的某个叶子节点发生分裂了，那么就会有一些记录被移动到新的节点上，这时所有存储指向这些被移动过的记录的指针的二级索引就要被更新，即使它们对应的记录内容没有发生改变，而这会带来较大的开销。</p>
<p>为了解决这一问题，在二级索引中，我们不再存储指向这些被索引记录的指针，而是存储一级索引的搜索键属性（就是说上层的索引不要存最底层的记录，只要存下一层的索引就行了<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>。虽然这样会让访问成本更高（需要额外的步骤<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，但是这能减少文件重组织的成本。</p>
<h3 id="indexing-strings">Indexing Strings<a class="headerlink" href="#indexing-strings" title="Permanent link">⚓︎</a></h3>
<p>为字符串属性创建<span class="heti-skip"><span class="heti-spacing"> </span>B+<span class="heti-spacing"> </span></span>树索引会有一些问题，下面列出这些问题以及对应的解决方案：</p>
<ul>
<li>字符串可能是变长的<ul>
<li>解决方案<heti-adjacent class="heti-adjacent-half">：</heti-adjacent>（没看懂课本的做法，貌似还是正常的分裂和合并<heti-adjacent class="heti-adjacent-half">？</heti-adjacent>）</li>
</ul>
</li>
<li>字符串可能会很长，导致节点的低扇出，从而让<span class="heti-skip"><span class="heti-spacing"> </span>B+<span class="heti-spacing"> </span></span>树变得很高<ul>
<li>解决方案：通过<strong>前缀压缩</strong>(prefix compression)（仅存储搜索键值的前缀部分，但足以区分搜索键值）提升扇出</li>
</ul>
</li>
</ul>
<h3 id="bulk-loading-of-b-tree-indices">Bulk Loading of B+ Tree Indices<a class="headerlink" href="#bulk-loading-of-b-tree-indices" title="Permanent link">⚓︎</a></h3>
<p><strong>批量加载</strong><span>(bulk loading)<span class="heti-spacing"> </span></span>是指一次向索引插入多个项的操作。一种实现方法是：</p>
<ul>
<li>创建一个包含关系中的索引项的临时文件</li>
<li>然后按搜索键为文件内容排序（后面会介绍一些高效的排序算法）<ul>
<li>这样做的好处是：如果按排好的顺序插入项的话，那么这些项也是连续进入某个节点的，那么只需要向该节点写入一次即可。</li>
<li>如果<span class="heti-skip"><span class="heti-spacing"> </span>B+<span class="heti-spacing"> </span></span>树是空的话，那么所有节点仅需一次写入即可。具体来说，可通过<strong>自底向上</strong><span>(bottom-up)<span class="heti-spacing"> </span></span>的<span class="heti-skip"><span class="heti-spacing"> </span>B+<span class="heti-spacing"> </span></span>树构造实现更快的构造。大多数数据库系统都会用到排序和自底向上构造的技术。</li>
</ul>
</li>
<li>扫描排好序的文件，将项插入到索引中</li>
</ul>
<h3 id="design-choice">Design Choice<a class="headerlink" href="#design-choice" title="Permanent link">⚓︎</a></h3>
<p>在<span class="heti-skip"><span class="heti-spacing"> </span>B+<span class="heti-spacing"> </span></span>树的设计中，我们需要考虑以下因素：</p>
<ul>
<li><strong>节点大小</strong><ul>
<li>存储设备的速度越慢，对应的<span class="heti-skip"><span class="heti-spacing"> </span>B+<span class="heti-spacing"> </span></span>树最优节点大小越大<ul>
<li>HDD：~1 MB</li>
<li>SSD：~10 KB</li>
<li>内存：~512 B</li>
</ul>
</li>
<li>最优大小还取决于工作量，比如叶子节点的扫描和从根节点到叶子结点的遍历所需的节点大小不同</li>
</ul>
</li>
<li><strong>合并阈值</strong>(merge threshold)<ul>
<li>有些<span class="heti-skip"><span class="heti-spacing"> </span>DBMS<span class="heti-spacing"> </span></span>在节点内容低于一半时不会进行合并操作<ul>
<li><span>B+<span class="heti-spacing"> </span></span>树节点内的平均占据率为<span><span class="heti-spacing"> </span>69%</span></li>
</ul>
</li>
<li>延迟更新操作能够减少重新组织的量</li>
<li>或者也可以让小节点存在，然后周期性地重新组织整棵树</li>
</ul>
</li>
<li><strong>变长键</strong>(variable-length keys)，包括以下方法：<ul>
<li>指针：将指向元组属性的指针作为键存储起来，可节省空间但影响效率（这样的树也称为<span class="heti-skip"><span class="heti-spacing"> </span>T<span class="heti-spacing"> </span></span>树<span><span class="heti-spacing"> </span>(T-trees)</span>）</li>
<li>变长节点：索引中的节点大小是可变的，需要谨慎的内存管理，所以一般不会用这种方法</li>
<li>填充：总是将键填充至该键类型的最大长度，但会造成很大的空间浪费，所以一般也不会用</li>
<li>键映射<span class="heti-skip"><span class="heti-spacing"> </span>/<span class="heti-spacing"> </span></span>间接引用：将映射到键值列表的指针数组嵌入到节点中，不仅能节省空间，有时还可以加快查询速度</li>
</ul>
</li>
<li><strong>节点内搜索</strong>(intra-node search)<ul>
<li>线性搜索：<ul>
<li>从头到尾扫描节点内的键，无需担心排序问题，使得插入和删除更快；但时间复杂度为<span><span class="heti-spacing"> </span><span class="arithmatex">\(O(n)\)</span></span>，效率不高</li>
<li>可通过<span class="heti-skip"><span class="heti-spacing"> </span>SIMD<span class="heti-spacing"> </span></span>指令实现向量化</li>
</ul>
</li>
<li>二分搜索：跳至中间键，根据比较结果选择左侧或右侧节点进行下一步的比较，效率更高（时间复杂度<span><span class="heti-spacing"> </span><span class="arithmatex">\(O(\log n)\)</span></span><heti-adjacent class="heti-adjacent-half">）</heti-adjacent>；但插入操作的成本会更大，因为我们必须要维护节点的顺序</li>
<li>插值搜索：基于已知的键的分布（利用节点内的元数据<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，估计目标键的位置。虽然这是最快的方法，但应用场景很少</li>
</ul>
</li>
</ul>
<h3 id="optimizations">Optimizations<a class="headerlink" href="#optimizations" title="Permanent link">⚓︎</a></h3>
<p>设计<span class="heti-skip"><span class="heti-spacing"> </span>B+<span class="heti-spacing"> </span></span>树时还可以考虑以下优化方案：</p>
<ul>
<li>
<p><strong>前缀压缩</strong>(prefix compression)</p>
<ul>
<li>相同叶子节点内（排好序）的键可能有相同的前缀</li>
<li>在这种情况下，我们就不存储完整的键，而是先提取共同的前缀，然后为每个键存储唯一的后缀</li>
</ul>
<p></p><div style="text-align: center">
<img src="images/lec10/34.png" width="40%/"/>
</div>
</li>
<li>
<p><strong>去重</strong>(deduplication)</p>
<ul>
<li>如果存在不唯一索引，那么就可能会有某个叶子节点存储一个键的多份拷贝的情况</li>
<li>此时叶子结点可以仅存储其中一份拷贝，但需要维护一个由包含该键的元组构成的“文档列表<span><span class="heti-spacing"> </span>(posting list)</span>”（类似哈希表）</li>
</ul>
<p></p><div style="text-align: center">
<img src="images/lec10/35.png" width="50%/"/>
</div>
</li>
<li>
<p><strong>后缀截断</strong>(suffix truncation)</p>
<ul>
<li>内部节点中的键仅用于“引导流量”</li>
<li>所以内部节点仅存储需要的最小前缀，仍然确保正确的引导</li>
</ul>
<p></p><div style="text-align: center">
<img src="images/lec10/36.gif" width="50%/"/>
</div>
</li>
<li>
<p><strong>指针混编</strong>(pointer swizzling)</p>
<ul>
<li>节点使用页<span><span class="heti-spacing"> </span>id</span>，以引用其他索引的节点。<span>DBMS<span class="heti-spacing"> </span></span>在遍历时必须从页表中获取相应的内存位置</li>
<li>如果要找的页被钉在缓存池中，那么就要存储原始指针而非页<span><span class="heti-spacing"> </span>id</span>，避免从页表中查找地址</li>
</ul>
<details class="example">
<summary>例子</summary>
<div class="tabbed-set tabbed-alternate" data-tabs="4:2"><input checked="checked" id="__tabbed_4_1" name="__tabbed_4" type="radio"/><input id="__tabbed_4_2" name="__tabbed_4" type="radio"/><div class="tabbed-labels"><label for="__tabbed_4_1">原来（存储页<span><span class="heti-spacing"> </span>id</span>）</label><label for="__tabbed_4_2">现在（存储页的原始指针）</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p></p><div style="text-align: center">
<img src="images/lec10/37.png" width="50%/"/>
</div>
</div>
<div class="tabbed-block">
<p></p><div style="text-align: center">
<img src="images/lec10/38.png" width="50%/"/>
</div>
<p>可以看到，现在我们就无需访问缓存池就可以知道页的地址了！</p>
</div>
</div>
</div>
</details>
</li>
<li>
<p><strong>批量插入</strong>(bulk insert)：构建一棵新的<span class="heti-skip"><span class="heti-spacing"> </span>B+<span class="heti-spacing"> </span></span>树的最快方法是先对键排序，然后自底向上构建索引</p>
<p></p><div style="text-align: center">
<img src="images/lec10/39.png" width="70%/"/>
</div>
</li>
</ul>
<h3 id="b-tree-index-files_1">B Tree Index Files<a class="headerlink" href="#b-tree-index-files_1" title="Permanent link">⚓︎</a></h3>
<p><strong><span>B<span class="heti-spacing"> </span></span>树索引</strong>和<span class="heti-skip"><span class="heti-spacing"> </span>B+<span class="heti-spacing"> </span></span>树索引类似，但主要的区别是<span class="heti-skip"><span class="heti-spacing"> </span>B<span class="heti-spacing"> </span></span>树消除了搜索键值的存储冗余，也就是说每个搜索键值在<span class="heti-skip"><span class="heti-spacing"> </span>B<span class="heti-spacing"> </span></span>树中仅出现一次（如果搜索键值是唯一的话<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>。因此，在<span class="heti-skip"><span class="heti-spacing"> </span>B<span class="heti-spacing"> </span></span>树的非叶子节点上，每个搜索键都要用一个额外的指针指向文件记录或者装有关联搜索键的桶。下图就是一个<span class="heti-skip"><span class="heti-spacing"> </span>B<span class="heti-spacing"> </span></span>树索引的例子：</p>
<div style="text-align: center">
<img src="images/lec10/15.png" width="90%/"/>
</div>
<p>下面两张图分别展示了<span class="heti-skip"><span class="heti-spacing"> </span>B<span class="heti-spacing"> </span></span>树的叶子节点（图<span><span class="heti-spacing"> </span>a</span>）和非叶子节点（图<span><span class="heti-spacing"> </span>b</span>）的结构：</p>
<div style="text-align: center">
<img src="images/lec10/16.png" width="70%/"/>
</div>
<p>在非叶子节点中，<span><span class="arithmatex">\(P_i\)</span><span class="heti-spacing"> </span></span>表示树指针，<span><span class="arithmatex">\(B_i\)</span><span class="heti-spacing"> </span></span>表示桶或文件记录指针。在一般的<span class="heti-skip"><span class="heti-spacing"> </span>B<span class="heti-spacing"> </span></span>树中，叶子节点里有<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n-1\)</span><span class="heti-spacing"> </span></span>个键，非叶子节点里有<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(m-1\)</span><span class="heti-spacing"> </span></span>个键，其中<span><span class="heti-spacing"> </span><span class="arithmatex">\(m &lt; n\)</span></span>。</p>
<p>在<span class="heti-skip"><span class="heti-spacing"> </span>B<span class="heti-spacing"> </span></span>树上进行查找时，有时我们可能在到达叶子节点前就找到了想要找的值。但是由于非叶子节点上的搜索键数量相比<span class="heti-skip"><span class="heti-spacing"> </span>B+<span class="heti-spacing"> </span></span>树更少，即有更少的扇出，所以<span class="heti-skip"><span class="heti-spacing"> </span>B<span class="heti-spacing"> </span></span>树会比（存储相同内容的） <span>B+<span class="heti-spacing"> </span></span>树更高。总的来说<span class="heti-skip"><span class="heti-spacing"> </span>B<span class="heti-spacing"> </span></span>树上的查找时间和搜索键数量的对数呈正比。</p>
<p><span>B<span class="heti-spacing"> </span></span>树的删除操作更为复杂，因为被删除的项还可能会出现在非叶子节点上。具体来说，如果搜索键<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(K_i\)</span><span class="heti-spacing"> </span></span>被删掉的话，那么出现在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(P_{i+1}\)</span><span class="heti-spacing"> </span></span>所指向的子树中最小的搜索键必须被移动到原来被<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(K_i\)</span><span class="heti-spacing"> </span></span>占据的地方。相对而言，插入操作只是变得略微复杂些。</p>
<p>对于更大规模的索引，<span>B<span class="heti-spacing"> </span></span>树的空间优势没法显现出来。因此大多数的数据库系统还是采用<span class="heti-skip"><span class="heti-spacing"> </span>B+<span class="heti-spacing"> </span></span>树。</p>
<h3 id="indexing-on-flash-storage">Indexing on Flash Storage<a class="headerlink" href="#indexing-on-flash-storage" title="Permanent link">⚓︎</a></h3>
<p>前面的介绍中，我们都是假设数据被存储在硬盘中——现在我们来看一下将索引用于闪存或<span class="heti-skip"><span class="heti-spacing"> </span>SSD<span class="heti-spacing"> </span></span>的情况。</p>
<ul>
<li><span>B+<span class="heti-spacing"> </span></span>树的节点大小和闪存页的大小相匹配</li>
<li>前面介绍过的批量加载和自底向上构建的方法仍然适用于<span class="heti-skip"><span class="heti-spacing"> </span>SSD<span class="heti-spacing"> </span></span>中，且仍然能发挥不错的效果。对于后者，它还能减少页的写操作（之前介绍过，闪存的写操作比较复杂<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，从而能显著提升性能</li>
<li>为了降低闪存的擦除次数，一种方法是为<span class="heti-skip"><span class="heti-spacing"> </span>B+<span class="heti-spacing"> </span></span>树的内部节点添加缓冲区，用于临时记录更新情况，之后将更新操作下传到更低层的节点上；另一种方法是创建多棵树，并将它们合并起来</li>
</ul>
<h3 id="indexing-in-main-memory">Indexing in Main Memory<a class="headerlink" href="#indexing-in-main-memory" title="Permanent link">⚓︎</a></h3>
<p>当然也可以对在内存中的数据进行索引！</p>
<ul>
<li>如果<span class="heti-skip"><span class="heti-spacing"> </span>B+<span class="heti-spacing"> </span></span>书的节点小到能够放在一个高速缓存行里，那么会为在内存中的数据带来更好的性能，因为这样的<span class="heti-skip"><span class="heti-spacing"> </span>B+<span class="heti-spacing"> </span></span>树能让索引操作遇到的高速缓存失效的情况更少</li>
</ul>
<h2 id="hash-indices">Hash Indices<a class="headerlink" href="#hash-indices" title="Permanent link">⚓︎</a></h2>
<p><strong>哈希</strong><span>(hashing)<span class="heti-spacing"> </span></span>是一种在内存中建立索引的常用技术，这样的索引可能被临时用于连接操作或作为主存数据库的永久结构。哈希也能够用于组织文件内的记录，尽管实际上用的不多。下面我们仅关注在内存中的哈希索引。</p>
<details class="note" open="open">
<summary>哈希表<span><span class="heti-spacing"> </span>(hash tables)</span></summary>
<ul>
<li>哈希表实现了一种关联数组（键<span class="heti-skip"><span class="heti-spacing"> </span>-&gt;<span class="heti-spacing"> </span></span>值）的抽象数据类型，里面的内容是无序的</li>
<li>访问哈希表的平均时间复杂度为<span><span class="heti-spacing"> </span><span class="arithmatex">\(O(1)\)</span></span>（最坏情况下的时间复杂度为<span><span class="heti-spacing"> </span><span class="arithmatex">\(O(n)\)</span></span><heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，空间复杂度为<span><span class="heti-spacing"> </span><span class="arithmatex">\(O(n)\)</span></span><ul>
<li>虽然看起来只有<span><span class="heti-spacing"> </span><span class="arithmatex">\(O(1)\)</span></span>，但在现实情况下我们不能忽视常数的影响</li>
</ul>
</li>
<li>哈希表的实现包含以下部分：<ul>
<li><strong>哈希函数</strong>(hash functions)：实现了将一个较大的键空间映射到一个较小的域内，用于计算数组（桶或槽）的索引位置。<ul>
<li>在选择哈希函数时，我们需要权衡<strong>速度</strong>与<strong>冲突概率</strong>（即两个键被映射到同一槽位的情况<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>。</li>
<li>在极端情况下，一个总是返回相同值的哈希函数虽然速度极快，但会导致持续的冲突；而另一个极端是<span class="heti-skip"><span class="heti-spacing"> </span>"<span class="heti-spacing"> </span></span>完美<span class="heti-skip"><span class="heti-spacing"> </span>"<span class="heti-spacing"> </span></span>哈希函数虽能完全避免冲突，但其计算速度过于缓慢。所以最好的方案是介于两者之间的——在保持较快运算速度的同时实现较低的冲突率。</li>
<li>这里我们不会考虑<a href="https://en.wikipedia.org/wiki/Cryptographic_hash_function">用于密码学的安全哈希函数</a>，因为这样的哈希函数是在<span class="heti-skip"><span class="heti-spacing"> </span>DBMS<span class="heti-spacing"> </span></span>内部实现的，我们无需担心信息泄露的问题。</li>
</ul>
</li>
<li><strong>哈希方案</strong>(hash schemes)：处理哈希后冲突的方法。我们需要权衡好通过分配更大的哈希表以减少冲突，和冲突发生时执行额外操作这两种方案。</li>
</ul>
</li>
</ul>
</details>
<p>在哈希中，我们用<strong>桶</strong><span>(bucket)<span class="heti-spacing"> </span></span>来指代一个存储单条或多条记录的存储单元，它一般是一个关于索引项或记录（用于<strong>哈希文件组织</strong><span>(hash file organization)<span class="heti-spacing"> </span></span>中）的链表。形式上，我们用<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(K\)</span><span class="heti-spacing"> </span></span>表示所有搜索键值的集合，<span><span class="arithmatex">\(B\)</span><span class="heti-spacing"> </span></span>表示所有桶地址的集合，那么<strong>哈希函数</strong><span>(hash function) <span class="arithmatex">\(h\)</span><span class="heti-spacing"> </span></span>就是一个从<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(K\)</span><span class="heti-spacing"> </span></span>到<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(B\)</span><span class="heti-spacing"> </span></span>的一个函数。这个桶集合实际上是一个指针数组，每个指针存储的是链表（桶）的头。</p>
<p>要想插入一条搜索键值为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(K_i\)</span><span class="heti-spacing"> </span></span>的记录，我们先计算<span><span class="heti-spacing"> </span><span class="arithmatex">\(h(K_i)\)</span></span>，得到该记录对应的桶地址，然后我们将这条记录的索引项加到偏移量为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(i\)</span><span class="heti-spacing"> </span></span>的列表上。这种方法称为<strong>溢出链</strong>(overflow chaining)，有时也称为<strong>闭寻址</strong>(closed addressing)。也有一种开寻址的方法，但不适合用于数据库的索引中，因为开寻址不支持高效的删除操作。</p>
<p>哈希索引支持对搜索键的相等性<strong>查询</strong>（比一比哈希函数值就行了<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，但不支持范围查询（而<span class="heti-skip"><span class="heti-spacing"> </span>B+<span class="heti-spacing"> </span></span>树均支持<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>。而<strong>删除</strong>操作相当直接：用哈希函数找到对应的桶后，删除桶里的指定记录就行了。</p>
<p>对于插入操作，如果桶没有足够多的空间的话，那么就发生了<strong>桶溢出</strong><span>(bucket overflow)<span class="heti-spacing"> </span></span>的问题，这时就要用<strong>溢出桶</strong><span>(overflow buckets)<span class="heti-spacing"> </span></span>来解决这一问题。具体来说：如果记录必须要被插入到桶<span><span class="heti-spacing"> </span><span class="arithmatex">\(b\)</span></span>，而<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(b\)</span><span class="heti-spacing"> </span></span>是满的话，那么系统将为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(b\)</span><span class="heti-spacing"> </span></span>提供一个溢出桶，然后将记录插入到这个溢出桶里。如果溢出桶也满的话，那么系统就会再提供一个溢出桶，以此类推。这些溢出桶用一个链表连接起来，就得到了前面提到的<strong>溢出链</strong>，如下所示：</p>
<div style="text-align: center">
<img src="images/lec10/17.png" width="60%/"/>
</div>
<p>如果我们能够提前知道需要被索引的记录数量的话，那么我们就能分配足够大的桶，从而避免了桶溢出的问题。</p>
<p>当多个记录对应的搜索键值相等时，就会导致记录（在所有桶的）分布的不均匀（或称为<strong>偏斜</strong>(skew)<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，这很有可能是因为我们选择的哈希函数不够好。因此在选择哈希函数时要注意这个问题，以减小偏斜的发生。</p>
<p>为了减小桶溢出的概率，我们让桶的数量为<span><span class="heti-spacing"> </span><span class="arithmatex">\(\dfrac{n_r}{f_r} \cdot (1 + d)\)</span></span>，其中<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(n_r\)</span><span class="heti-spacing"> </span></span>为记录总数，<span><span class="arithmatex">\(f_r\)</span><span class="heti-spacing"> </span></span>为每个桶的记录数量，<span><span class="arithmatex">\(d\)</span><span class="heti-spacing"> </span></span>是一个任意数值<span><span class="heti-spacing"> </span>(fudge factor)</span>，通常设为<span class="heti-skip"><span class="heti-spacing"> </span>0.2<span class="heti-spacing"> </span></span>左右。此时桶内<span class="heti-skip"><span class="heti-spacing"> </span>20%<span class="heti-spacing"> </span></span>的空间是空的，虽然看起来有些浪费空间，但它能够减少桶溢出的发生。</p>
<p>前面介绍的哈希索引都是固定桶数的，这种哈希称为<strong>静态哈希</strong>(static hashing)，它有一个问题：我们需要知道有多少记录被存储在索引里，否则的话桶的容量可能不太够用。为了解决这个问题，当记录量大到一定程度时就要重构哈希索引，增加桶的数量，但这样做会耗费不少时间。像这种能够让桶的数量增长的哈希称为<strong>动态哈希</strong>(dynamic hashing)，<strong>线性哈希</strong><span>(linear hashing)<span class="heti-spacing"> </span></span>和<strong>可扩展哈希</strong><span>(extendable hashing)<span class="heti-spacing"> </span></span>都属于此类。</p>
<details class="info">
<summary>更多的哈希方案！</summary>
<p>这一部分属于进阶内容，这里只是稍微带过一下，感兴趣的读者可以自行查阅资料了解。下面将根据静态和动态之分来列举一些常见的方案：</p>
<ul>
<li>
<p>静态哈希方案</p>
<ul>
<li>
<p><strong>线性探测哈希</strong>(linear probe hashing)：见我的<a href="../../algorithms/fds/5.html#open-addressing"><span class="heti-skip"><span class="heti-spacing"> </span>FDS<span class="heti-spacing"> </span></span>笔记</a>，里面还讲了一些更进阶的算法</p>
<details class="play">
<summary>动画演示</summary>
<p></p><div style="text-align: center">
<img src="images/lec10/21.gif" width="70%/"/>
</div>
</details>
</li>
<li>
<p><strong>布谷鸟哈希</strong>(cuckoo hashing)：使用多个哈希函数，在哈希表上找到多个可插入的位置</p>
<details class="play">
<summary>动画演示</summary>
<p></p><div style="text-align: center">
<img src="images/lec10/22.gif" width="70%/"/>
</div>
</details>
<ul>
<li>在插入前，检查这些位置上是否是空的，然后从空位置上挑一个放进去</li>
<li>如果没有空位置，就驱逐其中一个位置上的元素，然后重新哈希，找到新位置</li>
<li>此时查找和删除的时间复杂度均为<span><span class="heti-spacing"> </span><span class="arithmatex">\(O(1)\)</span></span></li>
</ul>
</li>
</ul>
</li>
<li>
<p>动态哈希方案</p>
<ul>
<li>
<p><strong>链哈希</strong>(chained hashing)：就是正文部分主要介绍的哈希方案，这里就不展开介绍了</p>
<details class="play">
<summary>动画演示</summary>
<p></p><div style="text-align: center">
<img src="images/lec10/23.gif" width="80%/"/>
</div>
</details>
</li>
<li>
<p><strong>可扩展哈希</strong>(extendible hashing)：链哈希的一种变体，能使哈希表中多个槽位指向相同的桶链。背后的思想是：分裂并移动桶的内容，并增加查找哈希表中条目时需要检查的位数。</p>
<details class="play">
<summary>动画演示</summary>
<p></p><div style="text-align: center">
<img src="images/lec10/24.gif" width="80%/"/>
</div>
</details>
</li>
<li>
<p><strong>线性哈希</strong>(linear hashing)：</p>
<ul>
<li>哈希表维护一个跟踪下一个要分裂的桶的指针；当任意桶出现溢出时，就分裂这个指针指向的桶。</li>
<li>使用多重哈希，为给定的键找到正确的桶</li>
<li>可采用不同的溢出处理方法</li>
</ul>
<details class="play">
<summary>动画演示</summary>
<div class="tabbed-set tabbed-alternate" data-tabs="5:2"><input checked="checked" id="__tabbed_5_1" name="__tabbed_5" type="radio"/><input id="__tabbed_5_2" name="__tabbed_5" type="radio"/><div class="tabbed-labels"><label for="__tabbed_5_1">查找和插入</label><label for="__tabbed_5_2">删除</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p></p><div style="text-align: center">
<img src="images/lec10/25.gif" width="90%/"/>
</div>
</div>
<div class="tabbed-block">
<p></p><div style="text-align: center">
<img src="images/lec10/26.gif" width="90%/"/>
</div>
</div>
</div>
</div>
</details>
</li>
</ul>
</li>
</ul>
</details>
<h2 id="multiple-key-access">Multiple-Key Access<a class="headerlink" href="#multiple-key-access" title="Permanent link">⚓︎</a></h2>
<p>前面讲到的搜索键大多是由单个属性构成的，而对于由多个属性构成的搜索键，我们称为<strong>复合搜索键</strong>(composite search keys)。假如对属性<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A_1, \dots, A_n\)</span><span class="heti-spacing"> </span></span>索引，那么搜索键值可以被表示为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\((a_1, \dots, a_n)\)</span><span class="heti-spacing"> </span></span>的元组形式。此时搜索键值的顺序遵循<strong>词典序</strong>(lexicographic ordering)。</p>
<p>对于某些查询，使用复合搜索键构成的索引能够提升查询效率。比如对于以下查询：</p>
<div class="language-sql highlight"><pre><span></span><code><span id="__span-0-1"><a href="#__codelineno-0-1" id="__codelineno-0-1" name="__codelineno-0-1"></a><span class="k">SELECT</span><span class="w"> </span><span class="n">ID</span>
</span><span id="__span-0-2"><a href="#__codelineno-0-2" id="__codelineno-0-2" name="__codelineno-0-2"></a><span class="k">FROM</span><span class="w"> </span><span class="n">instructor</span>
</span><span id="__span-0-3"><a href="#__codelineno-0-3" id="__codelineno-0-3" name="__codelineno-0-3"></a><span class="k">WHERE</span><span class="w"> </span><span class="n">dept_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">'Finance'</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">salary</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">80000</span><span class="p">;</span>
</span></code></pre></div>
<p>我们创建复合搜索键<span><span class="heti-spacing"> </span><span class="arithmatex">\((dept\_name, salary)\)</span></span>，并在其基础上建立起有序索引（比如<span class="heti-skip"><span class="heti-spacing"> </span>B+<span class="heti-spacing"> </span></span>树索引<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，从而实现高效的查找。</p>
<p>实际上，上述复合搜索键还适用一个为相等条件，一个为范围条件的查询，以及单属性的查询，比如：</p>
<div class="language-sql highlight"><pre><span></span><code><span id="__span-1-1"><a href="#__codelineno-1-1" id="__codelineno-1-1" name="__codelineno-1-1"></a><span class="k">SELECT</span><span class="w"> </span><span class="n">ID</span>
</span><span id="__span-1-2"><a href="#__codelineno-1-2" id="__codelineno-1-2" name="__codelineno-1-2"></a><span class="k">FROM</span><span class="w"> </span><span class="n">instructor</span>
</span><span id="__span-1-3"><a href="#__codelineno-1-3" id="__codelineno-1-3" name="__codelineno-1-3"></a><span class="k">WHERE</span><span class="w"> </span><span class="n">dept_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">'Finance'</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">salary</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">80000</span><span class="p">;</span>
</span><span id="__span-1-4"><a href="#__codelineno-1-4" id="__codelineno-1-4" name="__codelineno-1-4"></a>
</span><span id="__span-1-5"><a href="#__codelineno-1-5" id="__codelineno-1-5" name="__codelineno-1-5"></a><span class="k">SELECT</span><span class="w"> </span><span class="n">ID</span>
</span><span id="__span-1-6"><a href="#__codelineno-1-6" id="__codelineno-1-6" name="__codelineno-1-6"></a><span class="k">FROM</span><span class="w"> </span><span class="n">instructor</span>
</span><span id="__span-1-7"><a href="#__codelineno-1-7" id="__codelineno-1-7" name="__codelineno-1-7"></a><span class="k">WHERE</span><span class="w"> </span><span class="n">dept_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">'Finance'</span><span class="p">;</span>
</span></code></pre></div>
<p>但这种搜索键不适用于两个属性均为范围条件的查询，比如：</p>
<div class="language-sql highlight"><pre><span></span><code><span id="__span-2-1"><a href="#__codelineno-2-1" id="__codelineno-2-1" name="__codelineno-2-1"></a><span class="k">SELECT</span><span class="w"> </span><span class="n">ID</span>
</span><span id="__span-2-2"><a href="#__codelineno-2-2" id="__codelineno-2-2" name="__codelineno-2-2"></a><span class="k">FROM</span><span class="w"> </span><span class="n">instructor</span>
</span><span id="__span-2-3"><a href="#__codelineno-2-3" id="__codelineno-2-3" name="__codelineno-2-3"></a><span class="k">WHERE</span><span class="w"> </span><span class="n">dept_name</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="s1">'Finance'</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">salary</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">80000</span><span class="p">;</span>
</span></code></pre></div>
<p>因为满足条件的这些记录可能位于不同的硬盘块内，而文件内的记录是有序的，因此会带来很多的<span class="heti-skip"><span class="heti-spacing"> </span>I/O<span class="heti-spacing"> </span></span>操作。</p>
<hr/>
<p><strong>覆盖索引</strong>(covering indices)：存储某些属性（并非搜索键属性）以及指向记录的指针的索引。使用这种索引能够减小搜索键的规模，从而为非叶子节点带来更大的删除，降低索引树的高度。</p>
<h2 id="indices-in-sql">Indices in SQL<a class="headerlink" href="#indices-in-sql" title="Permanent link">⚓︎</a></h2>
<ul>
<li>
<p>虽然<span class="heti-skip"><span class="heti-spacing"> </span>SQL<span class="heti-spacing"> </span></span>标准里没有指明任何和索引相关的语法，但大多数的数据库支持用<span class="heti-skip"><span class="heti-spacing"> </span>SQL<span class="heti-spacing"> </span></span>命令创建和删除索引，语法格式大致如下：</p>
<div class="language-sql highlight"><pre><span></span><code><span id="__span-3-1"><a href="#__codelineno-3-1" id="__codelineno-3-1" name="__codelineno-3-1"></a><span class="k">CREATE</span><span class="w"> </span><span class="k">INDEX</span><span class="w"> </span><span class="o">&lt;</span><span class="k">index</span><span class="o">-</span><span class="n">name</span><span class="o">&gt;</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="o">&lt;</span><span class="n">relation</span><span class="o">-</span><span class="n">name</span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="o">&lt;</span><span class="n">attribute</span><span class="o">-</span><span class="n">list</span><span class="o">&gt;</span><span class="p">);</span>
</span><span id="__span-3-2"><a href="#__codelineno-3-2" id="__codelineno-3-2" name="__codelineno-3-2"></a><span class="k">DROP</span><span class="w"> </span><span class="k">INDEX</span><span class="w"> </span><span class="o">&lt;</span><span class="k">index</span><span class="o">-</span><span class="n">name</span><span class="o">&gt;</span><span class="p">;</span>
</span></code></pre></div>
</li>
<li>
<p>如果想要将候选键作为搜索键的话，可以用 <code>CREATE UNIQUE INDEX</code> 来实现。</p>
</li>
<li>当用户发起的查询能够从索引中获利的话，那么<span class="heti-skip"><span class="heti-spacing"> </span>SQL<span class="heti-spacing"> </span></span>查询处理器会自动使用该索引。</li>
<li>对那些在查询语句中作为选择条件或连接条件的属性而言，索引会很有帮助，因为它能够显著减少查询的成本。</li>
<li>然而，如果创建太多的索引的话，就会降低更新的处理，因为更新操作也会涉及到所有受影响的索引，所以在创建索引前要先想好是否有必要用到这个索引。</li>
<li>如果某个关系有主键的话，那么大多数数据库系统会自动根据主键创建索引，如果不这么做的话，当插入元组的时候，整个关系都要被扫描一遍，以确保主键约束是满足的。</li>
<li>通常，为外键属性创建索引是一个好主意，因为大多数的连接操作都是在外键索引和主键索引属性上进行的，对这种情况而言查询的效率会因为索引而变得更高。</li>
</ul>
<h2 id="write-optimized-index-structure">Write-Optimized Index Structure<a class="headerlink" href="#write-optimized-index-structure" title="Permanent link">⚓︎</a></h2>
<p><span>B+<span class="heti-spacing"> </span></span>树索引结构的一大缺点是随机的写操作对性能带来了负面影响。在<span class="heti-skip"><span class="heti-spacing"> </span>SSD<span class="heti-spacing"> </span></span>上，虽然随机<span class="heti-skip"><span class="heti-spacing"> </span>I/O<span class="heti-spacing"> </span></span>操作相当快，但写操作的成本还是很大。因此，我们接下来会介绍一些写优化的索引结构，来处理高写入<span class="heti-skip"><span class="heti-spacing"> </span>/<span class="heti-spacing"> </span></span>插入率带来的工作量。</p>
<h3 id="lsm-trees">LSM Trees<a class="headerlink" href="#lsm-trees" title="Permanent link">⚓︎</a></h3>
<p><strong><span>LSM<span class="heti-spacing"> </span></span>树</strong>，全称<strong>日志结构合并树</strong>(log-structured merge tree)，是由多棵<span class="heti-skip"><span class="heti-spacing"> </span>B+<span class="heti-spacing"> </span></span>树构成的，包括一棵在内存里的树<span><span class="heti-spacing"> </span><span class="arithmatex">\(L_0\)</span></span>，以及在硬盘里的树<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(L_1, L_2, \dots, L_k\)</span><span class="heti-spacing"> </span></span>构成的，其中<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(k\)</span><span class="heti-spacing"> </span></span>称为层级。下图展示了<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(k=3\)</span><span class="heti-spacing"> </span></span>时的<span class="heti-skip"><span class="heti-spacing"> </span>LSM<span class="heti-spacing"> </span></span>树：</p>
<div style="text-align: center">
<img src="images/lec10/18.png" width="60%/"/>
</div>
<ul>
<li>索引的查找过程为：先对每棵树进行单独的查找操作，然后合并查找结果。</li>
<li>向<span class="heti-skip"><span class="heti-spacing"> </span>LSM<span class="heti-spacing"> </span></span>树插入一条记录时，<ul>
<li>首先将该记录插入到在内存中的<span><span class="heti-spacing"> </span><span class="arithmatex">\(L_0\)</span></span>（系统为其分配了相当大的内存空间<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>。如果内存空间已满的话，那么就要将数据从内存移到硬盘里的<span class="heti-skip"><span class="heti-spacing"> </span>B+<span class="heti-spacing"> </span></span>树上。</li>
<li>具体来说，如果<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(L_1\)</span><span class="heti-spacing"> </span></span>是空的话，那么就将整个<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(L_0\)</span><span class="heti-spacing"> </span></span>写入到<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(L_1\)</span><span class="heti-spacing"> </span></span>上；否则的话，按键的升序扫描<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(L_0\)</span><span class="heti-spacing"> </span></span>的叶子层级，然后将里面的项和<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(L_1\)</span><span class="heti-spacing"> </span></span>的叶子层级里的项合并起来（同样需要扫描<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>。然后用自底向上的构建方法，根据合并后的项来创建新的<span class="heti-skip"><span class="heti-spacing"> </span>B+<span class="heti-spacing"> </span></span>树，用这棵新的树替代旧的<span><span class="heti-spacing"> </span><span class="arithmatex">\(L_1\)</span></span>。</li>
<li>上述方法的好处是能确保新树的叶子节点是顺序定位的，以避免随机<span class="heti-skip"><span class="heti-spacing"> </span>I/O<span class="heti-spacing"> </span></span>操作；同时确保叶子是满的，减少了空间开销。</li>
<li>但拷贝树需要不小的成本，所以这里介绍一些降低成本的方法：<ul>
<li>使用多级树，其中树<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(L_{i+1}\)</span><span class="heti-spacing"> </span></span>的最大容量是<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(L_i\)</span><span class="heti-spacing"> </span></span>的<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(k\)</span><span class="heti-spacing"> </span></span>倍，因此每个记录之多被写入<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(k\)</span><span class="heti-spacing"> </span></span>次。级数和<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\log_k (I/M)\)</span><span class="heti-spacing"> </span></span>成正比，其中<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(I\)</span><span class="heti-spacing"> </span></span>是总项数，<span><span class="arithmatex">\(M\)</span><span class="heti-spacing"> </span></span>是<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(L_0\)</span><span class="heti-spacing"> </span></span>的项数</li>
<li>除了<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(L_0\)</span><span class="heti-spacing"> </span></span>外，每级树都有至多<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(b\)</span><span class="heti-spacing"> </span></span>棵树（原来只有<span class="heti-skip"><span class="heti-spacing"> </span>1<span class="heti-spacing"> </span></span>棵树<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，这种变体称为<strong>按步合并索引</strong>(stepped-merge index)，它能够显著降低插入成本，但增加了查询成本</li>
</ul>
</li>
</ul>
</li>
<li>删除操作中除了找到并删除索引项外，还要插入一个<strong>删除项</strong>(deletion entry)，用于表明哪个索引项被删掉了。插入删除项的过程和插入一个普通索引项的过程是相同的。<ul>
<li>所以查找操作就要多出一步了：如果某些项存在删除项，那么在查找指定搜索键时需要同时找到原来的索引项以及删除项。如果发现删除项的话，那么就不返回原来的索引项。</li>
</ul>
</li>
<li>更新操作和删除类似，也要插入一个更新项。更新在合并操作中完成。</li>
</ul>
<h3 id="buffer-trees">Buffer Trees<a class="headerlink" href="#buffer-trees" title="Permanent link">⚓︎</a></h3>
<p><strong>缓冲区树</strong>是在<span class="heti-skip"><span class="heti-spacing"> </span>B+<span class="heti-spacing"> </span></span>树的基础上，让每个内部节点（包括根节点）都有一个关联的缓冲区。节点的结构如下所示：</p>
<div style="text-align: center">
<img src="images/lec10/19.png" width="80%/"/>
</div>
<ul>
<li>插入：<ul>
<li>在插入索引记录时，不是先遍历叶子节点，而是先将其插入到根节点的缓冲区中</li>
<li>如果缓冲区满了的话，那么缓冲区内的每个索引记录被推向下一级合适的孩子节点的缓冲区内，以此类推</li>
<li>在被向下推之前，所有在缓冲区内的记录都是按搜索键排好序的</li>
<li>如果下一级节点是叶子节点的话，那么索引记录就按正常方法插入到叶子节点中就行了</li>
<li>如果叶子节点满了的话就执行分裂操作，此时有可能会让内部节点分裂，对应的缓冲区同样需要分裂</li>
</ul>
</li>
<li>查找：<ul>
<li>相比普通的<span class="heti-skip"><span class="heti-spacing"> </span>B+<span class="heti-spacing"> </span></span>树查找，多了这样一步：在遍历内部节点时，检查一下节点的缓冲区内是否有要查找的搜索键值</li>
<li>范围查找同样适用</li>
</ul>
</li>
<li>删除和更新：<ul>
<li>和<span class="heti-skip"><span class="heti-spacing"> </span>LSM<span class="heti-spacing"> </span></span>树类似，也要插入删除项和更新项</li>
<li>也可以使用一般的<span class="heti-skip"><span class="heti-spacing"> </span>B+<span class="heti-spacing"> </span></span>树算法，但这样会带来更大的<span class="heti-skip"><span class="heti-spacing"> </span>I/O<span class="heti-spacing"> </span></span>成本</li>
</ul>
</li>
</ul>
<p>在最坏情况下，缓冲区树在<span class="heti-skip"><span class="heti-spacing"> </span>I/O<span class="heti-spacing"> </span></span>运算次数的上界会比<span class="heti-skip"><span class="heti-spacing"> </span>LSM<span class="heti-spacing"> </span></span>树更低。且对于读操作而言，缓冲区树会比<span class="heti-skip"><span class="heti-spacing"> </span>LSM<span class="heti-spacing"> </span></span>树快不少。然而对于写操作而言，缓冲区树的表现更差，因为它要求更多的随机<span><span class="heti-spacing"> </span>I/O</span>，因此花费更多的寻道时间。因此当写操作更多时，优先使用<span class="heti-skip"><span class="heti-spacing"> </span>LSM<span class="heti-spacing"> </span></span>树；当读操作更多时，优先使用缓冲区树。</p>
<h3 id="bvarepsilon-trees">B<span class="arithmatex">\(\varepsilon\)</span>-Trees<a class="headerlink" href="#bvarepsilon-trees" title="Permanent link">⚓︎</a></h3>
<p>我们不立即对<span class="heti-skip"><span class="heti-spacing"> </span>B+<span class="heti-spacing"> </span></span>树更新，而是将更新存储在内部节点对应键值项的日志缓存中。这样的树称为<a href="https://en.wikipedia.org/wiki/Fractal_tree_index"><strong>分形树</strong></a><span>(fractal trees)<span class="heti-spacing"> </span></span>或 <strong><span><span class="arithmatex">\(B\varepsilon\)</span><span class="heti-spacing"> </span></span>树</strong>。当缓冲区填满时，更新会逐步向下级节点增量式地传递。</p>
<details class="play">
<summary>动画演示</summary>
<p></p><div style="text-align: center">
<img src="images/lec10/40.gif" width="60%/"/>
</div>
</details>
<h2 id="bitmap-indices">Bitmap Indices<a class="headerlink" href="#bitmap-indices" title="Permanent link">⚓︎</a></h2>
<p><strong>位图索引</strong><span>(bitmap indices)<span class="heti-spacing"> </span></span>是一类适用于对多个键的简单查询的索引。在使用位图索引前，需要为关系中的每条记录标号（从<span class="heti-skip"><span class="heti-spacing"> </span>0<span class="heti-spacing"> </span></span>开始<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>。如果记录的大小固定，且被分配在某个文件内的连续块上，这一操作还是很容易的，此时记录编号就可以被转换为块编号。</p>
<p><strong>位图</strong><span>(bitmap)<span class="heti-spacing"> </span></span>就是一组位，对于关系<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(r\)</span><span class="heti-spacing"> </span></span>的属性<span><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span></span>，位图索引包含了<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>可取的每个值，而位的数量对应记录的数量。对于某个值<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(v_j\)</span><span class="heti-spacing"> </span></span>的位图，如果编号为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(i\)</span><span class="heti-spacing"> </span></span>的记录的属性值为<span><span class="heti-spacing"> </span><span class="arithmatex">\(v_j\)</span></span>，那么该位图的第<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(i\)</span><span class="heti-spacing"> </span></span>位置<span><span class="heti-spacing"> </span>1</span>，否则置<span><span class="heti-spacing"> </span>0</span>。</p>
<p>下面就是一个位图索引的例子：</p>
<details class="example" open="open">
<summary>例子</summary>
<p></p><div style="text-align: center">
<img src="images/lec10/20.png" width="80%/"/>
</div>
<p>对于以下查询：</p>
<div class="language-sql highlight"><pre><span></span><code><span id="__span-4-1"><a href="#__codelineno-4-1" id="__codelineno-4-1" name="__codelineno-4-1"></a><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span>
</span><span id="__span-4-2"><a href="#__codelineno-4-2" id="__codelineno-4-2" name="__codelineno-4-2"></a><span class="k">FROM</span><span class="w"> </span><span class="n">instructor_info</span>
</span><span id="__span-4-3"><a href="#__codelineno-4-3" id="__codelineno-4-3" name="__codelineno-4-3"></a><span class="k">WHERE</span><span class="w"> </span><span class="n">gender</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">'f'</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">income_level</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">'L2'</span><span class="p">;</span>
</span></code></pre></div>
<p>我们找到<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(gender\)</span><span class="heti-spacing"> </span></span>属性值为<span><span class="heti-spacing"> </span>f</span>，以及<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(income\_level\)</span><span class="heti-spacing"> </span></span>属性值为<span class="heti-skip"><span class="heti-spacing"> </span>L2<span class="heti-spacing"> </span></span>的位图，然后对这两个位图进行<strong>交</strong><span>(intersection)<span class="heti-spacing"> </span></span>运算（实际上是一个逻辑与的运算<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>。根据上图，<span class="arithmatex">\(gender = f(01101)，income\_level = L2(01000)\)</span>，交运算后的位图是<span><span class="heti-spacing"> </span>01000</span>，也就是说，编号为<span class="heti-skip"><span class="heti-spacing"> </span>1<span class="heti-spacing"> </span></span>的记录就是我们要查询的记录。</p>
</details>
<script>
    pseudocode.renderClass("pseudocode");
</script>
<aside class="md-source-file">
<span class="md-source-file__fact">
<span class="md-icon" title="最后更新">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M21 13.1c-.1 0-.3.1-.4.2l-1 1 2.1 2.1 1-1c.2-.2.2-.6 0-.8l-1.3-1.3c-.1-.1-.2-.2-.4-.2m-1.9 1.8-6.1 6V23h2.1l6.1-6.1zM12.5 7v5.2l4 2.4-1 1L11 13V7zM11 21.9c-5.1-.5-9-4.8-9-9.9C2 6.5 6.5 2 12 2c5.3 0 9.6 4.1 10 9.3-.3-.1-.6-.2-1-.2s-.7.1-1 .2C19.6 7.2 16.2 4 12 4c-4.4 0-8 3.6-8 8 0 4.1 3.1 7.5 7.1 7.9l-.1.2z"></path></svg>
</span>
<span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-datetime" title="2025年5月16日 18:34:31">2025年5月16日 18:34:31</span>
</span>
<span class="md-source-file__fact">
<span class="md-icon" title="创建日期">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M14.47 15.08 11 13V7h1.5v5.25l3.08 1.83c-.41.28-.79.62-1.11 1m-1.39 4.84c-.36.05-.71.08-1.08.08-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8c0 .37-.03.72-.08 1.08.69.1 1.33.32 1.92.64.1-.56.16-1.13.16-1.72 0-5.5-4.5-10-10-10S2 6.5 2 12s4.47 10 10 10c.59 0 1.16-.06 1.72-.16-.32-.59-.54-1.23-.64-1.92M18 15v3h-3v2h3v3h2v-3h3v-2h-3v-3z"></path></svg>
</span>
<span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-datetime" title="2024年10月7日 21:20:16">2024年10月7日 21:20:16</span>
</span>
</aside>
<p style="font-size: 30px; font-weight: 600">评论区</p>
<div>
    如果大家有什么问题或想法，欢迎在下方留言~
  </div>
<!-- Insert generated snippet here -->
<script async="" crossorigin="anonymous" data-category="Announcements" data-category-id="DIC_kwDOMAb9Zs4CfmpP" data-emit-metadata="0" data-input-position="bottom" data-lang="zh-CN" data-mapping="pathname" data-reactions-enabled="1" data-repo="noughtq/notebook" data-repo-id="R_kgDOMAb9Zg" data-strict="0" data-theme="preferred_color_scheme" src="https://giscus.app/client.js">
</script>
<!-- Synchronize Giscus theme with palette -->
<script>
    var giscus = document.querySelector("script[src*=giscus]")

    // Set palette on initial load
    var palette = __md_get("__palette")
    if (palette && typeof palette.color === "object") {
      var theme = palette.color.scheme === "slate"
        ? "transparent_dark"
        : "light"

      // Instruct Giscus to set theme
      giscus.setAttribute("data-theme", theme) 
    }

    // Register event handlers after documented loaded
    document.addEventListener("DOMContentLoaded", function() {
      var ref = document.querySelector("[data-md-component=palette]")
      ref.addEventListener("change", function() {
        var palette = __md_get("__palette")
        if (palette && typeof palette.color === "object") {
          var theme = palette.color.scheme === "slate"
            ? "dark"
            : "light"

          // Instruct Giscus to change theme
          var frame = document.querySelector(".giscus-frame")
          frame.contentWindow.postMessage(
            { giscus: { setConfig: { theme } } },
            "https://giscus.app"
          )
        }
      })
    })
  </script>
<!-- 标题计数器 -->
<link href="/css/counter.css" rel="stylesheet"/>
<!-- 主页个性化 -->
</article>
</div>
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
</div>
<button class="md-top md-icon" data-md-component="top" hidden="" type="button">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"></path></svg>
  回到页面顶部
</button>
</main>
<footer class="md-footer">
<nav aria-label="页脚" class="md-footer__inner md-grid">
<a aria-label="上一页: Lec 9: Database Storage Structures" class="md-footer__link md-footer__link--prev" href="9.html">
<div class="md-footer__button md-icon">
<svg viewbox="0 0 320 512" xmlns="http://www.w3.org/2000/svg"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256l137.3-137.4c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"></path></svg>
</div>
<div class="md-footer__title">
<span class="md-footer__direction">
                上一页
              </span>
<div class="md-ellipsis">
                Lec 9: Database Storage Structures
              </div>
</div>
</a>
<a aria-label="下一页: Lec 11: Query Processing" class="md-footer__link md-footer__link--next" href="11.html">
<div class="md-footer__title">
<span class="md-footer__direction">
                下一页
              </span>
<div class="md-ellipsis">
                Lec 11: Query Processing
              </div>
</div>
<div class="md-footer__button md-icon">
<svg viewbox="0 0 320 512" xmlns="http://www.w3.org/2000/svg"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"></path></svg>
</div>
</a>
</nav>
<div class="md-footer-meta md-typeset">
<div class="md-footer-meta__inner md-grid">
<div class="md-copyright" style="margin-left: 33.5%">
<div class="md-copyright__highlight" style="text-align: center">
        Copyright © 2024-2025 <a href="https://github.com/NoughtQ">NoughtQ</a>
</div>
    
    
      Powered by
      <a href="https://www.mkdocs.org/" rel="noopener" target="_blank">
        MkDocs
      </a>
      with theme
      <a href="https://squidfunk.github.io/mkdocs-material/" rel="noopener" target="_blank">
        Material
      </a>
      modified by
      <a href="https://github.com/NoughtQ" rel="noopener" target="_blank">
        NoughtQ
      </a>
<!-- <br> -->
<div style="text-align: center;">
<a href="https://icp.gov.moe/?keyword=20252357" target="_blank">萌ICP备20252357号</a>
</div>
</div>
<div class="md-social">
<a class="md-social__link" href="https://github.com/noughtq" rel="noopener" target="_blank" title="github.com">
<svg viewbox="0 0 496 512" xmlns="http://www.w3.org/2000/svg"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8M97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"></path></svg>
</a>
<a class="md-social__link" href="https://blog.noughtq.top" rel="noopener" target="_blank" title="blog.noughtq.top">
<svg viewbox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M192 32c0 17.7 14.3 32 32 32 123.7 0 224 100.3 224 224 0 17.7 14.3 32 32 32s32-14.3 32-32C512 128.9 383.1 0 224 0c-17.7 0-32 14.3-32 32m0 96c0 17.7 14.3 32 32 32 70.7 0 128 57.3 128 128 0 17.7 14.3 32 32 32s32-14.3 32-32c0-106-86-192-192-192-17.7 0-32 14.3-32 32m-96 16c0-26.5-21.5-48-48-48S0 117.5 0 144v224c0 79.5 64.5 144 144 144s144-64.5 144-144-64.5-144-144-144h-16v96h16c26.5 0 48 21.5 48 48s-21.5 48-48 48-48-21.5-48-48z"></path></svg>
</a>
<a class="md-social__link" href="mailto:noughtq666@gmail.com" rel="noopener" target="_blank" title="">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="m20 8-8 5-8-5V6l8 5 8-5m0-2H4c-1.11 0-2 .89-2 2v12a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2"></path></svg>
</a>
</div>
</div>
</div>
</footer>
</div>
<div class="md-dialog" data-md-component="dialog">
<div class="md-dialog__inner md-typeset"></div>
</div>
<script id="__config" type="application/json">{"base": "../..", "features": ["content.action.edit", "content.action.view", "content.code.copy", "content.code.annotate", "content.footnote.tooltips", "header.autohide", "navigation.tabs", "navigation.top", "navigation.footer", "navigation.indexes", "navigation.tracking", "navigation.prune", "search.share"], "search": "../../assets/javascripts/workers/search.d50fe291.min.js", "tags": null, "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}, "version": null}</script>
<script src="../../assets/javascripts/bundle.13a4f30d.min.js"></script>
<script src="../../js/anchor.js"></script>
<script src="../../js/katex.js"></script>
<script src="../../js/toc.js"></script>
<script src="../../js/typed.js"></script>
<script src="../../js/custom.js"></script>
<script src="https://unpkg.com/katex@0/dist/katex.min.js"></script>
<script src="https://unpkg.com/katex@0/dist/contrib/auto-render.min.js"></script>
</body>
</html>