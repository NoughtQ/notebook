<!DOCTYPE html>
<html class="no-js" lang="zh">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width,initial-scale=1" name="viewport"/>
<meta content="NoughtQ的笔记本，主要记录一些 CS 相关的笔记" name="description"/>
<meta content="NoughtQ" name="author"/>
<link href="https://notebook.noughtq.top/system/db/14.html" rel="canonical"/>
<link href="13.html" rel="prev"/>
<link href="15.html" rel="next"/>
<link href="../../feed_rss_created.xml" rel="alternate" title="RSS 订阅" type="application/rss+xml"/>
<link href="../../feed_rss_updated.xml" rel="alternate" title="已更新内容的 RSS 订阅" type="application/rss+xml"/>
<link href="../../assets/favicon.png" rel="icon"/>
<meta content="mkdocs-1.6.1, mkdocs-material-9.6.14" name="generator"/>
<title>Lec 14: Concurrency Control - NoughtQ的笔记本</title>
<link href="../../assets/stylesheets/main.342714a4.min.css" rel="stylesheet"/>
<link href="../../assets/stylesheets/palette.06af60db.min.css" rel="stylesheet"/>
<link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect"/>
<link href="https://fonts.googleapis.com/css?family=JetBrains+Mono,+LXGW+WenKai+Screen+GB+Screen:300,300i,400,400i,700,700i%7CJetBrains+Mono,+Consolas:400,400i,700,700i&amp;display=fallback" rel="stylesheet"/>
<style>:root{--md-text-font:"JetBrains Mono, LXGW WenKai Screen GB Screen";--md-code-font:"JetBrains Mono, Consolas"}</style>
<link href="../../css/heti.css" rel="stylesheet"/>
<link href="../../css/toc_extra.css" rel="stylesheet"/>
<link href="../../css/timeline.css" rel="stylesheet"/>
<link href="../../css/card.css" rel="stylesheet"/>
<link href="../../css/custom.css" rel="stylesheet"/>
<link href="../../css/extra_changelog.css" rel="stylesheet"/>
<link href="../../css/header.css" rel="stylesheet"/>
<link href="../../css/sidebar.css" rel="stylesheet"/>
<link href="https://unpkg.com/katex@0/dist/katex.min.css" rel="stylesheet"/>
<link href="https://gcore.jsdelivr.net/npm/lxgw-wenkai-screen-webfont@1.1.0/style.css" rel="stylesheet"/>
<link href="https://gcore.jsdelivr.net/npm/lxgw-wenkai-webfont@1.1.0/style.css" rel="stylesheet"/>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&amp;display=swap" rel="stylesheet"/>
<script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
<script id="__analytics">function __md_analytics(){function e(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],e("js",new Date),e("config","G-43NH8CVRCJ"),document.addEventListener("DOMContentLoaded",(function(){document.forms.search&&document.forms.search.query.addEventListener("blur",(function(){this.value&&e("event","search",{search_term:this.value})}));document$.subscribe((function(){var t=document.forms.feedback;if(void 0!==t)for(var a of t.querySelectorAll("[type=submit]"))a.addEventListener("click",(function(a){a.preventDefault();var n=document.location.pathname,d=this.getAttribute("data-md-value");e("event","feedback",{page:n,data:d}),t.firstElementChild.disabled=!0;var r=t.querySelector(".md-feedback__note [data-md-value='"+d+"']");r&&(r.hidden=!1)})),t.hidden=!1})),location$.subscribe((function(t){e("config","G-43NH8CVRCJ",{page_path:t.pathname})}))}));var t=document.createElement("script");t.async=!0,t.src="https://www.googletagmanager.com/gtag/js?id=G-43NH8CVRCJ",document.getElementById("__analytics").insertAdjacentElement("afterEnd",t)}</script>
<script>"undefined"!=typeof __md_analytics&&__md_analytics()</script>
</head>
<body data-md-color-accent="indigo" data-md-color-primary="indigo" data-md-color-scheme="slate" dir="ltr">
<input autocomplete="off" class="md-toggle" data-md-toggle="drawer" id="__drawer" type="checkbox"/>
<input autocomplete="off" class="md-toggle" data-md-toggle="search" id="__search" type="checkbox"/>
<label class="md-overlay" for="__drawer"></label>
<div data-md-component="skip">
<a class="md-skip" href="#lec-14-concurrency-control">
          跳转至
        </a>
</div>
<div data-md-component="announce">
</div>
<header class="md-header" data-md-component="header">
<nav aria-label="页眉" class="md-header__inner md-grid">
<a aria-label="NoughtQ的笔记本" class="md-header__button md-logo" data-md-component="logo" href="../.." title="NoughtQ的笔记本">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M9.05 9H7.06V6h1.99V4.03H7.06v-1c0-1.11.89-1.99 1.99-1.99h5.98V8l2.47-1.5L20 8V1.04h1c1.05 0 2 .96 2 1.99V17c0 1.03-.95 2-2 2H9.05c-1.05 0-1.99-.95-1.99-2v-1h1.99v-2H7.06v-3h1.99zM1 18h2v-3H1v-2h2v-3H1V8h2V5h2v3H3v2h2v3H3v2h2v3H3v2h2v1h16v2H5a2 2 0 0 1-2-2v-1H1z"></path></svg>
</a>
<label class="md-header__button md-icon" for="__drawer">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"></path></svg>
</label>
<div class="md-header__title" data-md-component="header-title">
<div class="md-header__ellipsis">
<div class="md-header__topic">
<span class="md-ellipsis">
            NoughtQ的笔记本
          </span>
</div>
<div class="md-header__topic" data-md-component="header-topic">
<span class="md-ellipsis">
            
              Lec 14: Concurrency Control
            
          </span>
</div>
</div>
</div>
<form class="md-header__option" data-md-component="palette">
<input aria-label="Dark Mode" class="md-option" data-md-color-accent="indigo" data-md-color-media="(prefer-color-scheme: dark)" data-md-color-primary="indigo" data-md-color-scheme="slate" id="__palette_0" name="__palette" type="radio"/>
<label class="md-header__button md-icon" for="__palette_1" hidden="" title="Dark Mode">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="m17.75 4.09-2.53 1.94.91 3.06-2.63-1.81-2.63 1.81.91-3.06-2.53-1.94L12.44 4l1.06-3 1.06 3zm3.5 6.91-1.64 1.25.59 1.98-1.7-1.17-1.7 1.17.59-1.98L15.75 11l2.06-.05L18.5 9l.69 1.95zm-2.28 4.95c.83-.08 1.72 1.1 1.19 1.85-.32.45-.66.87-1.08 1.27C15.17 23 8.84 23 4.94 19.07c-3.91-3.9-3.91-10.24 0-14.14.4-.4.82-.76 1.27-1.08.75-.53 1.93.36 1.85 1.19-.27 2.86.69 5.83 2.89 8.02a9.96 9.96 0 0 0 8.02 2.89m-1.64 2.02a12.08 12.08 0 0 1-7.8-3.47c-2.17-2.19-3.33-5-3.49-7.82-2.81 3.14-2.7 7.96.31 10.98 3.02 3.01 7.84 3.12 10.98.31"></path></svg>
</label>
<input aria-label="Light Mode" class="md-option" data-md-color-accent="indigo" data-md-color-media="(prefer-color-scheme: light)" data-md-color-primary="indigo" data-md-color-scheme="default" id="__palette_1" name="__palette" type="radio"/>
<label class="md-header__button md-icon" for="__palette_0" hidden="" title="Light Mode">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 7a5 5 0 0 1 5 5 5 5 0 0 1-5 5 5 5 0 0 1-5-5 5 5 0 0 1 5-5m0 2a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3m0-7 2.39 3.42C13.65 5.15 12.84 5 12 5s-1.65.15-2.39.42zM3.34 7l4.16-.35A7.2 7.2 0 0 0 5.94 8.5c-.44.74-.69 1.5-.83 2.29zm.02 10 1.76-3.77a7.131 7.131 0 0 0 2.38 4.14zM20.65 7l-1.77 3.79a7.02 7.02 0 0 0-2.38-4.15zm-.01 10-4.14.36c.59-.51 1.12-1.14 1.54-1.86.42-.73.69-1.5.83-2.29zM12 22l-2.41-3.44c.74.27 1.55.44 2.41.44.82 0 1.63-.17 2.37-.44z"></path></svg>
</label>
</form>
<script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
<label class="md-header__button md-icon" for="__search">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"></path></svg>
</label>
<div class="md-search" data-md-component="search" role="dialog">
<label class="md-search__overlay" for="__search"></label>
<div class="md-search__inner" role="search">
<form class="md-search__form" name="search">
<input aria-label="搜索" autocapitalize="off" autocomplete="off" autocorrect="off" class="md-search__input" data-md-component="search-query" name="query" placeholder="搜索" required="" spellcheck="false" type="text"/>
<label class="md-search__icon md-icon" for="__search">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"></path></svg>
<svg viewbox="0 0 320 512" xmlns="http://www.w3.org/2000/svg"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256l137.3-137.4c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"></path></svg>
</label>
<nav aria-label="查找" class="md-search__options">
<a aria-label="分享" class="md-search__icon md-icon" data-clipboard="" data-clipboard-text="" data-md-component="search-share" href="javascript:void(0)" tabindex="-1" title="分享">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9a3 3 0 0 0-3 3 3 3 0 0 0 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.15c-.05.21-.08.43-.08.66 0 1.61 1.31 2.91 2.92 2.91s2.92-1.3 2.92-2.91A2.92 2.92 0 0 0 18 16.08"></path></svg>
</a>
<button aria-label="清空当前内容" class="md-search__icon md-icon" tabindex="-1" title="清空当前内容" type="reset">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"></path></svg>
</button>
</nav>
</form>
<div class="md-search__output">
<div class="md-search__scrollwrap" data-md-scrollfix="" tabindex="0">
<div class="md-search-result" data-md-component="search-result">
<div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
<ol class="md-search-result__list" role="presentation"></ol>
</div>
</div>
</div>
</div>
</div>
<div class="md-header__source">
<a class="md-source" data-md-component="source" href="https://github.com/noughtq/notebook" title="前往仓库">
<div class="md-source__icon md-icon">
<svg viewbox="0 0 448 512" xmlns="http://www.w3.org/2000/svg"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81"></path></svg>
</div>
<div class="md-source__repository">
    NoughtQ/Notebook
  </div>
</a>
</div>
</nav>
</header>
<div class="md-container" data-md-component="container">
<nav aria-label="标签" class="md-tabs" data-md-component="tabs">
<div class="md-grid">
<ul class="md-tabs__list">
<li class="md-tabs__item">
<a class="md-tabs__link" href="../../index.html">
          
  
  
    
  
  🏫主页

        </a>
</li>
<li class="md-tabs__item">
<a class="md-tabs__link" href="../../lang/index.html">
          
  
  
    
  
  🔡语言

        </a>
</li>
<li class="md-tabs__item">
<a class="md-tabs__link" href="../../math/index.html">
          
  
  
    
  
  📊数学相关

        </a>
</li>
<li class="md-tabs__item">
<a class="md-tabs__link" href="../../algorithms/index.html">
          
  
  
    
  
  🧮算法相关

        </a>
</li>
<li class="md-tabs__item">
<a class="md-tabs__link" href="../../software/index.html">
          
  
  
    
  
  💾软件相关

        </a>
</li>
<li class="md-tabs__item md-tabs__item--active">
<a class="md-tabs__link" href="../index.html">
          
  
  
    
  
  💻系统相关

        </a>
</li>
<li class="md-tabs__item">
<a class="md-tabs__link" href="../../web/index.html">
          
  
  
    
  
  🌏Web相关

        </a>
</li>
<li class="md-tabs__item">
<a class="md-tabs__link" href="../../sec/ctf-101/index.html">
          
  
  
    
  
  🛡️信息安全

        </a>
</li>
<li class="md-tabs__item">
<a class="md-tabs__link" href="../../ai/index.html">
          
  
  
    
  
  🤖人工智能

        </a>
</li>
<li class="md-tabs__item">
<a class="md-tabs__link" href="../../misc/index.html">
          
  
  
    
  
  🗃️杂项

        </a>
</li>
<li class="md-tabs__item">
<a class="md-tabs__link" href="../../tools/index.html">
          
  
  
    
  
  🛠️工具

        </a>
</li>
<li class="md-tabs__item">
<a class="md-tabs__link" href="../../papers/index.html">
          
  
  
    
  
  📑论文阅读

        </a>
</li>
</ul>
</div>
</nav>
<main class="md-main" data-md-component="main">
<div class="md-main__inner md-grid">
<div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav aria-label="导航栏" class="md-nav md-nav--primary md-nav--lifted" data-md-level="0">
<label class="md-nav__title" for="__drawer">
<a aria-label="NoughtQ的笔记本" class="md-nav__button md-logo" data-md-component="logo" href="../.." title="NoughtQ的笔记本">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M9.05 9H7.06V6h1.99V4.03H7.06v-1c0-1.11.89-1.99 1.99-1.99h5.98V8l2.47-1.5L20 8V1.04h1c1.05 0 2 .96 2 1.99V17c0 1.03-.95 2-2 2H9.05c-1.05 0-1.99-.95-1.99-2v-1h1.99v-2H7.06v-3h1.99zM1 18h2v-3H1v-2h2v-3H1V8h2V5h2v3H3v2h2v3H3v2h2v3H3v2h2v1h16v2H5a2 2 0 0 1-2-2v-1H1z"></path></svg>
</a>
    NoughtQ的笔记本
  </label>
<div class="md-nav__source">
<a class="md-source" data-md-component="source" href="https://github.com/noughtq/notebook" title="前往仓库">
<div class="md-source__icon md-icon">
<svg viewbox="0 0 448 512" xmlns="http://www.w3.org/2000/svg"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81"></path></svg>
</div>
<div class="md-source__repository">
    NoughtQ/Notebook
  </div>
</a>
</div>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
<a class="md-nav__link" href="../../index.html">
<span class="md-ellipsis">
    🏫主页
    
  </span>
<span class="md-nav__icon md-icon"></span>
</a>
</li>
<li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
<a class="md-nav__link" href="../../lang/index.html">
<span class="md-ellipsis">
    🔡语言
    
  </span>
<span class="md-nav__icon md-icon"></span>
</a>
</li>
<li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
<a class="md-nav__link" href="../../math/index.html">
<span class="md-ellipsis">
    📊数学相关
    
  </span>
<span class="md-nav__icon md-icon"></span>
</a>
</li>
<li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
<a class="md-nav__link" href="../../algorithms/index.html">
<span class="md-ellipsis">
    🧮算法相关
    
  </span>
<span class="md-nav__icon md-icon"></span>
</a>
</li>
<li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
<a class="md-nav__link" href="../../software/index.html">
<span class="md-ellipsis">
    💾软件相关
    
  </span>
<span class="md-nav__icon md-icon"></span>
</a>
</li>
<li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
<input checked="" class="md-nav__toggle md-toggle" id="__nav_6" type="checkbox"/>
<div class="md-nav__link md-nav__container">
<a class="md-nav__link" href="../index.html">
<span class="md-ellipsis">
    💻系统相关
    
  </span>
</a>
<label class="md-nav__link" for="__nav_6" id="__nav_6_label" tabindex="">
<span class="md-nav__icon md-icon"></span>
</label>
</div>
<nav aria-expanded="true" aria-labelledby="__nav_6_label" class="md-nav" data-md-level="1">
<label class="md-nav__title" for="__nav_6">
<span class="md-nav__icon md-icon"></span>
            💻系统相关
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
<a class="md-nav__link" href="../csapp/index.html">
<span class="md-ellipsis">
    CSAPP
    
  </span>
<span class="md-nav__icon md-icon"></span>
</a>
</li>
<li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
<a class="md-nav__link" href="../dld/index.html">
<span class="md-ellipsis">
    数字逻辑设计
    
  </span>
<span class="md-nav__icon md-icon"></span>
</a>
</li>
<li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
<a class="md-nav__link" href="../co/index.html">
<span class="md-ellipsis">
    计算机组成
    
  </span>
<span class="md-nav__icon md-icon"></span>
</a>
</li>
<li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
<a class="md-nav__link" href="../ca/index.html">
<span class="md-ellipsis">
    计算机体系结构
    
  </span>
<span class="md-nav__icon md-icon"></span>
</a>
</li>
<li class="md-nav__item md-nav__item--active md-nav__item--nested">
<input checked="" class="md-nav__toggle md-toggle" id="__nav_6_6" type="checkbox"/>
<div class="md-nav__link md-nav__container">
<a class="md-nav__link" href="index.html">
<span class="md-ellipsis">
    数据库系统
    
  </span>
</a>
<label class="md-nav__link" for="__nav_6_6" id="__nav_6_6_label" tabindex="0">
<span class="md-nav__icon md-icon"></span>
</label>
</div>
<nav aria-expanded="true" aria-labelledby="__nav_6_6_label" class="md-nav" data-md-level="2">
<label class="md-nav__title" for="__nav_6_6">
<span class="md-nav__icon md-icon"></span>
            数据库系统
          </label>
<ul class="md-nav__list" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="1.html">
<span class="md-ellipsis">
    Lec 1: Introduction
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="2.html">
<span class="md-ellipsis">
    Lec 2: Relational Model
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="3.html">
<span class="md-ellipsis">
    Lec 3: Introduction to SQL
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="4.html">
<span class="md-ellipsis">
    Lec 4: Intermediate SQL
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="5.html">
<span class="md-ellipsis">
    Lec 5: Advanced SQL
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="6.html">
<span class="md-ellipsis">
    Lec 6: Database Design Using the E-R Model
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="7.html">
<span class="md-ellipsis">
    Lec 7: Relational Database Design
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="8.html">
<span class="md-ellipsis">
    Lec 8: Physical Storage Systems
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="9.html">
<span class="md-ellipsis">
    Lec 9: Database Storage Structures
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="10.html">
<span class="md-ellipsis">
    Lec 10: Indexing
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="11.html">
<span class="md-ellipsis">
    Lec 11: Query Processing
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="12.html">
<span class="md-ellipsis">
    Lec 12: Query Optimization
    
  </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="13.html">
<span class="md-ellipsis">
    Lec 13: Transactions
    
  </span>
</a>
</li>
<li class="md-nav__item md-nav__item--active">
<input class="md-nav__toggle md-toggle" id="__toc" type="checkbox"/>
<label class="md-nav__link md-nav__link--active" for="__toc">
<span class="md-ellipsis">
    Lec 14: Concurrency Control
    
  </span>
<span class="md-nav__icon md-icon"></span>
</label>
<a class="md-nav__link md-nav__link--active" href="14.html">
<span class="md-ellipsis">
    Lec 14: Concurrency Control
    
  </span>
</a>
<nav aria-label="目录" class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">
<span class="md-nav__icon md-icon"></span>
        目录
      </label>
<ul class="md-nav__list" data-md-component="toc" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="#lock-based-protocols">
<span class="md-ellipsis">
      Lock-Based Protocols
    </span>
</a>
<nav aria-label="Lock-Based Protocols" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#locks">
<span class="md-ellipsis">
      Locks
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#granting-of-locks">
<span class="md-ellipsis">
      Granting of Locks
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#the-two-phase-locking-protocol">
<span class="md-ellipsis">
      The Two-Phase Locking Protocol
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#implementation-of-locking">
<span class="md-ellipsis">
      Implementation of Locking
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#graph-based-protocols">
<span class="md-ellipsis">
      Graph-Based Protocols
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#deadlock-handling">
<span class="md-ellipsis">
      Deadlock Handling
    </span>
</a>
<nav aria-label="Deadlock Handling" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#deadlock-prevention">
<span class="md-ellipsis">
      Deadlock Prevention
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#deadlock-detection-and-recovery">
<span class="md-ellipsis">
      Deadlock Detection and Recovery
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#multiple-granulartiy">
<span class="md-ellipsis">
      Multiple Granulartiy
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#operations">
<span class="md-ellipsis">
      Operations
    </span>
</a>
<nav aria-label="Operations" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#deletion">
<span class="md-ellipsis">
      Deletion
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#insertion">
<span class="md-ellipsis">
      Insertion
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#predicate-reads-and-the-phantom-phenomenon">
<span class="md-ellipsis">
      Predicate Reads and the Phantom Phenomenon
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#timestamp-based-protocols">
<span class="md-ellipsis">
      Timestamp-Based Protocols
    </span>
</a>
<nav aria-label="Timestamp-Based Protocols" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#timestamps">
<span class="md-ellipsis">
      Timestamps
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#the-timestamp-ordering-protocol">
<span class="md-ellipsis">
      The Timestamp-Ordering Protocol
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#thomas-write-rule">
<span class="md-ellipsis">
      Thomas' Write Rule
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#validation-based-protocols">
<span class="md-ellipsis">
      Validation-Based Protocols
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#multiversion-schemes">
<span class="md-ellipsis">
      Multiversion Schemes
    </span>
</a>
<nav aria-label="Multiversion Schemes" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#multiversion-timestamp-ordering">
<span class="md-ellipsis">
      Multiversion Timestamp Ordering
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#multiversion-two-phase-locking">
<span class="md-ellipsis">
      Multiversion Two-Phase Locking
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#mvcc-design-decision">
<span class="md-ellipsis">
      MVCC Design Decision
    </span>
</a>
<nav aria-label="MVCC Design Decision" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#version-storage">
<span class="md-ellipsis">
      Version Storage
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#garbage-collection">
<span class="md-ellipsis">
      Garbage Collection
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#index-management">
<span class="md-ellipsis">
      Index Management
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#deletion_1">
<span class="md-ellipsis">
      Deletion
    </span>
</a>
</li>
</ul>
</nav>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#snapshot-isolation">
<span class="md-ellipsis">
      Snapshot Isolation
    </span>
</a>
<nav aria-label="Snapshot Isolation" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#multiversioning-in-snapshot-isolation">
<span class="md-ellipsis">
      Multiversioning in Snapshot Isolation
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#validation-steps-for-update-transactions">
<span class="md-ellipsis">
      Validation Steps for Update Transactions
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#serializability-issues-and-solutions">
<span class="md-ellipsis">
      Serializability Issues and Solutions
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#weak-levels-of-consistency-in-practice">
<span class="md-ellipsis">
      Weak Levels of Consistency in Practice
    </span>
</a>
<nav aria-label="Weak Levels of Consistency in Practice" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#degree-two-consistency">
<span class="md-ellipsis">
      Degree-Two Consistency
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#cursor-stability">
<span class="md-ellipsis">
      Cursor Stability
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#concurrency-control-across-user-interactions">
<span class="md-ellipsis">
      Concurrency Control Across User Interactions
    </span>
</a>
</li>
</ul>
</nav>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="15.html">
<span class="md-ellipsis">
    Lec 15: Recovery System
    
  </span>
</a>
</li>
</ul>
</nav>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
<a class="md-nav__link" href="../../web/index.html">
<span class="md-ellipsis">
    🌏Web相关
    
  </span>
<span class="md-nav__icon md-icon"></span>
</a>
</li>
<li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
<a class="md-nav__link" href="../../sec/ctf-101/index.html">
<span class="md-ellipsis">
    🛡️信息安全
    
  </span>
<span class="md-nav__icon md-icon"></span>
</a>
</li>
<li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
<a class="md-nav__link" href="../../ai/index.html">
<span class="md-ellipsis">
    🤖人工智能
    
  </span>
<span class="md-nav__icon md-icon"></span>
</a>
</li>
<li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
<a class="md-nav__link" href="../../misc/index.html">
<span class="md-ellipsis">
    🗃️杂项
    
  </span>
<span class="md-nav__icon md-icon"></span>
</a>
</li>
<li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
<a class="md-nav__link" href="../../tools/index.html">
<span class="md-ellipsis">
    🛠️工具
    
  </span>
<span class="md-nav__icon md-icon"></span>
</a>
</li>
<li class="md-nav__item md-nav__item--pruned md-nav__item--nested">
<a class="md-nav__link" href="../../papers/index.html">
<span class="md-ellipsis">
    📑论文阅读
    
  </span>
<span class="md-nav__icon md-icon"></span>
</a>
</li>
</ul>
</nav>
</div>
</div>
</div>
<div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc">
<div class="md-sidebar__scrollwrap">
<div class="md-sidebar__inner">
<nav aria-label="目录" class="md-nav md-nav--secondary">
<label class="md-nav__title" for="__toc">
<span class="md-nav__icon md-icon"></span>
        目录
      </label>
<ul class="md-nav__list" data-md-component="toc" data-md-scrollfix="">
<li class="md-nav__item">
<a class="md-nav__link" href="#lock-based-protocols">
<span class="md-ellipsis">
      Lock-Based Protocols
    </span>
</a>
<nav aria-label="Lock-Based Protocols" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#locks">
<span class="md-ellipsis">
      Locks
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#granting-of-locks">
<span class="md-ellipsis">
      Granting of Locks
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#the-two-phase-locking-protocol">
<span class="md-ellipsis">
      The Two-Phase Locking Protocol
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#implementation-of-locking">
<span class="md-ellipsis">
      Implementation of Locking
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#graph-based-protocols">
<span class="md-ellipsis">
      Graph-Based Protocols
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#deadlock-handling">
<span class="md-ellipsis">
      Deadlock Handling
    </span>
</a>
<nav aria-label="Deadlock Handling" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#deadlock-prevention">
<span class="md-ellipsis">
      Deadlock Prevention
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#deadlock-detection-and-recovery">
<span class="md-ellipsis">
      Deadlock Detection and Recovery
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#multiple-granulartiy">
<span class="md-ellipsis">
      Multiple Granulartiy
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#operations">
<span class="md-ellipsis">
      Operations
    </span>
</a>
<nav aria-label="Operations" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#deletion">
<span class="md-ellipsis">
      Deletion
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#insertion">
<span class="md-ellipsis">
      Insertion
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#predicate-reads-and-the-phantom-phenomenon">
<span class="md-ellipsis">
      Predicate Reads and the Phantom Phenomenon
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#timestamp-based-protocols">
<span class="md-ellipsis">
      Timestamp-Based Protocols
    </span>
</a>
<nav aria-label="Timestamp-Based Protocols" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#timestamps">
<span class="md-ellipsis">
      Timestamps
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#the-timestamp-ordering-protocol">
<span class="md-ellipsis">
      The Timestamp-Ordering Protocol
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#thomas-write-rule">
<span class="md-ellipsis">
      Thomas' Write Rule
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#validation-based-protocols">
<span class="md-ellipsis">
      Validation-Based Protocols
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#multiversion-schemes">
<span class="md-ellipsis">
      Multiversion Schemes
    </span>
</a>
<nav aria-label="Multiversion Schemes" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#multiversion-timestamp-ordering">
<span class="md-ellipsis">
      Multiversion Timestamp Ordering
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#multiversion-two-phase-locking">
<span class="md-ellipsis">
      Multiversion Two-Phase Locking
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#mvcc-design-decision">
<span class="md-ellipsis">
      MVCC Design Decision
    </span>
</a>
<nav aria-label="MVCC Design Decision" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#version-storage">
<span class="md-ellipsis">
      Version Storage
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#garbage-collection">
<span class="md-ellipsis">
      Garbage Collection
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#index-management">
<span class="md-ellipsis">
      Index Management
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#deletion_1">
<span class="md-ellipsis">
      Deletion
    </span>
</a>
</li>
</ul>
</nav>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#snapshot-isolation">
<span class="md-ellipsis">
      Snapshot Isolation
    </span>
</a>
<nav aria-label="Snapshot Isolation" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#multiversioning-in-snapshot-isolation">
<span class="md-ellipsis">
      Multiversioning in Snapshot Isolation
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#validation-steps-for-update-transactions">
<span class="md-ellipsis">
      Validation Steps for Update Transactions
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#serializability-issues-and-solutions">
<span class="md-ellipsis">
      Serializability Issues and Solutions
    </span>
</a>
</li>
</ul>
</nav>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#weak-levels-of-consistency-in-practice">
<span class="md-ellipsis">
      Weak Levels of Consistency in Practice
    </span>
</a>
<nav aria-label="Weak Levels of Consistency in Practice" class="md-nav">
<ul class="md-nav__list">
<li class="md-nav__item">
<a class="md-nav__link" href="#degree-two-consistency">
<span class="md-ellipsis">
      Degree-Two Consistency
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#cursor-stability">
<span class="md-ellipsis">
      Cursor Stability
    </span>
</a>
</li>
<li class="md-nav__item">
<a class="md-nav__link" href="#concurrency-control-across-user-interactions">
<span class="md-ellipsis">
      Concurrency Control Across User Interactions
    </span>
</a>
</li>
</ul>
</nav>
</li>
</ul>
</nav>
</div>
</div>
</div>
<div class="md-content" data-md-component="content">
<article class="md-content__inner md-typeset">
<a class="md-content__button md-icon" href="https://github.com/noughtq/notebook/edit/master/docs/system/db/14.md" title="编辑此页">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M10 20H6V4h7v5h5v3.1l2-2V8l-6-6H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h4zm10.2-7c.1 0 .3.1.4.2l1.3 1.3c.2.2.2.6 0 .8l-1 1-2.1-2.1 1-1c.1-.1.2-.2.4-.2m0 3.9L14.1 23H12v-2.1l6.1-6.1z"></path></svg>
</a>
<a class="md-content__button md-icon" href="https://github.com/noughtq/notebook/raw/master/docs/system/db/14.md" title="查看本页的源代码">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M17 18c.56 0 1 .44 1 1s-.44 1-1 1-1-.44-1-1 .44-1 1-1m0-3c-2.73 0-5.06 1.66-6 4 .94 2.34 3.27 4 6 4s5.06-1.66 6-4c-.94-2.34-3.27-4-6-4m0 6.5a2.5 2.5 0 0 1-2.5-2.5 2.5 2.5 0 0 1 2.5-2.5 2.5 2.5 0 0 1 2.5 2.5 2.5 2.5 0 0 1-2.5 2.5M9.27 20H6V4h7v5h5v4.07c.7.08 1.36.25 2 .49V8l-6-6H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h4.5a8.2 8.2 0 0 1-1.23-2"></path></svg>
</a>
<div><h1 id="lec-14-concurrency-control">Lec 14: Concurrency Control<a class="headerlink" href="#lec-14-concurrency-control" title="Permanent link">⚓︎</a></h1>
<div style="margin-top: -30px; font-size: 0.9em; opacity: 0.7;">
<p><span class="twemoji"><svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 2A10 10 0 0 0 2 12a10 10 0 0 0 10 10 10 10 0 0 0 10-10h-2a8 8 0 0 1-8 8 8 8 0 0 1-8-8 8 8 0 0 1 8-8zm6.78 1a.7.7 0 0 0-.48.2l-1.22 1.21 2.5 2.5L20.8 5.7c.26-.26.26-.7 0-.95L19.25 3.2c-.13-.13-.3-.2-.47-.2m-2.41 2.12L9 12.5V15h2.5l7.37-7.38z"></path></svg></span> 约<span class="heti-skip"><span class="heti-spacing"> </span>15265<span class="heti-spacing"> </span></span>个字 <span class="twemoji"><svg viewbox="0 0 640 512" xmlns="http://www.w3.org/2000/svg"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M392.8 1.2c-17-4.9-34.7 5-39.6 22l-128 448c-4.9 17 5 34.7 22 39.6s34.7-5 39.6-22l128-448c4.9-17-5-34.7-22-39.6m80.6 120.1c-12.5 12.5-12.5 32.8 0 45.3l89.3 89.4-89.4 89.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0l112-112c12.5-12.5 12.5-32.8 0-45.3l-112-112c-12.5-12.5-32.8-12.5-45.3 0zm-306.7 0c-12.5-12.5-32.8-12.5-45.3 0l-112 112c-12.5 12.5-12.5 32.8 0 45.3l112 112c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L77.3 256l89.4-89.4c12.5-12.5 12.5-32.8 0-45.3"></path></svg></span> <span>4<span class="heti-spacing"> </span></span>行代码 <span class="twemoji"><svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 20c4.42 0 8-3.58 8-8s-3.58-8-8-8-8 3.58-8 8 3.58 8 8 8m0-18c5.5 0 10 4.5 10 10s-4.5 10-10 10C6.47 22 2 17.5 2 12S6.5 2 12 2m.5 11H11V7h1.5v4.26l3.7-2.13.75 1.3z"></path></svg></span> 预计阅读时间<span class="heti-skip"><span class="heti-spacing"> </span>76<span class="heti-spacing"> </span></span>分钟</p>
</div>
<div class="admonition warning">
<p class="admonition-title">注意</p>
<p>从<span class="heti-skip"><span class="heti-spacing"> </span>"Timestamp-Based Protocol"<span class="heti-spacing"> </span></span>开始的小节都<strong>不在</strong>《数据库系统》课程考试范围内！</p>
</div>
<details class="abstract">
<summary>核心知识</summary>
<blockquote>
<p>核心知识仅包括考点部分</p>
</blockquote>
<ul>
<li>基于锁的协议<ul>
<li>请求锁、独占锁</li>
<li>两阶段锁协议：增长<span class="heti-skip"><span class="heti-spacing"> </span>+<span class="heti-spacing"> </span></span>收缩<ul>
<li>升<span class="heti-skip"><span class="heti-spacing"> </span>/<span class="heti-spacing"> </span></span>降级</li>
<li>实现：锁表</li>
</ul>
</li>
<li>树协议</li>
</ul>
</li>
<li>死锁处理<ul>
<li>阻止</li>
<li>检测<span class="heti-skip"><span class="heti-spacing"> </span>+<span class="heti-spacing"> </span></span>恢复</li>
</ul>
</li>
<li>多粒度锁协议：意向锁</li>
<li>考虑更多操作：插入、删除</li>
<li>幽灵现象</li>
</ul>
</details>
<p>事务的一大性质是<strong>隔离性</strong>(isolation)。但如果多个事务并发执行的话，数据库可能就不再具备隔离性了。因此系统必须控制好并发事务之间的互动，而实现这种控制的一系列机制被称为<strong>并发控制</strong>(concurrency control)。下面将介绍各种并发控制的方案。</p>
<h2 id="lock-based-protocols">Lock-Based Protocols<a class="headerlink" href="#lock-based-protocols" title="Permanent link">⚓︎</a></h2>
<h3 id="locks">Locks<a class="headerlink" href="#locks" title="Permanent link">⚓︎</a></h3>
<p>一种确保隔离性的方法是要求被访问的数据项遵循一种互斥规则：当某个事务访问数据项时，其他事务就不得修改这个数据项。实现这种要求的最常用的方法是仅允许对于数据项有<strong>锁</strong><span>(lock)<span class="heti-spacing"> </span></span>的事务访问该数据项。一般会提供多种锁模式，我们目前只关注这两种：</p>
<ul>
<li><strong>共享</strong>(shared)：若事务<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>获得一个对于数据项<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(Q\)</span><span class="heti-spacing"> </span></span>的<strong>共享锁</strong>(shared-mode lock)（记作<span><span class="heti-spacing"> </span><span class="arithmatex">\(S\)</span></span><heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，那么<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>可以读取<span><span class="heti-spacing"> </span><span class="arithmatex">\(Q\)</span></span>，但不能向<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(Q\)</span><span class="heti-spacing"> </span></span>写入。</li>
<li><strong>独占</strong>(exclusive)：：若事务<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>获得一个对于数据项<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(Q\)</span><span class="heti-spacing"> </span></span>的<strong>独占锁</strong>(exclusive-mode lock)（记作<span><span class="heti-spacing"> </span><span class="arithmatex">\(X\)</span></span><heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，那么<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>可以读取并写入<span><span class="heti-spacing"> </span><span class="arithmatex">\(Q\)</span></span>。</li>
</ul>
<p>当事务访问数据项时，它会向并发控制管理器发起合适的<strong>请求</strong>(request)；只有当并发控制管理器向事务<strong>授予</strong><span>(grant)<span class="heti-spacing"> </span></span>锁时，该事务才能继续后面的操作。而发起请求到继续后面操作的这段时间并不重要，所以我们可以假设<u>事务被给予锁后就立马执行后续操作</u>。</p>
<p>这两种锁模式允许多个事务读取同一个数据项，但也给出了一次仅允许一个事务进行写访问的限制。我们可以用一个<strong>兼容性函数</strong><span>(compatibility function)<span class="heti-spacing"> </span></span>来描述这一特征：假如有两个任意的锁模式<span><span class="heti-spacing"> </span><span class="arithmatex">\(A, B\)</span></span>，如果在数据项<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(Q\)</span><span class="heti-spacing"> </span></span>已经有锁模式<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(B\)</span><span class="heti-spacing"> </span></span>的情况下，事务<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>仍然能够被立即授予对于该数据项的锁模式<span><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span></span>，那么称模式<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span><span class="heti-spacing"> </span></span>和模式<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(B\)</span><span class="heti-spacing"> </span></span>是<strong>兼容的</strong>(compatible)。兼容性函数 <code>comp(A, B)</code> 可以用以下表格描述（值为<span class="heti-skip"><span class="heti-spacing"> </span>true<span class="heti-spacing"> </span></span>表明是兼容的<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>：</p>
<div style="text-align: center">
<img src="images/lec14/11.png" width="50%/"/>
</div>
<p>可以看到，只有共享模式是相互兼容的，而一旦涉及到独占模式就是不兼容的。</p>
<p>接下来定义一些和锁相关的指令：</p>
<ul>
<li><code>lock-S(Q)</code>：向数据项<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(Q\)</span><span class="heti-spacing"> </span></span>发起共享锁请求</li>
<li><code>lock-X(Q)</code>：向数据项<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(Q\)</span><span class="heti-spacing"> </span></span>发起独占锁请求</li>
<li><code>unlock(Q)</code>：解锁数据项<span><span class="heti-spacing"> </span><span class="arithmatex">\(Q\)</span></span><ul>
<li>该指令不一定要放在事务的最后执行</li>
</ul>
</li>
</ul>
<p>要想访问数据项，事务<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>必须先锁住该数据项。如果该数据项已被其他事务锁住的话，并发控制管理器就不会向<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>授予锁，<span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>一直处于<strong>等待</strong>状态，直到所有不兼容的锁都被释放为止。</p>
<p>需要注意的是，只要事务保持对数据项的访问，那么它就必须保持对该数据项的锁。并且即便完成对数据项的最后一次访问时，事务也不能立马解锁，因为这样可能无法确保可串行性。</p>
<p>对于一组并发执行的事务，如果没有事务能够继续执行后续操作的话，那么我们就认为发生了<strong>死锁</strong>(deadlock)，此时必须得回滚其中一个事务，使得其他事务得以继续执行。相比没有用锁导致的不一致状态<span class="heti-skip"><span class="heti-spacing"> </span>(inconsistent states)<span class="heti-spacing"> </span></span>问题，我们可能相对更能忍受死锁带来的后果，因为该问题可通过回滚事务处理，但不一致状态就没法被数据库系统处理。</p>
<details class="example" open="open">
<summary>例子</summary>
<p></p><div style="text-align: center">
<img src="images/lec14/20.png" width="80%/"/>
</div>
</details>
<p>事务的加锁和解锁操作需要遵循一套规则，称为<strong>锁协议</strong>(locking protocol)。稍后会介绍一些仅允许冲突可串行调度的锁协议，不过在此之前先要了解一些术语：令<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(\{T_0, T_1, \dots, T_n\}\)</span><span class="heti-spacing"> </span></span>为一组参与调度<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(S\)</span><span class="heti-spacing"> </span></span>的事务，</p>
<ul>
<li>如果存在数据项<span><span class="heti-spacing"> </span><span class="arithmatex">\(Q\)</span></span>，事务<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>对其有锁模式<span><span class="heti-spacing"> </span><span class="arithmatex">\(A\)</span></span>，随后的事务<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_j\)</span><span class="heti-spacing"> </span></span>对其有锁模式<span><span class="heti-spacing"> </span><span class="arithmatex">\(B\)</span></span>，且<code>comp(A, B)</code><span><span class="heti-spacing"> </span>= false</span>，那么称<span><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span></span> <strong>先于</strong>(precedes) <span class="arithmatex">\(T_j\)</span>，记作<span><span class="heti-spacing"> </span><span class="arithmatex">\(T_i \rightarrow T_j\)</span></span><ul>
<li>指令之间的冲突对应锁模式的不兼容性</li>
</ul>
</li>
<li>若调度<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(S\)</span><span class="heti-spacing"> </span></span>中的事务遵循锁协议中的规则，则<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(S\)</span><span class="heti-spacing"> </span></span>在该锁协议下是<strong>合法的</strong>(legal)</li>
<li>当且仅当所有在锁协议下的合法调度是冲突可串行的时候，我们认为该锁协议确保冲突可串行性</li>
</ul>
<h3 id="granting-of-locks">Granting of Locks<a class="headerlink" href="#granting-of-locks" title="Permanent link">⚓︎</a></h3>
<p>有时可能存在这样的情况：有一个对同一数据项发起共享锁的事务序列，每个事务给予锁后过一会儿便释放该锁，这样的话事务<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>就永远没法获得对该数据项的独占锁，所以<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>就没法进行下去，也就是说<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>处于<strong>饥饿</strong><span>(starve)<span class="heti-spacing"> </span></span>状态。</p>
<p>为避免这种情况，当满足以下条件时，并发控制管理器就可以向事务<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>授予对数据项<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(Q\)</span><span class="heti-spacing"> </span></span>的锁（模式为<span><span class="heti-spacing"> </span><span class="arithmatex">\(M\)</span></span><heti-adjacent class="heti-adjacent-half">）</heti-adjacent>：</p>
<ul>
<li>没有其他事务持有和<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(M\)</span><span class="heti-spacing"> </span></span>冲突的针对<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(Q\)</span><span class="heti-spacing"> </span></span>的锁模式</li>
<li>没有先于<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>发起请求的事务等待在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(Q\)</span><span class="heti-spacing"> </span></span>上加锁</li>
</ul>
<p>这样，事务的加锁请求就不会被后发起的加锁请求阻断。</p>
<h3 id="the-two-phase-locking-protocol">The Two-Phase Locking Protocol<a class="headerlink" href="#the-two-phase-locking-protocol" title="Permanent link">⚓︎</a></h3>
<p>一种确保（冲突）可串行性的协议是<strong>两阶段锁协议</strong>(two-phase locking protocol)，该协议要求每个事务分两个阶段发起加锁和解锁请求：</p>
<ul>
<li><strong>增长阶段</strong>(growing phase)：事务可能会<strong>获得</strong>锁（也有可能要<strong>延后</strong>一段时间再获得锁<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，但一定不能释放任何已有的锁</li>
<li><strong>收缩阶段</strong>(shrinking phase)：事务可能会<strong>释放</strong>锁（也可能对原有锁进行<strong>降级</strong><heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，但一定不能获得任何新的锁</li>
</ul>
<p>因此，某个事务锁的数量随时间的变化如下所示：</p>
<div style="text-align: center">
<img src="images/lec14/12.png" width="70%/"/>
</div>
<p>在调度中，某个事务获取最后一个锁（在增长阶段的末尾）的节点被称为该事务的<strong>锁点</strong>(lock point)。调度中的事务可以按照锁点序排序，而这样的顺序正是可串行的顺序。</p>
<details class="example">
<summary>例子</summary>
<p></p><div style="text-align: center">
<img src="images/lec14/13.png" width="80%/"/>
</div>
</details>
<p>该协议不保证不会出现死锁问题，而且可能会出现<a href="13.html#cascadeless-schedules"><strong>级联回滚</strong></a><span>(cascading rollback)<span class="heti-spacing"> </span></span>的问题。</p>
<details class="example">
<summary>例子</summary>
<p></p><div style="text-align: center">
<img src="images/lec14/14.png" width="50%/"/>
</div>
<p>因为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_1\)</span><span class="heti-spacing"> </span></span>最后是被中止的，所以实际上没对数据做任何改动；但<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_2\)</span><span class="heti-spacing"> </span></span>基于这些改动值进行操作，所以<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_2\)</span><span class="heti-spacing"> </span></span>也要随<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_1\)</span><span class="heti-spacing"> </span></span>中止，那么它之前的操作都属于无用功。</p>
</details>
<p>为避免该问题发生，我们对原来的协议稍作修改，得到<strong>严格两阶段锁协议</strong>(strict two-phase locking protocol)。该协议在原有协议的基础上，要求事务<u>所有的<strong>独占锁</strong>必须被保留，直到该事务被提交为止</u>。相比原来的协议，它能够避免级联回滚的发生，因此实际上被广泛用于数据库系统中。</p>
<p>另一种变体是<strong>强严格两阶段锁协议</strong>(rigorous two-phase locking protocol)，它要求<u>保留所有锁，直至事务被提交</u>。因此在这种协议下，事务可按照提交顺序被串行化。这种协议的实现更加简单粗暴，也能避免级联回滚的发生，但是会降低并发程度。</p>
<p>在强严格两阶段锁协议下，某个事务锁的数量随时间的变化如下所示：</p>
<div style="text-align: center">
<img src="images/lec14/15.png" width="70%/"/>
</div>
<blockquote>
<p>到收缩阶段的最后一下子释放全部的锁。</p>
</blockquote>
<details class="example">
<summary>例子</summary>
<div class="tabbed-set tabbed-alternate" data-tabs="1:3"><input checked="" id="__tabbed_1_1" name="__tabbed_1" type="radio"/><input id="__tabbed_1_2" name="__tabbed_1" type="radio"/><input id="__tabbed_1_3" name="__tabbed_1" type="radio"/><div class="tabbed-labels"><label for="__tabbed_1_1">没有用到两阶段锁协议</label><label for="__tabbed_1_2">两阶段锁协议</label><label for="__tabbed_1_3">强严格两阶段锁协议</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p></p><div style="text-align: center">
<img src="images/lec14/16.png" width="80%/"/>
</div>
</div>
<div class="tabbed-block">
<p></p><div style="text-align: center">
<img src="images/lec14/17.png" width="80%/"/>
</div>
</div>
<div class="tabbed-block">
<p></p><div style="text-align: center">
<img src="images/lec14/18.png" width="80%/"/>
</div>
</div>
</div>
</div>
</details>
<details class="info">
<summary>到目前为止，我们认识到的各种调度</summary>
<p></p><div style="text-align: center">
<img src="images/lec14/19.png" width="60%/"/>
</div>
</details>
<hr/>
<p>为了提高并发程度，我们在基础的两阶段锁协议上增加一种<strong>锁转换</strong><span>(lock conversion)<span class="heti-spacing"> </span></span>机制，它支持：</p>
<ul>
<li><strong>升级</strong>(upgrade)：共享锁<span class="heti-skip"><span class="heti-spacing"> </span>-&gt;<span class="heti-spacing"> </span></span>独占锁，仅发生在<strong>增长</strong>阶段</li>
<li><strong>降级</strong>(downgrade)：独占锁<span class="heti-skip"><span class="heti-spacing"> </span>-&gt;<span class="heti-spacing"> </span></span>共享锁，仅发生在<strong>收缩</strong>阶段</li>
</ul>
<p>需要注意的是，当数据项<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(Q\)</span><span class="heti-spacing"> </span></span>被其他事务以共享模式锁住时，尝试升级对<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(Q\)</span><span class="heti-spacing"> </span></span>的锁的事务会被要求强制等待。</p>
<p>类似基础的两阶段锁协议，带有锁转换的两阶段锁仅生成冲突可串行的调度，并且事务可按锁点被串行化</p>
<hr/>
<p>下面介绍一种简单而常用的加<span class="heti-skip"><span class="heti-spacing"> </span>/<span class="heti-spacing"> </span></span>解锁方案：</p>
<ul>
<li>当事务<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>发起 <code>read(Q)</code> 操作时，系统在该操作后发起 <code>lock-S(Q)</code> 指令</li>
<li>当事务<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>发起 <code>write(Q)</code> 操作时，系统检查<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>是否已经有<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(Q\)</span><span class="heti-spacing"> </span></span>上的共享锁：<ul>
<li>如果有的话，系统在 <code>write(Q)</code> 之后发起 <code>upgrade(Q)</code> 指令</li>
<li>否则系统在 <code>write(Q)</code> 之后发起 <code>lock-X(Q)</code> 指令</li>
</ul>
</li>
<li>在事务提交或中止后，该事务获得的所有锁都会被解锁</li>
</ul>
<details class="example">
<summary>例子</summary>
<div class="tabbed-set tabbed-alternate" data-tabs="2:2"><input checked="" id="__tabbed_2_1" name="__tabbed_2" type="radio"/><input id="__tabbed_2_2" name="__tabbed_2" type="radio"/><div class="tabbed-labels"><label for="__tabbed_2_1">例<span class="heti-skip"><span class="heti-spacing"> </span>1<span class="heti-spacing"> </span></span></label><label for="__tabbed_2_2">例<span><span class="heti-spacing"> </span>2</span></label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<div class="tabbed-set tabbed-alternate" data-tabs="3:2"><input checked="" id="__tabbed_3_1" name="__tabbed_3" type="radio"/><input id="__tabbed_3_2" name="__tabbed_3" type="radio"/><div class="tabbed-labels"><label for="__tabbed_3_1">题目</label><label for="__tabbed_3_2">解答</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p></p><div style="text-align: center">
<img src="images/lec14/54.png" width="80%/"/>
</div>
</div>
<div class="tabbed-block">
<p></p><div style="text-align: center">
<img src="images/lec14/55.png" width="80%/"/>
</div>
</div>
</div>
</div>
</div>
<div class="tabbed-block">
<div class="tabbed-set tabbed-alternate" data-tabs="4:2"><input checked="" id="__tabbed_4_1" name="__tabbed_4" type="radio"/><input id="__tabbed_4_2" name="__tabbed_4" type="radio"/><div class="tabbed-labels"><label for="__tabbed_4_1">题目</label><label for="__tabbed_4_2">参考答案</label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p></p><div style="text-align: center">
<img src="images/lec14/56.png" width="80%/"/>
</div>
</div>
<div class="tabbed-block">
<table>
<thead>
<tr>
<th style="text-align: left;">步骤</th>
<th style="text-align: left;">T1</th>
<th style="text-align: left;">T2</th>
<th style="text-align: left;">T3</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;">1</td>
<td style="text-align: left;"><code>lock(A)</code></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">2</td>
<td style="text-align: left;"><code>read(A)</code></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">3</td>
<td style="text-align: left;"><code>write(A)</code></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">4</td>
<td style="text-align: left;"><code>unlock(A)</code></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">5</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><code>lock(A)</code></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">6</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><code>read(A)</code></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">7</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><code>unlock(A)</code></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">8</td>
<td style="text-align: left;"><code>lock(B)</code></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">9</td>
<td style="text-align: left;"><code>read(B)</code></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">10</td>
<td style="text-align: left;"><code>write(B)</code></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">11</td>
<td style="text-align: left;"><code>unlock(B)</code></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr>
<td style="text-align: left;">12</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><code>lock(B)</code></td>
</tr>
<tr>
<td style="text-align: left;">13</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><code>read(B)</code></td>
</tr>
<tr>
<td style="text-align: left;">14</td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"><code>unlock(B)</code></td>
</tr>
</tbody>
</table>
<p>可以看到，关于这<span class="heti-skip"><span class="heti-spacing"> </span>3<span class="heti-spacing"> </span></span>个事务的优先图中，只有 <code>T1 -&gt; T2</code> 和 <code>T1 -&gt; T3</code> 两条边，因此这个调度是冲突可串行的。</p>
<p>然而，<span>T1<span class="heti-spacing"> </span></span>违背了两阶段锁协议，因为它在释放 <code>A</code> 的锁后又获取对 <code>B</code> 的锁，而在<span class="heti-skip"><span class="heti-spacing"> </span>2PL<span class="heti-spacing"> </span></span>协议中释放锁后就不能再获取新的锁了。因此，冲突可串行的调度不一定遵守<span class="heti-skip"><span class="heti-spacing"> </span>2PL<span class="heti-spacing"> </span></span>协议。</p>
</div>
</div>
</div>
</div>
</div>
</div>
</details>
<h3 id="implementation-of-locking">Implementation of Locking<a class="headerlink" href="#implementation-of-locking" title="Permanent link">⚓︎</a></h3>
<p><strong>锁管理器</strong><span>(lock manager)<span class="heti-spacing"> </span></span>可通过一个接收来自事务信息，并通过发送信息来回应的进程实现。具体来说：</p>
<ul>
<li>将锁授予信息，或者请求事务回滚的信息（当死锁发生时）作为锁请求信息的回应</li>
<li>对于解锁信息仅需承认<span class="heti-skip"><span class="heti-spacing"> </span>(acknowledge)<span class="heti-spacing"> </span></span>即可，但可能要向其他正在等待的事务发送锁授予信息</li>
</ul>
<p>锁管理器使用以下数据结构：</p>
<ul>
<li>对于当前每个被锁住的数据项，维护一个记录链表，每个项为一次请求，遵循请求到达的顺序</li>
<li>
<p>使用哈希表（这里称为<strong>锁表</strong>(lock table)，用到了溢出链<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，在数据项名称上索引，以寻找数据相对应的链表。锁表的示意图如下：</p>
<p></p><div style="text-align: center">
<img src="images/lec14/1.png" width="50%/"/>
</div>
</li>
<li>
<p>锁表还维护了关于事务标识符的索引</p>
</li>
</ul>
<p>锁管理器进程按以下方式发起请求：</p>
<ul>
<li>当锁请求信息到达时，如果数据项对应的链表存在的话，那么将记录添加在链表末尾；否则创建一个新的，包含该请求记录的链表。<ul>
<li>当数据项没有被加锁时，锁管理器就会授予锁请求；但如果加锁的话，仅当请求的锁和当前的锁兼容时，锁管理器才会授予请求，否则该请求必须等待。</li>
</ul>
</li>
<li>当收到解锁信息时，锁管理器删除对应该事务的链表中的数据项记录。然后它会测试紧随其后的记录（如果有的话<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，以查看该请求现在是否可以授予；如果可以，锁管理器授予该请求。之后按相同方式继续处理后续记录，以此类推。</li>
<li>如果事务中止，那么锁管理器删除由该事务发起的任何正在等待的请求。一旦数据库系统采取合适的行动来撤销事务时，锁管理器将释放被中止事务保留的所有锁。</li>
</ul>
<p>这种方式能够避免事务出现饥饿的问题。</p>
<h3 id="graph-based-protocols">Graph-Based Protocols<a class="headerlink" href="#graph-based-protocols" title="Permanent link">⚓︎</a></h3>
<p>除了两阶段协议外，还有其他类型的协议，但它们就需要一些额外的信息，这些信息可以用各种模型描述。其中最简单的模型要求我们预先知道数据项被访问的顺序。要提前知道这样的信息，需要为所有数据项<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(D = \{d_1, d_2, \dots, d_n\}\)</span><span class="heti-spacing"> </span></span>的<a href="../../math/dm/9.html#partial-orderings">偏序</a><span><span class="heti-spacing"> </span>(paritial order) <span class="arithmatex">\(\rightarrow\)</span></span>。如果<span><span class="heti-spacing"> </span><span class="arithmatex">\(d_i \rightarrow d_j\)</span></span>，那么任何访问<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(d_i, d_j\)</span><span class="heti-spacing"> </span></span>的事务必须先访问<span><span class="heti-spacing"> </span><span class="arithmatex">\(d_i\)</span></span>，后访问<span><span class="heti-spacing"> </span><span class="arithmatex">\(d_j\)</span></span>。这种偏序可以通过数据的逻辑组织或物理组织实现，或者仅用于并发控制目的。</p>
<p>偏序表明我们可以将<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(D\)</span><span class="heti-spacing"> </span></span>看作一个有向无环图，我们称其为<strong>数据库图</strong>(database graph)。为了简洁，我们将这种图限制在<a href="../../math/dm/11.html#rooted-trees">有根树</a><span class="heti-skip"><span class="heti-spacing"> </span>(rooted tree)<span class="heti-spacing"> </span></span>的形式；对应的协议称为<strong>树协议</strong>(tree protocol)。该协议唯一用到的加锁指令是 <code>lock-X</code>。每个事务<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>至多对数据项加锁一次，且必须遵循以下规则：</p>
<ul>
<li><span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>的第一个锁可以作用在任一数据项上</li>
<li>随后，仅当数据项<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(Q\)</span><span class="heti-spacing"> </span></span>的父亲被<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>锁住时，<span><span class="arithmatex">\(Q\)</span><span class="heti-spacing"> </span></span>才能被<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>锁住</li>
<li>可以在任何时间解锁数据项</li>
<li>由<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>加锁或解锁的数据项不能再次被<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>加锁</li>
</ul>
<p>所有在树协议下合法的调度都是<strong>冲突可串行的</strong>。</p>
<p>下图展示的是树结构的数据库图：</p>
<div style="text-align: center">
<img src="images/lec14/2.png" width="50%/"/>
</div>
<p>下面的四个事务就是针对图中的数据项进行操作的（仅展示加锁和解锁指令<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>：</p>
<div style="text-align: center">
<img src="images/lec14/3.png" width="70%/"/>
</div>
<p>一种可行的调度如下：</p>
<div style="text-align: center">
<img src="images/lec14/4.png" width="50%/"/>
</div>
<ul>
<li>可以发现，在执行过程中，<span><span class="arithmatex">\(T_{10}\)</span><span class="heti-spacing"> </span></span>在两个不相交的子树上维护锁</li>
<li>该调度是冲突可串行的，但无法确保可恢复性和无级联性</li>
</ul>
<p>为了让树协议具备这两个性质，可以在其基础上稍加修改：不允许释放独占锁，直到事务结束为止。但这样做会降低并发程度。另一种提升并发程度，但只能保证可恢复性的办法是：</p>
<ul>
<li>对于每个存在的未提交写入操作的数据项，我们会记录是哪个事务最后一次对该数据项进行了写操作</li>
<li>每当一个事务<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>读取某个未被提交的数据项时，我们就会记录下<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>对最后一次写入该数据项的事务的<strong>提交依赖关系</strong>(commit dependency)</li>
<li>此后，在所有被<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>所依赖的事务完成提交之前，<span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>都不允许进行提交</li>
<li>如果其中任何一个相关事务发生中止，那么<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>也必须随之被中止</li>
</ul>
<p>树协议的优点是它能确保不会发生死锁，那么也就无需回滚；另一个优点是能够更早执行解锁操作，因而缩短等待时间，提升并发程度。但它的缺点在于加锁开销的提升，并且可能会带来额外的等待时间，以及潜在的并发程度下降问题。</p>
<p>事实上，存在遵循两阶段锁协议，但不遵循树协议的调度，反之亦然。</p>
<h2 id="deadlock-handling">Deadlock Handling<a class="headerlink" href="#deadlock-handling" title="Permanent link">⚓︎</a></h2>
<p>假如存在一组等待事务<span><span class="heti-spacing"> </span><span class="arithmatex">\(\{T_0, T_1, \dots, T_n\}\)</span></span>，使得<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_0\)</span><span class="heti-spacing"> </span></span>等待<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_1\)</span><span class="heti-spacing"> </span></span>加锁的数据，<span><span class="arithmatex">\(T_1\)</span><span class="heti-spacing"> </span></span>等待<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_2\)</span><span class="heti-spacing"> </span></span>加锁的数据，...，<span><span class="arithmatex">\(T_{n-1}\)</span><span class="heti-spacing"> </span></span>等待<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_n\)</span><span class="heti-spacing"> </span></span>加锁的数据，<span><span class="arithmatex">\(T_n\)</span><span class="heti-spacing"> </span></span>等待<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_0\)</span><span class="heti-spacing"> </span></span>加锁的数据。那么我们认为这些事务进入<strong>死锁</strong><span>(deadlock)<span class="heti-spacing"> </span></span>状态。</p>
<p>下面介绍两种处理死锁问题的主要方法：</p>
<ul>
<li><strong>死锁阻止</strong>(prevention)：确保系统不会进入死锁状态</li>
<li><strong>死锁检测和恢复</strong>(detection and recovery)：允许系统进入死锁状态，但之后尝试从死锁状态恢复</li>
</ul>
<p>如果死锁会带来相对较高的损失，那么可以采用死锁阻止；否则的话可以采用更加高效的死锁检测和恢复。</p>
<h3 id="deadlock-prevention">Deadlock Prevention<a class="headerlink" href="#deadlock-prevention" title="Permanent link">⚓︎</a></h3>
<p>有以下阻止死锁的方法：</p>
<ul>
<li>
<p>通过为锁请求排序或要求一次性获取所有锁，确保没有循环等待的情况出现</p>
<ul>
<li>最简单的方案是要求每个事务在开始执行前锁住它要用到的所有数据项。但这种方法的缺点是难以预测需要被加锁的数据项，以及数据项的低利用率</li>
<li>强制为数据项排序，并要求事务仅对于顺序一致的序列锁定数据项</li>
<li>上述方法的一种变体是采用数据项的全序和两阶段锁。一旦事务锁住特定数据项后，它就不能对顺序中先于该数据项的数据项请求加锁。该方法最大的好处是易于实现</li>
</ul>
</li>
<li>
<p>类似死锁恢复，当事务的等待可能会导致死锁时，回滚该事务而不是继续等待</p>
<ul>
<li>具体通过<strong>抢夺</strong><span>(preemption)<span class="heti-spacing"> </span></span>来实现：当事务<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_j\)</span><span class="heti-spacing"> </span></span>向已被<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>加锁的数据项请求锁时，通过回滚<span><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span></span>，将<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>的锁抢走，然后向<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_j\)</span><span class="heti-spacing"> </span></span>授予锁</li>
<li>
<p>为了控制抢占操作，我们需要为每个刚开始的事务赋予<strong>时间戳</strong>(timestamp)（基于计数器或系统时钟<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>。系统仅用时间戳来决定事务是否需要等待或回滚。如果事务要回滚，那么在重启该事务时要保留<strong>旧的</strong>时间戳。下面给出两种使用时间戳的不同方案：</p>
<ul>
<li><strong>等待<span class="heti-skip"><span class="heti-spacing"> </span>-<span class="heti-spacing"> </span></span>死亡</strong>(wait-die)（非抢夺技术<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>：当事务<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>向已被<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_j\)</span><span class="heti-spacing"> </span></span>加锁的数据项请求锁时，仅当<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>的时间戳小于<span><span class="heti-spacing"> </span><span class="arithmatex">\(T_j\)</span></span>（<span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>比<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_j\)</span><span class="heti-spacing"> </span></span>更老）的时候，<span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>可以等待，否则需要回滚<span><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span></span></li>
<li><strong>受伤<span class="heti-skip"><span class="heti-spacing"> </span>-<span class="heti-spacing"> </span></span>等待</strong>(wound-wait)（抢夺技术<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>：当事务<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>向已被<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_j\)</span><span class="heti-spacing"> </span></span>加锁的数据项请求锁时，仅当<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>的时间戳大于<span><span class="heti-spacing"> </span><span class="arithmatex">\(T_j\)</span></span>（<span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>比<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_j\)</span><span class="heti-spacing"> </span></span>更新）的时候，<span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>可以等待，否则需要回滚<span><span class="heti-spacing"> </span><span class="arithmatex">\(T_j\)</span></span>（<span><span class="arithmatex">\(T_j\)</span><span class="heti-spacing"> </span></span>被<span><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span></span> “击伤<span><span class="heti-spacing"> </span>(wound)</span>”）</li>
</ul>
<p></p><div style="text-align: center">
<img src="images/lec14/22.png" width="80%/"/>
</div>
<p>这两种方法的共同问题是会带来不必要的回滚。</p>
</li>
</ul>
</li>
<li>
<p>基于<strong>锁超时</strong><span>(lock timeout)<span class="heti-spacing"> </span></span>的方法：请求锁的事务至多等待一定量的时间。如果在这段时间内还没向事务授予锁，那么该事务被认为是超时了，需要回滚并重新开始。</p>
<ul>
<li>该方法易于实现，且当事务内容不多，并且长时间等待会可能会导致死锁时较为有效</li>
<li>但我们很难决定多久被认为是超时的：等待太久会带来不必要的延迟，等待太少会带来不必要的回滚，从而导致资源浪费。并且该方法可能会让事务进入饥饿状态。因此该方法应用有限。</li>
</ul>
</li>
</ul>
<h3 id="deadlock-detection-and-recovery">Deadlock Detection and Recovery<a class="headerlink" href="#deadlock-detection-and-recovery" title="Permanent link">⚓︎</a></h3>
<p>如果系统采用的协议无法确保死锁不出现，那么就必须得采取死锁检测和恢复方案了。具体来说，系统需要：</p>
<ul>
<li>维护关于当前分配给事务的数据项的信息，以及任何未完成的数据项请求</li>
<li>提供一种检测算法，它采用上述信息，以确定系统是否进入死锁状态<ul>
<li>我们还得考虑何时调用该算法——这取决于两个因素：死锁发生的频率，以及受死锁影响的事务数量</li>
</ul>
</li>
<li>当检测算法确定死锁存在时，要从死锁中恢复过来，具体分为以下三步：<ul>
<li><strong>受害者的选择</strong>：对于给定的一组事务，我们必须确定要回滚哪个事务（被称为<strong>受害者</strong>(victim)）以打破死锁。一般我们会选择回滚成本最小的事务，但这个最小成本很难准确定义。回滚的成本需要考虑以下因素：<ul>
<li>事务计算所需的时间</li>
<li>事务使用的数据项的个数</li>
<li>还需要多少数据项来完成事务</li>
<li>回滚包含的事务数</li>
</ul>
</li>
<li><strong>回滚</strong>：<ul>
<li>最简单的方案是<strong>完全回滚</strong>(total rollback)：中止事务并重新启动</li>
<li>但相对而言，<strong>部分回滚</strong><span>(partial rollback)<span class="heti-spacing"> </span></span>效率更高，仅回滚能够打破死锁的事务。但该方法要求系统维护额外的有关所有正在运行的事务状态的信息，具体来说事务执行的锁请求<span class="heti-skip"><span class="heti-spacing"> </span>/<span class="heti-spacing"> </span></span>授予，以及更新序列需要被记录下来。</li>
</ul>
</li>
<li><strong>饥饿</strong>：有可能出现总是将相同事务作为“受害者”的情况，这样的话该事务就永远没法完成任务，因而存在饥饿问题。所以我们必须确保事务被选为“受害者”的次数不超过指定次数。最常见的解决方案是在成本因子中包含回滚次数。</li>
</ul>
</li>
</ul>
<hr/>
<p>死锁的情况可用一种称为<strong>等待图</strong><span>(wait-for graph)<span class="heti-spacing"> </span></span>的有向图<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(G = (V, E)\)</span><span class="heti-spacing"> </span></span>表示，</p>
<ul>
<li>其中顶点表示系统中的事务，边表示一个有序对<span><span class="heti-spacing"> </span><span class="arithmatex">\(T_i \rightarrow T_j\)</span></span>，表明事务<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>正在等待事务<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_j\)</span><span class="heti-spacing"> </span></span>释放其所需数据项的锁。</li>
<li>当事务<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>向正被<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_j\)</span><span class="heti-spacing"> </span></span>加锁的数据项发起加锁请求时，将<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i \rightarrow T_j\)</span><span class="heti-spacing"> </span></span>插入到图中；当<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_j\)</span><span class="heti-spacing"> </span></span>不再持有该数据项的锁时，将这条边删掉。</li>
<li>当且仅当等待图中存在<strong>环</strong>时，系统中就出现了<strong>死锁</strong>。为了检测死锁，系统需要维护等待图，周期性地调用在图中搜索环的算法</li>
</ul>
<details class="example">
<summary>例子</summary>
<div class="tabbed-set tabbed-alternate" data-tabs="5:2"><input checked="" id="__tabbed_5_1" name="__tabbed_5" type="radio"/><input id="__tabbed_5_2" name="__tabbed_5" type="radio"/><div class="tabbed-labels"><label for="__tabbed_5_1">例<span class="heti-skip"><span class="heti-spacing"> </span>1<span class="heti-spacing"> </span></span></label><label for="__tabbed_5_2">例<span><span class="heti-spacing"> </span>2</span></label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p></p><div style="text-align: center">
<img src="images/lec14/21.png" width="80%/"/>
</div>
</div>
<div class="tabbed-block">
<p>C</p>
<p>很容易误选<span><span class="heti-spacing"> </span>D</span>，问题出在：虽然看起来<span class="heti-skip"><span class="heti-spacing"> </span>T3<span class="heti-spacing"> </span></span>要等待<span class="heti-skip"><span class="heti-spacing"> </span>T1<span class="heti-spacing"> </span></span>释放<span class="heti-skip"><span class="heti-spacing"> </span>B<span class="heti-spacing"> </span></span>的锁，但是<span class="heti-skip"><span class="heti-spacing"> </span>B<span class="heti-spacing"> </span></span>的锁还在<span class="heti-skip"><span class="heti-spacing"> </span>T2<span class="heti-spacing"> </span></span>那里（注意题目最后一句话<heti-adjacent class="heti-adjacent-quarter">：</heti-adjacent>“At this time, no granted lock is released.”<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，所以<span class="heti-skip"><span class="heti-spacing"> </span>T3<span class="heti-spacing"> </span></span>实际上等的是<span class="heti-skip"><span class="heti-spacing"> </span>T2<span class="heti-spacing"> </span></span>的锁（<del>笔者一开始做的时候没想到这一层</del><heti-adjacent class="heti-adjacent-half">）</heti-adjacent>。</p>
</div>
</div>
</div>
</details>
<h2 id="multiple-granulartiy">Multiple Granulartiy<a class="headerlink" href="#multiple-granulartiy" title="Permanent link">⚓︎</a></h2>
<p>在前面介绍的并发控制方案中，我们都是将单个的数据项作为同步执行单元。但有时将多个数据项放在同一个组，将其视为同一个同步单元可能会带来更好的效果。例如：</p>
<ul>
<li>假设一个事务<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>需要访问整个关系表，而采用的锁协议是对元组加锁，那么<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>必须锁定该关系表中的每一个元组。显然，获取大量此类锁非常耗时；更糟糕的是，锁表可能会变得极其庞大以致无法容纳在内存中。</li>
<li>若<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>能通过单一锁请求直接锁定整个关系表则更为高效。反之，若事务<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_j\)</span><span class="heti-spacing"> </span></span>仅需访问少量元组时，就不应强制其锁定整张关系表，否则将丧失并发性优势。</li>
</ul>
<p>因此，我们需要一种机制，能够让系统定义多个层级的<strong>粒度</strong>(granularity)：也就是说让数据项的大小可变；并定义一种数据粒度层级，其中小粒度会被包含在大粒度里面。这样的层级可以用一棵树表示，如下所示：</p>
<div style="text-align: center">
<img src="images/lec14/7.png" width="70%/"/>
</div>
<ul>
<li>不同于树协议中独立的节点，多粒度树的非叶子节点表示的是和它后代关联的数据</li>
<li>树中最高层的节点表示整个<strong>数据库</strong></li>
<li>第二层节点表示的是<strong>区域</strong>(areas)，可以看到数据库由多个区域构成</li>
<li>每个区域内有多份<strong>文件</strong>(files)，反映在树上就是文件节点作为区域节点的后代；注意文件不得横跨多个区域</li>
<li>每个文件下有多条<strong>记录</strong>(records)，作为文件节点的后代；类似地，记录不得存在于多个文件内</li>
<li>每个节点可以被单独加锁。当事务锁住某个节点时（无论用共享锁还是独占锁<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，事务也会<strong>隐式</strong>地对其全部后代加锁</li>
<li>假如事务<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_j\)</span><span class="heti-spacing"> </span></span>要对记录<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(r_b\)</span><span class="heti-spacing"> </span></span>加锁，那么该事务要从这棵树的根节点开始遍历。如果发现路径上有节点采用了和<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_j\)</span><span class="heti-spacing"> </span></span>锁不兼容的锁，那么<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_j\)</span><span class="heti-spacing"> </span></span>的加锁操作就要被延后了</li>
</ul>
<details class="info">
<summary>另一种粒度层级（个人感觉更通顺）</summary>
<p></p><div style="text-align: center">
<img src="images/lec14/23.png" width="80%/"/>
</div>
</details>
<p>假如事务<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_k\)</span><span class="heti-spacing"> </span></span>要对整个数据库加锁，但由于另一个事务<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>已经对某个子树加锁，因此在加锁前需要确定是否能够加锁。遍历整棵树固然能够解决这一问题，但这种简单粗暴的方法效率太低，我们无法接受。因此，我们采用一种更高效的做法，称为<strong>意向锁模式</strong>(intention lock modes)：如果一个节点被加上意向锁，那么它的后代也会被<strong>显式</strong>地加锁。因此事务就无需遍历整棵树——如果想要锁住节点<span><span class="heti-spacing"> </span><span class="arithmatex">\(Q\)</span></span>，那么在此之前只需遍历从根节点到<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(Q\)</span><span class="heti-spacing"> </span></span>这条路径即可。</p>
<p>意向锁可以和共享锁关联，也可以和独占锁关联，因此我们得到更多的锁模式：</p>
<ul>
<li><strong>意向<span class="heti-skip"><span class="heti-spacing"> </span>-<span class="heti-spacing"> </span></span>共享模式</strong>(intention-shared(IS) mode)：对节点后代进行显式加上共享锁</li>
<li><strong>意向<span class="heti-skip"><span class="heti-spacing"> </span>-<span class="heti-spacing"> </span></span>独占模式</strong>(intention-exclusion(IX) mode)：对节点后代进行显式加上共享锁或独占锁</li>
<li><strong>共享<span class="heti-skip"><span class="heti-spacing"> </span>-<span class="heti-spacing"> </span></span>意向<span class="heti-skip"><span class="heti-spacing"> </span>-<span class="heti-spacing"> </span></span>独占模式</strong>(shared and intention-exclusive(SIX) mode)：该节点下子树的根节点被显式加上共享锁，而更低层的节点被显式加上独占锁</li>
</ul>
<p>算上一般的共享锁和独占锁，我们可以得到以下兼容函数：</p>
<div style="text-align: center">
<img src="images/lec14/24.png" width="60%/"/>
</div>
<p>在多粒度概念的基础上，我们可以得到<strong>多粒度锁协议</strong>(multiple-granularity locking protocol)。该协议利用上述<span class="heti-skip"><span class="heti-spacing"> </span>5<span class="heti-spacing"> </span></span>种锁来确保可串行性。它要求事务<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>在对某个节点<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(Q\)</span><span class="heti-spacing"> </span></span>加锁前必须遵循以下规则：</p>
<ul>
<li><span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>必须遵循上面给出的兼容函数</li>
<li><span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>必须先对树的根节点加锁（可用任意锁模式）</li>
<li>仅当<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>已经对<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(Q\)</span><span class="heti-spacing"> </span></span>的父亲节点加上<span class="heti-skip"><span class="heti-spacing"> </span>IX<span class="heti-spacing"> </span></span>或<span class="heti-skip"><span class="heti-spacing"> </span>IS<span class="heti-spacing"> </span></span>锁时，<span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>可对<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(Q\)</span><span class="heti-spacing"> </span></span>加上<span class="heti-skip"><span class="heti-spacing"> </span>S<span class="heti-spacing"> </span></span>或<span class="heti-skip"><span class="heti-spacing"> </span>IS<span class="heti-spacing"> </span></span>锁</li>
<li>仅当<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>已经对<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(Q\)</span><span class="heti-spacing"> </span></span>的父亲节点加上<span class="heti-skip"><span class="heti-spacing"> </span>IX<span class="heti-spacing"> </span></span>或<span class="heti-skip"><span class="heti-spacing"> </span>SIX<span class="heti-spacing"> </span></span>锁时，<span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>可对<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(Q\)</span><span class="heti-spacing"> </span></span>加上<span class="heti-skip"><span class="heti-spacing"> </span>X, SIX<span class="heti-spacing"> </span></span>或<span class="heti-skip"><span class="heti-spacing"> </span>IX<span class="heti-spacing"> </span></span>锁</li>
<li>仅当<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>在先前没有解锁过时，<span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>才可以对节点加锁</li>
<li>仅当<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>没有对<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(Q\)</span><span class="heti-spacing"> </span></span>的任何孩子加锁时，<span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>才可以解锁<span><span class="heti-spacing"> </span><span class="arithmatex">\(Q\)</span></span></li>
</ul>
<p>可以看到，多粒度锁协议要求获取锁的顺序是<strong>自顶向下</strong>(top-down/root-to-leaf)，而释放锁的顺序是<strong>自底向上</strong>(bottom-up/leaf-to-root)。</p>
<p>多粒度锁协议无法保证不发生死锁现象。</p>
<p>该协议的好处是增强并发程度，并减少了锁开销。它尤其适用于以下场景：仅访问部分数据项的短事务，以及从单个或多个文件中生成报告的长事务。</p>
<details class="example">
<summary>例子</summary>
<p></p><div style="text-align: center">
<img src="images/lec14/25.png" width="70%/"/>
</div>
<p></p><div style="text-align: center">
<img src="images/lec14/26.png" width="80%/"/>
</div>
</details>
<p><span>SQL<span class="heti-spacing"> </span></span>查询需要的锁数量通常可通过关系扫描操作的结果来估算。例如，关系扫描会在关系级别获取一个锁，而索引扫描则可能在关系级别获得意向锁，并在元组级别施加常规锁。若某事务获取了大量元组锁，可能导致锁表过度填充。针对这种情况，锁管理器可执行<strong>锁升级</strong><span>(lock escalation)<span class="heti-spacing"> </span></span>机制——用单个更高层级的锁替代多个低层级锁；在上述示例中，单个关系级锁即可取代大量元组级锁定。</p>
<h2 id="operations">Operations<a class="headerlink" href="#operations" title="Permanent link">⚓︎</a></h2>
<p>到目前为止，我们只关注了 <code>read</code> 和 <code>write</code> 操作。现在我们考虑更多的操作：</p>
<ul>
<li><code>delete(Q)</code>：从数据库中删除数据项<span><span class="heti-spacing"> </span><span class="arithmatex">\(Q\)</span></span></li>
<li><code>insert(Q)</code>：向数据库插入一个新数据项<span><span class="heti-spacing"> </span><span class="arithmatex">\(Q\)</span></span>，并为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(Q\)</span><span class="heti-spacing"> </span></span>赋予一个初始值</li>
</ul>
<h3 id="deletion">Deletion<a class="headerlink" href="#deletion" title="Permanent link">⚓︎</a></h3>
<p>为了理解 <code>delete</code> 指令是如何影响并发控制的，我们必须确定 <code>delete</code> 何时和其他指令发生冲突。令<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(I_i, I_j\)</span><span class="heti-spacing"> </span></span>分别为事务<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i, T_j\)</span><span class="heti-spacing"> </span></span>的指令，而这两个事务以连续顺序出现在调度<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(S\)</span><span class="heti-spacing"> </span></span>中；并且令<span><span class="heti-spacing"> </span><span class="arithmatex">\(I_i\)</span> =</span> <code>delete(Q)</code>。接下来就<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(I_j\)</span><span class="heti-spacing"> </span></span>来分类讨论：</p>
<ul>
<li><span class="arithmatex">\(I_j\)</span> = <code>read(Q)</code>：<span><span class="arithmatex">\(I_i, I_j\)</span><span class="heti-spacing"> </span></span>冲突。如果<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(I_i\)</span><span class="heti-spacing"> </span></span>出现在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(I_j\)</span><span class="heti-spacing"> </span></span>前面，<span><span class="arithmatex">\(T_j\)</span><span class="heti-spacing"> </span></span>就会有逻辑错误；如果<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(I_j\)</span><span class="heti-spacing"> </span></span>出现在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(I_i\)</span><span class="heti-spacing"> </span></span>前面，<span><span class="arithmatex">\(T_j\)</span><span class="heti-spacing"> </span></span>就能成功执行 <code>read</code> 操作。</li>
<li><span class="arithmatex">\(I_j\)</span> = <code>write(Q)</code>：<span><span class="arithmatex">\(I_i, I_j\)</span><span class="heti-spacing"> </span></span>冲突。如果<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(I_i\)</span><span class="heti-spacing"> </span></span>出现在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(I_j\)</span><span class="heti-spacing"> </span></span>前面，<span><span class="arithmatex">\(T_j\)</span><span class="heti-spacing"> </span></span>就会有逻辑错误；如果<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(I_j\)</span><span class="heti-spacing"> </span></span>出现在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(I_i\)</span><span class="heti-spacing"> </span></span>前面，<span><span class="arithmatex">\(T_j\)</span><span class="heti-spacing"> </span></span>就能成功执行 <code>write</code> 操作。</li>
<li><span class="arithmatex">\(I_j\)</span> = <code>delete(Q)</code>：<span><span class="arithmatex">\(I_i, I_j\)</span><span class="heti-spacing"> </span></span>冲突。如果<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(I_i\)</span><span class="heti-spacing"> </span></span>出现在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(I_j\)</span><span class="heti-spacing"> </span></span>前面，<span><span class="arithmatex">\(T_j\)</span><span class="heti-spacing"> </span></span>就会有逻辑错误；如果<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(I_j\)</span><span class="heti-spacing"> </span></span>出现在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(I_i\)</span><span class="heti-spacing"> </span></span>前面，<span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>就会有逻辑错误。</li>
<li><span class="arithmatex">\(I_j\)</span> = <code>insert(Q)</code>：<span><span class="arithmatex">\(I_i, I_j\)</span><span class="heti-spacing"> </span></span>冲突。假设数据项<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(Q\)</span><span class="heti-spacing"> </span></span>在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(I_i, I_j\)</span><span class="heti-spacing"> </span></span>执行前不存在。那么如果<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(I_i\)</span><span class="heti-spacing"> </span></span>出现在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(I_j\)</span><span class="heti-spacing"> </span></span>前面，<span><span class="arithmatex">\(T_j\)</span><span class="heti-spacing"> </span></span>就会有逻辑错误；如果<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(I_j\)</span><span class="heti-spacing"> </span></span>出现在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(I_i\)</span><span class="heti-spacing"> </span></span>前面，就没有有逻辑错误。同样地，如果数据项<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(Q\)</span><span class="heti-spacing"> </span></span>在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(I_i, I_j\)</span><span class="heti-spacing"> </span></span>执行前存在的话，当<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(I_j\)</span><span class="heti-spacing"> </span></span>出现在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(I_i\)</span><span class="heti-spacing"> </span></span>前面时就会发生逻辑错误，反之则不会。</li>
</ul>
<p>下面总结一下：</p>
<ul>
<li>在<a href="#the-two-phase-locking-protocol">两阶段锁协议</a>中，在删除某个数据项前，需要为该数据项加上独占锁</li>
<li>在<a href="#timestamp-based-protocols">时间戳顺序协议</a>中，必须执行类似检验 <code>write</code> 的测试。假设<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>发起 <code>delete(Q)</code> 指令：<ul>
<li>若<span><span class="heti-spacing"> </span>TS(<span class="arithmatex">\(T_i\)</span>) &lt; R-timestamp(<span class="arithmatex">\(Q\)</span>)</span>，那么<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(Q\)</span><span class="heti-spacing"> </span></span>的值已经被另一个满足<span class="heti-skip"><span class="heti-spacing"> </span>TS(<span class="arithmatex">\(T_j\)</span>) &gt; TS(<span class="arithmatex">\(T_i\)</span>)<span class="heti-spacing"> </span></span>的事务<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_j\)</span><span class="heti-spacing"> </span></span>读取。因此 <code>delete</code> 操作被拒绝，<span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>被回滚</li>
<li>若<span><span class="heti-spacing"> </span>TS(<span class="arithmatex">\(T_i\)</span>) &lt; W-timestamp(<span class="arithmatex">\(Q\)</span>)</span>，那么另一个满足<span class="heti-skip"><span class="heti-spacing"> </span>TS(<span class="arithmatex">\(T_j\)</span>) &gt; TS(<span class="arithmatex">\(T_i\)</span>)<span class="heti-spacing"> </span></span>的事务<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_j\)</span><span class="heti-spacing"> </span></span>已经写入<span><span class="heti-spacing"> </span><span class="arithmatex">\(Q\)</span></span>。因此 <code>delete</code> 操作被拒绝，<span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>被回滚</li>
<li>否则执行 <code>delete</code> 操作</li>
</ul>
</li>
</ul>
<h3 id="insertion">Insertion<a class="headerlink" href="#insertion" title="Permanent link">⚓︎</a></h3>
<p>前面已经说过，<code>insert(Q)</code> 操作和 <code>delete(Q)</code> 操作冲突；此外，<code>insert(Q)</code> 也和 <code>read(Q)</code> 和 <code>write(Q)</code> 冲突，因为 <code>read</code> 和 <code>write</code> 没法执行于一个不存在的数据项上。</p>
<ul>
<li>在两阶段锁协议中，如果<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>执行 <code>insert(Q)</code> 操作，那么<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>要为新创建的数据项<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(Q\)</span><span class="heti-spacing"> </span></span>加上独占锁</li>
<li>在时间戳顺序协议中，如果<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>执行 <code>insert(Q)</code> 操作，那么<span class="heti-skip"><span class="heti-spacing"> </span>R-timestamp(Q)<span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span>W-timestamp(Q)<span class="heti-spacing"> </span></span>被设为<span><span class="heti-spacing"> </span>TS(<span class="arithmatex">\(T_i\)</span>)</span></li>
</ul>
<h3 id="predicate-reads-and-the-phantom-phenomenon">Predicate Reads and the Phantom Phenomenon<a class="headerlink" href="#predicate-reads-and-the-phantom-phenomenon" title="Permanent link">⚓︎</a></h3>
<p><strong>幽灵现象</strong>(phantom phenomenon)（或称作<strong>幻读</strong><heti-adjacent class="heti-adjacent-half">）</heti-adjacent>：当一个事务在执行过程中，多次执行相同的查询（<strong>谓词读取</strong>(predicate read)<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，但由于其他并发事务插入或删除了符合查询条件的新记录，导致后一次查询的结果集与前一次查询的结果集不同，就好像出现了“幽灵”一样，这些新出现的或消失的记录就是“幽灵”。</p>
<div style="text-align: center">
<img src="images/lec14/34.png" width="80%/"/>
</div>
<p>有以下几种解决方法：</p>
<ul>
<li><strong>再执行扫描</strong>(re-execute scan)：<span>DBMS<span class="heti-spacing"> </span></span>会记录该事务执行的所有查询的 <code>WHERE</code> 子句；事务在提交时可能会重新执行查询以检查结果是否不同，能够发现由于新增或删除的记录而遗漏的变更，以确保结果保持一致性。</li>
<li>
<p><strong>谓词锁</strong>(predicate locking)：根据查询谓词获取锁，确保满足谓词的任何数据不会被其他事务修改，但这种方法用的很少。</p>
<p></p><div style="text-align: center">
<img src="images/lec14/35.png" width="80%/"/>
</div>
</li>
<li>
<p><strong>索引锁</strong>(index-locking)：</p>
<ul>
<li>避免对整个索引加锁：任何向关系插入元组的事务必须向对应索引插入信息；通过在索引上施加锁协议来消除幽灵现象</li>
<li>
<p><strong>索引锁协议</strong><span>(index-locking protocol)<span class="heti-spacing"> </span></span>的具体操作为：</p>
<ul>
<li>每个关系必须至少有一个索引</li>
<li>仅当通过关系中的一个或多个索引找到指定元组时，事务<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>才能访问这些元组。在索引锁协议中，关系扫描被视为对索引中所有叶子节点进行扫描</li>
<li>执行查找的事务<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>必须对要访问的索引中的所有节点加上共享锁</li>
<li>事务<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>在对关系<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(r\)</span><span class="heti-spacing"> </span></span>中的元组<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(t_i\)</span><span class="heti-spacing"> </span></span>执行插入、删除或更新操作时，必须同时更新<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(r\)</span><span class="heti-spacing"> </span></span>上的所有索引。该事务需要获取所有受插入、删除或更新操作影响的索引叶子节点的独占锁。具体而言：<ul>
<li>插入<span class="heti-skip"><span class="heti-spacing"> </span>/<span class="heti-spacing"> </span></span>删除：受影响的叶子节点是指那些（在插入后）将包含该元组搜索键值或（在删除前）曾包含该元组搜索键值的节点</li>
<li>更新：受影响的叶子节点包括两类——修改前含有旧搜索键值的节点，以及修改后将包含新搜索键值的节点</li>
</ul>
</li>
<li>对于元组，锁的获取和平常一样</li>
<li>必须遵守两阶段锁协议的规则</li>
</ul>
</li>
<li>
<p>索引锁的具体方案有：</p>
<ul>
<li>
<p><strong>键值锁</strong>(key-value locks)：索引中单个键值对的锁定，包括不存在值的虚拟键</p>
<p></p><div style="text-align: center">
<img src="images/lec14/36.png" width="60%/"/>
</div>
</li>
<li>
<p><strong>间隙锁</strong>(gap locks)：键值对之后的间隙上的锁，防止在这些间隙中插入</p>
<p></p><div style="text-align: center">
<img src="images/lec14/37.png" width="60%/"/>
</div>
</li>
<li>
<p><strong>键<span class="heti-skip"><span class="heti-spacing"> </span>-<span class="heti-spacing"> </span></span>范围锁</strong>(key-range locks)：锁定一个键范围，从现有键到下一个键</p>
<p></p><div style="text-align: center">
<img src="images/lec14/38.png" width="60%/"/>
</div>
</li>
<li>
<p><strong>层级锁</strong>(hierarchical locks)：允许事务以不同模式持有更广泛的键范围锁，降低锁管理器的开销</p>
<p></p><div style="text-align: center">
<img src="images/lec14/39.png" width="60%/"/>
</div>
</li>
</ul>
</li>
<li>
<p>需要注意的是，索引锁协议没有解决索引中内部节点的并发控制。</p>
</li>
<li>对索引叶子节点的加锁能够阻止任何对节点的更新操作，即便实际上这个更新操作不会和谓词冲突。</li>
</ul>
</li>
</ul>
<h2 id="timestamp-based-protocols">Timestamp-Based Protocols<a class="headerlink" href="#timestamp-based-protocols" title="Permanent link">⚓︎</a></h2>
<h3 id="timestamps">Timestamps<a class="headerlink" href="#timestamps" title="Permanent link">⚓︎</a></h3>
<p>对系统中的每个事务<span><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span></span>，我们为其关联一个唯一的固定时间戳，记作<span><span class="heti-spacing"> </span>TS(<span class="arithmatex">\(T_i\)</span>)</span>。该时间戳由数据库系统在事务<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>开始执行前分配得到。如果事务<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_j\)</span><span class="heti-spacing"> </span></span>后于<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>执行，那么<span><span class="heti-spacing"> </span>TS(<span class="arithmatex">\(T_i\)</span>) &lt; TS(<span class="arithmatex">\(T_j\)</span>)</span>。具体有两种实现方式：</p>
<ul>
<li>使用<strong>系统时钟</strong><span>(system clock)<span class="heti-spacing"> </span></span>值作为时间戳，也就是说事务的时间戳等于事务进入系统时的时钟值</li>
<li>使用<strong>逻辑计数器</strong>(logical counter)，该计数器在分配新的时间戳后会递增；也就是说事务的时间戳等于事务进入系统时的计数器值</li>
</ul>
<p>事务的时间戳决定了可串行性顺序。因此，如果<span><span class="heti-spacing"> </span>TS(<span class="arithmatex">\(T_i\)</span>) &lt; TS(<span class="arithmatex">\(T_j\)</span>)</span>，那么系统必须确保得到的调度等价于<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>出现在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_j\)</span><span class="heti-spacing"> </span></span>之前的串行调度。为做到这点，我们为每个数据项<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(Q\)</span><span class="heti-spacing"> </span></span>关联两个时间戳值：</p>
<ul>
<li><strong>W-timestamp</strong>(<span class="arithmatex">\(Q\)</span>)：任何成功执行 <code>write(Q)</code> 的事务中最大的时间戳</li>
<li><strong>R-timestamp</strong>(<span class="arithmatex">\(Q\)</span>)：任何成功执行 <code>read(Q)</code> 的事务中最大的时间戳</li>
</ul>
<p>当新的 <code>read(Q)</code> 或 <code>write(Q)</code> 指令被执行时，这些时间戳就要更新了。</p>
<h3 id="the-timestamp-ordering-protocol">The Timestamp-Ordering Protocol<a class="headerlink" href="#the-timestamp-ordering-protocol" title="Permanent link">⚓︎</a></h3>
<p><strong>时间戳顺序协议</strong><span>(timestamp-ordering protocol)<span class="heti-spacing"> </span></span>确保任何冲突的 <code>read</code> 和 <code>write</code> 操作按照时间戳顺序执行，具体操作为：</p>
<ul>
<li>假设<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>发射 <code>read(Q)</code> 指令：<ul>
<li>如果<span><span class="heti-spacing"> </span>TS(<span class="arithmatex">\(T_i\)</span>) &lt; W-timestamp(<span class="arithmatex">\(Q\)</span>)</span>，那么<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>需要读取<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(Q\)</span><span class="heti-spacing"> </span></span>中已被覆写的值。因此，<code>read</code> 操作被拒绝，<span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>被回滚</li>
<li>如果<span><span class="heti-spacing"> </span>TS(<span class="arithmatex">\(T_i\)</span>) &gt;= W-timestamp(<span class="arithmatex">\(Q\)</span>)</span>，那么执行 <code>read</code> 操作，并且<span class="heti-skip"><span class="heti-spacing"> </span>R-timestamp(<span class="arithmatex">\(Q\)</span>)<span class="heti-spacing"> </span></span>被设为<span class="heti-skip"><span class="heti-spacing"> </span>R-timestamp(<span class="arithmatex">\(Q\)</span>)<span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span>TS(<span class="arithmatex">\(T_i\)</span>)<span class="heti-spacing"> </span></span>中的最大值</li>
</ul>
</li>
<li>假设<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>发射 <code>write(Q)</code> 指令：<ul>
<li>如果<span><span class="heti-spacing"> </span>TS(<span class="arithmatex">\(T_i\)</span>) &lt; R-timestamp(<span class="arithmatex">\(Q\)</span>)</span>，那么<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>需要读取，那么<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>试图生成的<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(Q\)</span><span class="heti-spacing"> </span></span>值在此之前已被读取，系统原先假定该值永远不会被产生。因此，<code>write</code> 操作被拒绝，<span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>被回滚</li>
<li>如果<span><span class="heti-spacing"> </span>TS(<span class="arithmatex">\(T_i\)</span>) &lt; W-timestamp(<span class="arithmatex">\(Q\)</span>)</span>，那么<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>尝试写入写入一个过时的<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(Q\)</span><span class="heti-spacing"> </span></span>值。因此，<code>write</code> 操作被拒绝，<span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>被回滚</li>
<li>否则系统执行 <code>write</code> 操作，并将<span class="heti-skip"><span class="heti-spacing"> </span>W-timestamp(<span class="arithmatex">\(Q\)</span>)<span class="heti-spacing"> </span></span>的值设为<span><span class="heti-spacing"> </span>TS(<span class="arithmatex">\(T_i\)</span>)</span></li>
</ul>
</li>
</ul>
<p>如果事务<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>被回滚，那么系统需要为该事务赋予新的时间戳，并重新启动该事务。</p>
<p>在双阶段锁协议下可行的调度，在时间戳协议下可能不可行，反之亦然。</p>
<p>时间戳顺序协议确保冲突可串行性，因为系统能够按照时间戳顺序处理冲突的操作。</p>
<p>该协议还确保不会出现死锁，因为没有事务会等待。然而，对于长事务，如果一系列冲突的短事务导致长事务的重复启动，那么就会出现饥饿问题。遇到这种情况，就需要暂时阻止那些冲突的事务，直至该事务能够顺利完成。</p>
<p>虽然该协议得到的调度时不可恢复的，但是我们可通过扩展该协议来使调度变得可恢复，具体有以下途径：</p>
<ul>
<li>通过将所有写操作集中在事务结束时执行，可以确保可恢复性和无级联性。这些写操作必须满足以下原子性要求：在写操作进行过程中，任何事务都不得访问已被写入的数据项。</li>
<li>通过采用一种有限形式的锁定机制，可以确保可恢复性和无级联性。在这种机制下，对未提交数据项的读取操作会被推迟，直到更新该数据项的事务提交为止。</li>
<li>仅通过追踪未提交的写入操作，并确保事务<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>只有在所有被其读取数据的事务提交之后才能提交，即可单独保障可恢复性。提交依赖机制正可用于实现这一目标。</li>
</ul>
<p>如果该协议仅作用在元组上，那么该协议很容易会遇到<a href="#predicate-reads-and-the-phantom-phenomenon">幽灵问题</a>。为避免该问题，就要将该协议作用在事务读取的整个数据上，包括关系元数据和索引数据。时间戳排序协议将每个索引节点视为一个数据项，并关联读写时间戳，同时对这些数据项也应用时间戳排序测试。这一扩展版的时间戳排序协议能够避免幽灵问题，并确保即使在谓词读取的情况下也能实现可串行化。</p>
<h3 id="thomas-write-rule">Thomas' Write Rule<a class="headerlink" href="#thomas-write-rule" title="Permanent link">⚓︎</a></h3>
<p>下面介绍一种能够提高潜在并发程度的时间戳顺序协议的改版——<strong>托马斯写规则</strong>(Thomas' write rule)：在特定情况下，我们可以忽略过时的写操作；对于读操作，协议规则保持不变。下面我们仅考虑 <code>write(Q)</code> 的情况：</p>
<ul>
<li>如果<span><span class="heti-spacing"> </span>TS(<span class="arithmatex">\(T_i\)</span>) &lt; R-timestamp(<span class="arithmatex">\(Q\)</span>)</span>，那么<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>需要读取，那么<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>试图生成的<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(Q\)</span><span class="heti-spacing"> </span></span>值在此之前已被读取，系统原先假定该值永远不会被产生。因此，<code>write</code> 操作被拒绝，<span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>被回滚</li>
<li>如果<span><span class="heti-spacing"> </span>TS(<span class="arithmatex">\(T_i\)</span>) &lt; W-timestamp(<span class="arithmatex">\(Q\)</span>)</span>，那么<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>尝试写入写入一个过时的<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(Q\)</span><span class="heti-spacing"> </span></span>值。因此，<code>write</code> 操作可以被忽略</li>
<li>否则系统执行 <code>write</code> 操作，并将<span class="heti-skip"><span class="heti-spacing"> </span>W-timestamp(<span class="arithmatex">\(Q\)</span>)<span class="heti-spacing"> </span></span>的值设为<span><span class="heti-spacing"> </span>TS(<span class="arithmatex">\(T_i\)</span>)</span></li>
</ul>
<p>和时间戳顺序协议相比，唯一的变化在于第二条规则。</p>
<p>通过忽略写操作，托马斯写规则允许那些虽然不具备冲突可串行化性质，但实际结果正确的调度，它们符合<strong>视图可串行化</strong><span>(view serializable)<span class="heti-spacing"> </span></span>调度的定义（见下面的补充<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>。托马斯写规则实质上是通过删除事务中已过时的写操作来利用视图可串行性。这种对事务的修改能够生成在其他协议下无法实现的、具有可串行性的调度。</p>
<details class="info">
<summary>补充：视图可串行性<span><span class="heti-spacing"> </span>(view serialzability)</span></summary>
<p>现有两个调度<span><span class="heti-spacing"> </span><span class="arithmatex">\(S, S'\)</span></span>，且它们包含的事务是一样的。如果满足以下条件，我们称这两个调度是<strong>视图等价的</strong>(view equivalent)：</p>
<ul>
<li>对于每个数据项<span><span class="heti-spacing"> </span><span class="arithmatex">\(Q\)</span></span>，如果事务<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>在调度<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(S\)</span><span class="heti-spacing"> </span></span>中读取<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(Q\)</span><span class="heti-spacing"> </span></span>的初始值，那么<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(S'\)</span><span class="heti-spacing"> </span></span>中的<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>也要读取<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(Q\)</span><span class="heti-spacing"> </span></span>的初始值</li>
<li>对于每个数据项<span><span class="heti-spacing"> </span><span class="arithmatex">\(Q\)</span></span>，如果在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(S\)</span><span class="heti-spacing"> </span></span>中的事务<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>执行 <code>read(Q)</code>，并且读取值来自事务<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_j\)</span><span class="heti-spacing"> </span></span>执行的 <code>write(Q)</code> 操作，那么在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(S'\)</span><span class="heti-spacing"> </span></span>中的事务<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>的<code>read(Q)</code> 也要读取值来自事务<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_j\)</span><span class="heti-spacing"> </span></span>执行的相同的 <code>write(Q)</code> 操作</li>
<li>对于每个数据项<span><span class="heti-spacing"> </span><span class="arithmatex">\(Q\)</span></span>，<span><span class="arithmatex">\(S\)</span><span class="heti-spacing"> </span></span>中执行最后的 <code>write(Q)</code> 的任何事务必须在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(S'\)</span><span class="heti-spacing"> </span></span>中执行最后的 <code>write(Q)</code></li>
</ul>
<p>如果调度<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(S\)</span><span class="heti-spacing"> </span></span>视图等价于一个串行调度，那么称<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(S\)</span><span class="heti-spacing"> </span></span>是<strong>视图可串行化的</strong>(view serializable)。</p>
<details class="example">
<summary>例子</summary>
<p></p><div style="text-align: center">
<img src="images/lec14/9.png" width="80%/"/>
</div>
<p></p><div style="text-align: center">
<img src="images/lec14/10.png" width="80%/"/>
</div>
</details>
<p>所有冲突可串行的调度都是视图可串行的，但是视图可串行的调度不一定是冲突可串行的。当视图可串行的调度出现<strong>盲写</strong>(blind writes)（事务在执行盲写时，并不知道它正在写入的数据项当前的值是什么，它“盲目地”覆盖了之前的值）时，该调度就不是冲突可串行的。</p>
</details>
<h2 id="validation-based-protocols">Validation-Based Protocols<a class="headerlink" href="#validation-based-protocols" title="Permanent link">⚓︎</a></h2>
<p>当大多数事务都是只读事务时，事务之间的冲突率就很低，因此如果这些事务不遵循并发控制方案（会带来执行开销和可能的延迟<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，也可以保证系统状态一致。所以我们有希望用其他替代方案来减少并发控制带来的开销，但难就难在我们无法预先知道事务之间是否有冲突。为了知道这一信息，我们需要一个能够<strong>监控</strong>系统的方案。</p>
<p><strong>验证协议</strong><span>(validation protocol)<span class="heti-spacing"> </span></span>正是这样的方案：它要求每个事务的执行分为<span class="heti-skip"><span class="heti-spacing"> </span>2-3<span class="heti-spacing"> </span></span>个不同的阶段，具体取决于事务的类型（只读<span class="heti-skip"><span class="heti-spacing"> </span>/<span class="heti-spacing"> </span></span>更新<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>。这些阶段为：</p>
<ol>
<li><strong>读阶段</strong>(read phase)：在该阶段，系统执行事务<span><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span></span>。它读取各种数据项，并将其存储到<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>的局部变量（或者认为是一块私有的工作空间）中。<span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>在局部变量上执行 <code>write</code> 操作，不会更新实际的数据库内容。</li>
<li><strong>验证阶段</strong>(validation phase)：对<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>进行验证测试（下面会详细介绍<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，用于确定<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>是否能够在不破坏可串行性的情况下进入到写阶段。如果事务没能通过验证测试，那么系统就会中止该事务。</li>
<li><strong>写阶段</strong>(write phase)：如果<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>成功通过验证测试，那么保留<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>执行的 <code>write</code> 操作结果的局部变量就会被拷贝到数据库中。只读事务忽略该阶段。</li>
</ol>
<details class="example">
<summary>例子</summary>
<p></p><div style="text-align: center">
<img src="images/lec14/27.gif" width="80%/"/>
</div>
</details>
<p>每个事务必须经历上述阶段。但是这些阶段在并发执行的事务中可以相互交错。</p>
<p>要执行验证测试，我们要知道事务的各阶段何时发生，因此我们将三个不同的时间戳关联到事务<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>上：</p>
<ul>
<li><strong>StartTS</strong>(<span class="arithmatex">\(T_i\)</span>)：<span class="arithmatex">\(T_i\)</span>：<span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>开始执行的时间</li>
<li><strong>ValidationTS</strong>(<span class="arithmatex">\(T_i\)</span>)：<span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>结束读阶段并且开始验证阶段的时间</li>
<li><strong>FinishTS</strong>(<span class="arithmatex">\(T_i\)</span>)：<span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>结束写阶段的时间</li>
</ul>
<p>我们使用<span><span class="heti-spacing"> </span>ValidationTS(<span class="arithmatex">\(T_i\)</span>)</span>，通过时间戳顺序协议来确定可串行性顺序（因此<span><span class="heti-spacing"> </span>TS(<span class="arithmatex">\(T_i\)</span>) = ValidationTS(<span class="arithmatex">\(T_i\)</span>)</span><heti-adjacent class="heti-adjacent-half">）</heti-adjacent>。<strong>验证测试</strong><span>(validation test)<span class="heti-spacing"> </span></span>要求事务<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>对于任意满足<span class="heti-skip"><span class="heti-spacing"> </span>TS(<span class="arithmatex">\(T_k\)</span>) &lt; TS(<span class="arithmatex">\(T_i\)</span>)<span class="heti-spacing"> </span></span>的事务<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_k\)</span><span class="heti-spacing"> </span></span>必须满足以下其中一个条件：</p>
<ul>
<li>
<p>FinishTS(<span class="arithmatex">\(T_k\)</span>) &lt; StartTS(<span class="arithmatex">\(T_i\)</span>)。因为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_k\)</span><span class="heti-spacing"> </span></span>先于<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>开始前完成执行，那么可串行顺序能被成功保留。</p>
<p></p><div style="text-align: center">
<img src="images/lec14/28.png" width="40%/"/>
</div>
</li>
<li>
<p>被<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_k\)</span><span class="heti-spacing"> </span></span>写入的数据项集不和<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>读取的数据项集相交（WriteSet(<span class="arithmatex">\(T_k\)</span>) <span class="arithmatex">\(\cap\)</span> ReadSet(<span class="arithmatex">\(T_i\)</span>) = <span class="arithmatex">\(\emptyset\)</span><heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，且<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_k\)</span><span class="heti-spacing"> </span></span>在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>开始验证阶段前完成写阶段（即<span><span class="heti-spacing"> </span>StartTS(<span class="arithmatex">\(T_i\)</span>) &lt; FinishTS(<span class="arithmatex">\(T_K\)</span>) &lt; ValidationTS(<span class="arithmatex">\(T_i\)</span>)</span><heti-adjacent class="heti-adjacent-half">）</heti-adjacent>。这一条件确保<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_k, T_i\)</span><span class="heti-spacing"> </span></span>的写操作不重叠。因为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_k\)</span><span class="heti-spacing"> </span></span>的写操作不影响<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>的读操作，且<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>不影响<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_k\)</span><span class="heti-spacing"> </span></span>的读操作，那么可串行顺序能被成功保留。</p>
<details class="example">
<summary>例子</summary>
<div class="tabbed-set tabbed-alternate" data-tabs="6:2"><input checked="" id="__tabbed_6_1" name="__tabbed_6" type="radio"/><input id="__tabbed_6_2" name="__tabbed_6" type="radio"/><div class="tabbed-labels"><label for="__tabbed_6_1">例<span class="heti-skip"><span class="heti-spacing"> </span>1<span class="heti-spacing"> </span></span></label><label for="__tabbed_6_2">例<span><span class="heti-spacing"> </span>2</span></label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p></p><div style="text-align: center">
<img src="images/lec14/29.gif" width="80%/"/>
</div>
</div>
<div class="tabbed-block">
<p></p><div style="text-align: center">
<img src="images/lec14/30.gif" width="80%/"/>
</div>
</div>
</div>
</div>
</details>
</li>
<li>
<p><span><span class="arithmatex">\(T_k\)</span><span class="heti-spacing"> </span></span>先于<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>完成读阶段，且<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_k\)</span><span class="heti-spacing"> </span></span>写入的数据不和<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>读取或写入的数据相交（<span>WriteSet(<span class="arithmatex">\(T_k\)</span>) <span class="arithmatex">\(\cap\)</span> ReadSet(<span class="arithmatex">\(T_i\)</span>) = <span class="arithmatex">\(\emptyset\)</span><span class="heti-spacing"> </span></span>并且<span><span class="heti-spacing"> </span>WriteSet(<span class="arithmatex">\(T_k\)</span>) <span class="arithmatex">\(\cap\)</span> WriteSet(<span class="arithmatex">\(T_i\)</span>) = <span class="arithmatex">\(\emptyset\)</span></span>）</p>
<details class="example">
<summary>例子</summary>
<p></p><div style="text-align: center">
<img src="images/lec14/31.gif" width="80%/"/>
</div>
</details>
</li>
</ul>
<p>上述验证方法被称为<strong>前向验证</strong>(forward validation)，因为它检查正在提交的事务是否和其他<strong>未提交</strong>事务的读写数据集有重叠。</p>
<div style="text-align: center">
<img src="images/lec14/32.png" width="70%/"/>
</div>
<p>对应的，我们也有<strong>后向验证</strong><span>(backward validation)<span class="heti-spacing"> </span></span>的方法，要求检查正在提交的事务是否和其他<strong>已提交</strong>事务的读写数据集有重叠。</p>
<div style="text-align: center">
<img src="images/lec14/33.png" width="70%/"/>
</div>
<p>验证方案能够自动防止级联回滚的发生，因为实际写入操作仅在发起写入的事务提交之后执行。然而，由于一系列冲突的短事务可能导致长事务反复重启，存在长事务陷入饥饿状态的风险。为避免这种情况，必须暂时阻塞与之冲突的其他事务，以确保长事务能够顺利完成。</p>
<p>另外，验证条件导致事务<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T\)</span><span class="heti-spacing"> </span></span>仅需针对那些在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T\)</span><span class="heti-spacing"> </span></span>开始之后完成，且进一步在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T\)</span><span class="heti-spacing"> </span></span>之前被序列化的事务集合<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>进行重新验证。对于在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T\)</span><span class="heti-spacing"> </span></span>开始前已完成的事务，可以在验证测试中予以忽略。同样地，那些序列化顺序排在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T\)</span><span class="heti-spacing"> </span></span>之后（即其<span><span class="heti-spacing"> </span>ValidationTS(<span class="arithmatex">\(T_i\)</span>) &gt; ValidationTS(<span class="arithmatex">\(T\)</span>)</span>）的事务<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>也可被忽略；因为当事务<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>接受验证时，若<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T\)</span><span class="heti-spacing"> </span></span>的完成时间晚于<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>的开始时间，它自会与<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T\)</span><span class="heti-spacing"> </span></span>进行比对验证。</p>
<p>这种验证方案被称为<strong>乐观并发控制方案</strong>(optimistic concurrency-control scheme)，因为<span class="heti-skip"><span class="heti-spacing"> </span>DBMS<span class="heti-spacing"> </span></span>假定事务发生冲突的概率很低（大多数事务都是只读的，或者事务访问的数据是不相交的<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，大多数情况下能够顺利完成并在最后阶段通过验证，即便失败了也要到最后再处理。时间戳协议也属于乐观策略（教材中的说法不对<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>。相比之下，<strong>锁协议</strong>则属于<strong>悲观</strong>策略——一旦检测到冲突，即便存在调度可能实现冲突可串行化的机会，这些方法也会强制事务等待或回滚。</p>
<h2 id="multiversion-schemes">Multiversion Schemes<a class="headerlink" href="#multiversion-schemes" title="Permanent link">⚓︎</a></h2>
<p>前面讲到的并发控制方案都是通过延迟操作或中止事务来确保可串行性的，但这些操作都需要不小的成本。如果系统能为单个的<strong>逻辑</strong>对象保留多个<strong>物理</strong>版本，那么就可以避免这一问题——<strong>多版本并发控制</strong><span>(multiversion concurrency-control, MVCC)<span class="heti-spacing"> </span></span>方案正是这么做的：每次 <code>write(Q)</code> 操作都会为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(Q\)</span><span class="heti-spacing"> </span></span>创建一个新<strong>版本</strong>(version)；当事务发起 <code>read(Q)</code> 操作时，并发控制管理器选择<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(Q\)</span><span class="heti-spacing"> </span></span>的某个版本读取，这个选择要确保可串行性，并且还要考虑到性能问题。</p>
<p><span>MVCC<span class="heti-spacing"> </span></span>的基本概念或优势在于<strong>写操作不会阻塞读操作，读操作也不会阻塞写操作</strong>。这意味着一个事务在修改对象时，其他事务仍可读取该对象的旧版本。若多个写操作针对同一对象，则仍可能相互阻塞，因为与数据库对象相关的版本上依然存在锁机制。</p>
<details class="example">
<summary>例子</summary>
<div class="tabbed-set tabbed-alternate" data-tabs="7:2"><input checked="" id="__tabbed_7_1" name="__tabbed_7" type="radio"/><input id="__tabbed_7_2" name="__tabbed_7" type="radio"/><div class="tabbed-labels"><label for="__tabbed_7_1">例<span class="heti-skip"><span class="heti-spacing"> </span>1<span class="heti-spacing"> </span></span></label><label for="__tabbed_7_2">例<span><span class="heti-spacing"> </span>2</span></label></div>
<div class="tabbed-content">
<div class="tabbed-block">
<p></p><div style="text-align: center">
<img src="images/lec14/40.gif" width="80%/"/>
</div>
</div>
<div class="tabbed-block">
<p></p><div style="text-align: center">
<img src="images/lec14/41.gif" width="80%/"/>
</div>
</div>
</div>
</div>
</details>
<h3 id="multiversion-timestamp-ordering">Multiversion Timestamp Ordering<a class="headerlink" href="#multiversion-timestamp-ordering" title="Permanent link">⚓︎</a></h3>
<p>我们能将时间戳顺序协议扩展到多版本控制：事务时间戳的定义和原来一致，但是对于每个数据项<span><span class="heti-spacing"> </span><span class="arithmatex">\(Q\)</span></span>，它关联到多个版本<span><span class="heti-spacing"> </span><span class="arithmatex">\(&lt;Q_1, Q_2,  dots, Q_m&gt;\)</span></span>，且每个版本<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(Q_k\)</span><span class="heti-spacing"> </span></span>包含三个数据字段：</p>
<ul>
<li><strong>内容</strong>：版本<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(Q_k\)</span><span class="heti-spacing"> </span></span>的值</li>
<li><strong>W-timestamp</strong>(<span class="arithmatex">\(Q_k\)</span>)：事务创建版本<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(Q_k\)</span><span class="heti-spacing"> </span></span>的时间戳</li>
<li><strong>R-timestamp</strong>(<span class="arithmatex">\(Q_k\)</span>)：任何事物成功读取版本<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(Q_k\)</span><span class="heti-spacing"> </span></span>的最大时间戳</li>
</ul>
<p>事务<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>通过发起 <code>write(Q)</code> 操作来创建数据项<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(Q\)</span><span class="heti-spacing"> </span></span>的新版本<span><span class="heti-spacing"> </span><span class="arithmatex">\(Q_k\)</span></span>，其中内容字段保留<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>写入的值，并且系统为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>初始化<span class="heti-skip"><span class="heti-spacing"> </span>W-timestamp<span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span>R-timestamp<span class="heti-spacing"> </span></span>为<span><span class="heti-spacing"> </span>TS(<span class="arithmatex">\(T_i\)</span>)</span>。当事务<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_j\)</span><span class="heti-spacing"> </span></span>读取<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(Q_k\)</span><span class="heti-spacing"> </span></span>的内容，且<span class="heti-skip"><span class="heti-spacing"> </span>R-timestamp(<span class="arithmatex">\(Q_k\)</span>) &lt; TS(<span class="arithmatex">\(T_j\)</span>)<span class="heti-spacing"> </span></span>时，更新<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(Q_k\)</span><span class="heti-spacing"> </span></span>的<span class="heti-skip"><span class="heti-spacing"> </span>R-timestamp<span class="heti-spacing"> </span></span>值。</p>
<p><strong>多版本时间戳顺序方案</strong><span>(multiversion timestamp-ordering scheme)<span class="heti-spacing"> </span></span>能确保可串行性，具体操作为：假设事务<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>发出 <code>read(Q)</code> 或 <code>write(Q)</code>；令<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(Q_k\)</span><span class="heti-spacing"> </span></span>为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(Q\)</span><span class="heti-spacing"> </span></span>中写时间戳最大且小于等于<span class="heti-skip"><span class="heti-spacing"> </span>TS(<span class="arithmatex">\(T_i\)</span>)<span class="heti-spacing"> </span></span>的版本。</p>
<ul>
<li>如果<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>发出 <code>read(Q)</code>，那么返回值为<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(Q_k\)</span><span class="heti-spacing"> </span></span>值。</li>
<li>如果<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>发出 <code>write(Q)</code>，且<span><span class="heti-spacing"> </span>TS(<span class="arithmatex">\(T_i\)</span>) &lt; R-timestamp(<span class="arithmatex">\(Q_k\)</span>)</span>，那么系统回滚<span><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span></span>；如果<span><span class="heti-spacing"> </span>TS(<span class="arithmatex">\(T_i\)</span>) = W-timestamp(<span class="arithmatex">\(Q_k\)</span>)</span>，系统覆写<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(Q_k\)</span><span class="heti-spacing"> </span></span>的内容；否则（TS(<span class="arithmatex">\(T_i\)</span>) &gt; R-timestamp(<span class="arithmatex">\(Q_k\)</span>)）创建<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(Q\)</span><span class="heti-spacing"> </span></span>的新版本。</li>
</ul>
<p><span><span class="arithmatex">\(Q\)</span><span class="heti-spacing"> </span></span>的版本<span><span class="heti-spacing"> </span><span class="arithmatex">\(Q_i\)</span></span>（其<span class="heti-skip"><span class="heti-spacing"> </span>W-timestamp<span class="heti-spacing"> </span></span>记作<span><span class="heti-spacing"> </span><span class="arithmatex">\(t\)</span></span>）的<strong>有效区间</strong><span>(valid interval)<span class="heti-spacing"> </span></span>定义如下：</p>
<ul>
<li>如果<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(Q_i\)</span><span class="heti-spacing"> </span></span>是<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(Q\)</span><span class="heti-spacing"> </span></span>的最新版本，那么区间为<span><span class="heti-spacing"> </span><span class="arithmatex">\([t, \infty]\)</span></span></li>
<li>否则令<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(Q\)</span><span class="heti-spacing"> </span></span>的下一版本有时间戳<span><span class="heti-spacing"> </span><span class="arithmatex">\(s\)</span></span>，那么区间为<span><span class="heti-spacing"> </span><span class="arithmatex">\([t, s)\)</span></span></li>
</ul>
<p>不再需要的版本将按照以下规则进行移除：假设数据项存在两个版本<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(Q_k\)</span><span class="heti-spacing"> </span></span>和<span><span class="heti-spacing"> </span><span class="arithmatex">\(Q_j\)</span></span>，且这两个版本的写时间戳均小于系统中最早活跃事务的时间戳。那么，在这两个版本中较旧的那个（<span><span class="arithmatex">\(Q_k\)</span><span class="heti-spacing"> </span></span>或<span><span class="heti-spacing"> </span><span class="arithmatex">\(Q_j\)</span></span>）将不会被再次使用，因此可以被删除。</p>
<p>这种协议有一个不错的性质是读取请求永远不会失败，且永远不需要等待。但它也有两个不好的性质：</p>
<ul>
<li>读取数据项的同时爱要求更新<span class="heti-skip"><span class="heti-spacing"> </span>R-timestamp<span class="heti-spacing"> </span></span>字段，导致需要两次磁盘访问（而不是原来的一次）</li>
<li>事务之间的冲突需要通过回滚解决（而不是靠等待解决<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，因此会带来更高的成本</li>
</ul>
<p>另外，该方案不确保可恢复性和无级联性，但这些可通过扩展（类似基础版的时间戳顺序协议扩展）来实现。</p>
<h3 id="multiversion-two-phase-locking">Multiversion Two-Phase Locking<a class="headerlink" href="#multiversion-two-phase-locking" title="Permanent link">⚓︎</a></h3>
<p><strong>多版本两阶段锁协议</strong><span>(multiversion two-phase locking protocol)<span class="heti-spacing"> </span></span>尝试结合多版本并发控制和两阶段锁的优点。该协议为只读事务和更新事务采取不同操作：</p>
<ul>
<li><strong>更新事务</strong><ul>
<li>执行强严格两阶段加锁（保留所有的锁，直至事务结束<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>。因此事务可按提交顺序被串行化。</li>
<li>每个版本的数据项都有单个的时间戳，它本质上是一个计数器（叫做 <code>ts-counter</code><heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，在提交处理中会递增。</li>
<li>当事务读取数据项时，它会获得该数据项的共享锁，并读取该数据项的最新版本。</li>
<li>当事务想要写入数据项时，它会先获得该数据项的独占锁，然后创建数据项的一个新版本。写操作将在新版本上执行，并且新版本的时间戳被初始化为<span><span class="heti-spacing"> </span><span class="arithmatex">\(\infty\)</span></span>（一个超过所有时间戳的很大的值<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>。</li>
<li>当事务完成操作时，它会执行提交处理。规定一次仅允许一个更新事务处理提交。具体步骤为：首先，<span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>为每个它创建的版本时间戳设置值为<code>ts-counter</code><span><span class="heti-spacing"> </span>+ 1</span>；然后<code>ts-couner</code><span><span class="heti-spacing"> </span>++</span>，并提交事务。</li>
</ul>
</li>
<li><strong>只读事务</strong>：事务在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>成功提交之前看到的是 <code>ts-counter</code> 的旧值。因此，在<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>提交后开始的只读事务才能看到<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>更新的值。但无论在提交前后，事务都无需等待锁。</li>
</ul>
<p>该协议能确保调度的可恢复性和无级联性。</p>
<p>版本的删除方式类似于多版本时间戳排序：假设一个数据项存在两个版本<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(Q_k\)</span><span class="heti-spacing"> </span></span>和<span><span class="heti-spacing"> </span><span class="arithmatex">\(Q_j\)</span></span>，且这两个版本的时间戳都小于或等于系统中最早只读事务的时间戳。那么，在这两个版本<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(Q_k\)</span><span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(Q_j\)</span><span class="heti-spacing"> </span></span>中较旧的那个将不再被使用，因此可以被删除。</p>
<h3 id="mvcc-design-decision">MVCC Design Decision<a class="headerlink" href="#mvcc-design-decision" title="Permanent link">⚓︎</a></h3>
<p>在设计<span class="heti-skip"><span class="heti-spacing"> </span>MVCC<span class="heti-spacing"> </span></span>时，我们需要考虑：</p>
<ul>
<li><strong>并发控制协议</strong>(concurrency control protocol)</li>
<li><strong>版本存储</strong>(version storage)</li>
<li><strong>垃圾回收</strong>(garbage collection, GC)</li>
<li><strong>索引管理</strong>(index management)</li>
<li><strong>删除</strong>(deletion)</li>
</ul>
<h4 id="version-storage">Version Storage<a class="headerlink" href="#version-storage" title="Permanent link">⚓︎</a></h4>
<p><span>DBMS<span class="heti-spacing"> </span></span>利用元组的指针字段为每个逻辑元组创建<strong>版本链</strong>(version chain)。这本质上是一个按时间戳排序的版本链表，让<span class="heti-skip"><span class="heti-spacing"> </span>DBMS<span class="heti-spacing"> </span></span>能够在运行时找到对特定事务可见的版本。索引始终指向链的<span class="heti-skip"><span class="heti-spacing"> </span>"<span class="heti-spacing"> </span></span>头部<span><span class="heti-spacing"> </span>"</span>，根据实现方式不同，该头部可能是最新或最旧的版本。线程会遍历链条直至定位到正确的版本。不同的存储方案决定了每个版本的存储内容及位置。</p>
<p>具体有以下三种版本存储方法：</p>
<ul>
<li>
<p><strong>仅追加存储</strong>(append-only storage)：</p>
<ul>
<li>逻辑元组的所有物理版本均存储在同一表空间中</li>
<li>
<p>版本在表中是被混合存放的，每次更新仅向表内追加该元组的新版本并更新版本链</p>
<p></p><div style="text-align: center">
<img src="images/lec14/44.png" width="50%/"/>
</div>
</li>
<li>
<p>可采取的两种排序方式有：</p>
<ul>
<li><strong>从旧到新</strong><span>(O2N)<span class="heti-spacing"> </span></span>排序：查询需遍历整个链条</li>
<li><strong>从新到旧</strong><span>(N2O)<span class="heti-spacing"> </span></span>排序：则每个新版本都需更新索引指针，但无需遍历整个链。因此通常该方法是更好的方案，因为多数事务仅关注最新版本</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>时间旅行存储</strong>(time-travel storage)：</p>
<ul>
<li><span>DBMS<span class="heti-spacing"> </span></span>维护一个名为<strong>时间旅行表</strong><span>(time-travel table)<span class="heti-spacing"> </span></span>的独立表格，用于存储元组的旧版本</li>
<li>每次更新时，系统会将元组的旧版本复制到时间旅行表中，并用新数据覆盖主表中的对应元组</li>
<li>主表中元组的指针指向时间旅行表里的历史版本</li>
</ul>
<details class="example">
<summary>例子</summary>
<p></p><div style="text-align: center">
<img src="images/lec14/45.gif" width="80%/"/>
</div>
</details>
</li>
<li>
<p><strong>增量存储</strong>(delta storage)：</p>
<ul>
<li>类似时间旅行存储，但<span class="heti-skip"><span class="heti-spacing"> </span>DBMS<span class="heti-spacing"> </span></span>并不保存所有的历史元组，而是仅存储<strong>增量或变更部分</strong>于所谓的<strong>增量存储段</strong><span>(delta storage segment)<span class="heti-spacing"> </span></span>中</li>
<li>事务可通过逆向遍历这些增量并逐一应用来重建旧版本数据</li>
<li>这种方式相比时间旅行存储实现了更快的写入速度，但读取速度较慢</li>
</ul>
<details class="example">
<summary>例子</summary>
<p></p><div style="text-align: center">
<img src="images/lec14/46.gif" width="80%/"/>
</div>
</details>
</li>
</ul>
<h4 id="garbage-collection">Garbage Collection<a class="headerlink" href="#garbage-collection" title="Permanent link">⚓︎</a></h4>
<p><span>DBMS<span class="heti-spacing"> </span></span>需要随时间推移从数据库中移除<strong>可回收的</strong><span>(reclaimable)<span class="heti-spacing"> </span></span>物理版本。当一个版本不被任何活跃事务“可见”，或是由已中止的事务创建时，该版本即为可回收状态。我们可以执行<strong>元组</strong>级别或<strong>事务</strong>级别的<strong>垃圾回收</strong><span>(garbage collection, GC)<span class="heti-spacing"> </span></span>操作。</p>
<ul>
<li>
<p><strong>元组</strong>级别：<span>DBMS<span class="heti-spacing"> </span></span>通过直接检查元组来定位旧版本数据，具体实现方式有两种：</p>
<ul>
<li>
<p><strong>后台清理</strong>(background vacuuming)：由独立线程周期性地扫描表并标记可回收的版本</p>
<ul>
<li>此方法适用于任何版本存储方案</li>
<li>一个简单的优化是维护<span class="heti-skip"><span class="heti-spacing"> </span>"<span class="heti-spacing"> </span></span>脏页位图<span><span class="heti-spacing"> </span>"</span>，用于记录自上次扫描以来被修改过的页面，从而让清理线程跳过未变化的页面</li>
</ul>
<details class="example">
<summary>例子</summary>
<p></p><div style="text-align: center">
<img src="images/lec14/47.gif" width="80%/"/>
</div>
</details>
</li>
<li>
<p><strong>协同清理</strong>(cooperative cleaning)：工作线程在遍历版本链时识别可回收的版本</p>
<ul>
<li>此方法仅适用于<span class="heti-skip"><span class="heti-spacing"> </span>O2N<span class="heti-spacing"> </span></span>版本链结构</li>
<li>若数据未被访问，则永远不会被清理</li>
</ul>
<details class="example">
<summary>例子</summary>
<p></p><div style="text-align: center">
<img src="images/lec14/48.gif" width="80%/"/>
</div>
</details>
</li>
</ul>
</li>
<li>
<p><strong>事务</strong>级别：每个事务负责追踪自身的旧版本数据，因此数据库管理系统无需扫描元组。各事务独立维护其读写集合。当事务完成时，垃圾收集器可据此识别待回收的元组。数据库管理系统会判定已完结事务所创建的所有版本何时不再可见。</p>
<details class="example">
<summary>例子</summary>
<p></p><div style="text-align: center">
<img src="images/lec14/49.gif" width="80%/"/>
</div>
</details>
</li>
</ul>
<h4 id="index-management">Index Management<a class="headerlink" href="#index-management" title="Permanent link">⚓︎</a></h4>
<p>所有<strong>主键索引</strong>始终指向版本链头。<span>DBMS<span class="heti-spacing"> </span></span>需要更新主键索引的频率取决于系统在更新元组时是否创建新版本。如果事务更新主键属性，则视其为先 <code>DELETE</code> 后 <code>INSERT</code>。</p>
<p>管理<strong>二级索引</strong>更复杂，有以下处理方法：</p>
<ul>
<li>
<p><strong>逻辑指针</strong>：<span>DBMS<span class="heti-spacing"> </span></span>为每个元组使用一个固定不变的标识符；这需要一个额外的间接层，将逻辑<span class="heti-skip"><span class="heti-spacing"> </span>ID<span class="heti-spacing"> </span></span>映射到元组的物理位置上，这样对元组的更新只需修改间接层中的映射关系即可。</p>
<p></p><div style="text-align: center">
<img src="images/lec14/50.png" width="80%/"/>
</div>
</li>
<li>
<p><strong>物理指针</strong>：<span>DBMS<span class="heti-spacing"> </span></span>通过物理地址定位版本链头部；当版本链头部更新时，要求同步更新所有索引，因此成本可能会非常高。</p>
<p></p><div style="text-align: center">
<img src="images/lec14/51.png" width="80%/"/>
</div>
</li>
</ul>
<hr/>
<p><span>MVCC DBMS<span class="heti-spacing"> </span></span>的索引（通常）不会将元组的版本信息与其键一同存储。相反，每个索引都必须支持来自不同快照的<strong>重复键</strong>(duplicate key)，因为相同的键可能在不同快照中指向不同的逻辑元组。</p>
<p>工作线程在一次查询中可能获取多条记录项，随后必须通过指针追踪才能定位到其对应的正确物理版本。</p>
<details class="example">
<summary>例子</summary>
<p></p><div style="text-align: center">
<img src="images/lec14/52.gif" width="80%/"/>
</div>
</details>
<h4 id="deletion_1">Deletion<a class="headerlink" href="#deletion_1" title="Permanent link">⚓︎</a></h4>
<p><span>DBMS<span class="heti-spacing"> </span></span>仅在逻辑删除元组的所有版本均不可见时，才从数据库中物理删除该元组。若某元组已被标记为删除，则其最新版本之后不会产生新版本。这意味着不存在写<span class="heti-skip"><span class="heti-spacing"> </span>-<span class="heti-spacing"> </span></span>写冲突，遵循<span class="heti-skip"><span class="heti-spacing"> </span>"<span class="heti-spacing"> </span></span>先写入者胜出<span class="heti-skip"><span class="heti-spacing"> </span>"<span class="heti-spacing"> </span></span>原则。</p>
<p>有以下两种表示某个元组在特定时间点已被逻辑删除的实现方法：</p>
<ul>
<li><strong>删除标志</strong>(deleted flag)：维护一个标志，用于表示逻辑元组在最新物理版本后已被删除，该标志可置于元组头部或作为独立列存在</li>
<li><strong>墓碑元组</strong>(tombstone tuple)：创建空物理版本来标记逻辑元组已删除；为墓碑元组设立独立存储池，仅在版本链指针中设置特殊位模式以降低存储开销</li>
</ul>
<details class="info">
<summary>各家数据库的<span class="heti-skip"><span class="heti-spacing"> </span>MVCC<span class="heti-spacing"> </span></span>实现</summary>
<p></p><div style="text-align: center">
<img src="images/lec14/53.png" width="80%/"/>
</div>
</details>
<h2 id="snapshot-isolation">Snapshot Isolation<a class="headerlink" href="#snapshot-isolation" title="Permanent link">⚓︎</a></h2>
<p>接下来介绍一种很流行的并发控制方案——<strong>快照隔离</strong>(snapshot isolation)。在事务开始执行时，它为该事务提供了数据库的“快照”。随后，该事务在此快照上进行操作，完全独立于其他并发事务。快照中的数据仅包含已提交事务所写入的值。这种隔离方式对<strong>只读事务</strong>而言极为理想，因为它们既无需等待，也永远不会被并发管理器中止。</p>
<p>不过在这种方案下，<strong>更新</strong>数据库的事务可能会与其他同样执行更新的操作产生冲突。所以，在允许事务提交之前，必须对其执行的更新进行有效性验证。所有更新内容会暂存于该事务的私有工作区中，直至通过验证后才会被正式写入数据库。</p>
<p>当允许事务<span><span class="heti-spacing"> </span><span class="arithmatex">\(T\)</span></span> <strong>提交</strong>时，<span><span class="arithmatex">\(T\)</span><span class="heti-spacing"> </span></span>向已提交状态的转换，以及由<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T\)</span><span class="heti-spacing"> </span></span>执行的所有更新写入数据库的操作，必须用一个原子动作<span class="heti-skip"><span class="heti-spacing"> </span>(atomic action)<span class="heti-spacing"> </span></span>完成。这样，为其他事务创建的任何快照要么包含事务<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T\)</span><span class="heti-spacing"> </span></span>的全部更新，要么完全不包含其中任何更新。</p>
<h3 id="multiversioning-in-snapshot-isolation">Multiversioning in Snapshot Isolation<a class="headerlink" href="#multiversioning-in-snapshot-isolation" title="Permanent link">⚓︎</a></h3>
<p>要实现快照隔离，事务会被给予两个时间戳：</p>
<ul>
<li>StartTS(<span class="arithmatex">\(T_i\)</span>)：事务<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>开始的时间</li>
<li>CommitTS(<span class="arithmatex">\(T_i\)</span>)：事务<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>请求验证的时间</li>
</ul>
<p>虽然这两个时间戳可以用系统时钟表示，但一般用的是计数器。当事务进入验证阶段时，计数器就会递增。</p>
<p>快照隔离基于多版本机制，每个更新数据项的事务都会为该数据项创建一个新版本。各版本仅携带<span class="heti-skip"><span class="heti-spacing"> </span>1<span class="heti-spacing"> </span></span>个时间戳——写入时间戳。由事务<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>生成的版本，其时间戳设定为<span><span class="heti-spacing"> </span>CommitTS(<span class="arithmatex">\(T_i\)</span>)</span>。</p>
<p>当事务<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>读取一个数据项时，系统会返回时间戳<span class="heti-skip"><span class="heti-spacing"> </span>&lt;= StartTS(<span class="arithmatex">\(T_i\)</span>)<span class="heti-spacing"> </span></span>的最新数据版本。因此，<span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>不会看到任何在其启动后提交的事务所做的更新，但能获取所有在它开始前已提交事务的更新。这种机制使得<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>实质上获得了其启动时刻的数据库快照。</p>
<h3 id="validation-steps-for-update-transactions">Validation Steps for Update Transactions<a class="headerlink" href="#validation-steps-for-update-transactions" title="Permanent link">⚓︎</a></h3>
<p>决定是否允许一个更新事务提交需要谨慎处理——两个并发运行的事务可能会同时更新同一数据项。由于这两个事务各自使用独立的私有快照进行操作，彼此都无法看到对方的更新结果。若两者均被允许写入数据库，先前的更新将被后续的覆盖，从而导致<strong>丢失更新</strong><span>(lost update)<span class="heti-spacing"> </span></span>现象——这是必须避免的问题。</p>
<p>快照隔离给出了两种解决方案：<strong>先提交者胜</strong><span>(first committer wins)<span class="heti-spacing"> </span></span>与<strong>先更新者胜</strong>(first updater wins)。这两种机制的核心原理都是通过检测事务与其他并发事务之间的冲突来实现的。</p>
<p>我们明确一下并发的概念：如果一个事务<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_j\)</span><span class="heti-spacing"> </span></span>在给定事务<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>开始执行，直至其验证阶段启动的期间内处于活跃状态或部分提交状态，则称<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_j\)</span><span class="heti-spacing"> </span></span>与<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>是<strong>并发的</strong>。形式化的表述为：当且仅当满足以下任一条件时，<span><span class="arithmatex">\(T_j\)</span><span class="heti-spacing"> </span></span>与<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>并发：</p>
<ul>
<li>StartTS(<span class="arithmatex">\(T_j\)</span>) &lt;= StartTS(<span class="arithmatex">\(T_i\)</span>) &lt;= CommitTS(<span class="arithmatex">\(T_j\)</span>)，或</li>
<li>StartTS(<span class="arithmatex">\(T_i\)</span>) &lt;= StartTS(<span class="arithmatex">\(T_j\)</span>) &lt;= CommitTS(<span class="arithmatex">\(T_i\)</span>)</li>
</ul>
<p>下面详细讨论快照隔离的两种机制：</p>
<ul>
<li>
<p><strong>先提交者胜</strong>：当事务<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>开始验证时，在其北分配到<span class="heti-skip"><span class="heti-spacing"> </span>CommitTS<span class="heti-spacing"> </span></span>后，将执行以下操作作为验证的一部分（为简化说明，我们假设同一时间仅有一个交易进行验证<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>：</p>
<ul>
<li>进行一项测试，以检查是否存在与事务<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T\)</span><span class="heti-spacing"> </span></span>并发执行的任何其他事务，已经对<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T\)</span><span class="heti-spacing"> </span></span>计划写入的某些数据项进行了更新并写入了数据库。具体通过以下方式实现：对于事务<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>中打算写入的每一个数据项<span><span class="heti-spacing"> </span><span class="arithmatex">\(d\)</span></span>，检查是否存在一个版本的数据项<span><span class="heti-spacing"> </span><span class="arithmatex">\(d\)</span></span>，其时间戳位于<span class="heti-skip"><span class="heti-spacing"> </span>StartTS(<span class="arithmatex">\(T_i\)</span>)<span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span>CommitTS(<span class="arithmatex">\(T_i\)</span>)<span class="heti-spacing"> </span></span>之间。</li>
<li>如果找到这样的数据项，就中止<span><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span></span>；</li>
<li>否则（没有找到数据项）就提交<span><span class="heti-spacing"> </span><span class="arithmatex">\(T\)</span></span>，它的更新将会写入到数据库中。</li>
</ul>
<p>之所以该机制称为“先提交者胜”，是因为如果事务发生冲突时，按照上述规则，首先接受测试的事务将成功写入其更新，而后续的事务则被迫中止。</p>
</li>
<li>
<p><strong>先更新者胜</strong>：系统使用一种仅适用于更新的锁定机制（读取不受此影响，因为它们不获取锁）——当事务<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>尝试更新一个数据项时，它请求对该数据项的<strong>写入锁</strong>(write lock)。如果其他并发事务未持有对该数据项的锁，那么在该事务获取锁之后采取以下步骤：</p>
<ul>
<li>如果数据项被任何其他并发事务更新的话，则中止<span><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span></span></li>
<li>否则<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>继续执行，包括（可能的）提交</li>
</ul>
<p>但有并发事务<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_j\)</span><span class="heti-spacing"> </span></span>已经对该数据项上了写入锁的话，那么<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>就不能继续执行下去，且要遵循以下规则：<span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>等待<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_j\)</span><span class="heti-spacing"> </span></span>中止或提交。</p>
<ul>
<li>如果<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_j\)</span><span class="heti-spacing"> </span></span>中止，那么它的锁就会释放，<span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>就能获得锁。获取锁之后，系统会按照前文所述方式检查是否存在并发事务的更新操作：若检测到其他事务已修改该数据项，则中止当前事务<span><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span></span>；反之，则允许其继续执行。</li>
<li>如果<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_j\)</span><span class="heti-spacing"> </span></span>提交，那么<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_i\)</span><span class="heti-spacing"> </span></span>必须中止。</li>
</ul>
<p>之所以该机制称为“先更新者胜”，是因为如果事务发生冲突，第一个获得锁的事务将被允许提交并执行其更新。之后尝试更新的其他事务将会中止，除非先前的更新者因其他原因而中止。</p>
</li>
</ul>
<h3 id="serializability-issues-and-solutions">Serializability Issues and Solutions<a class="headerlink" href="#serializability-issues-and-solutions" title="Permanent link">⚓︎</a></h3>
<p>快照隔离在实际应用中很受欢迎，因为事务能够在读取大量数据的同时不会干扰到更短的更新事务（而两阶段锁协议中，长时间的只读事务会阻碍更新事务的进行<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>。</p>
<p>值得注意的是，数据库提供的完整性约束不会在快照中被检查，因此可能有两个并发事务插入相同主键值的元组，或者有事务插入一个从参照表中被并发删除的外键值。这个问题的处理方式是：检查数据库当前状态下的这些约束，而不是在快照上，这作为提交时的验证部分。</p>
<p>更严重的一个问题是：快照隔离不保证可串行性。但实际上，可串行性问题发生概率相对较少，因为：</p>
<ul>
<li>数据库必须在提交时而非快照状态下检查完整性约束，这一机制有助于避免数据不一致问题。当两个事务在快照隔离外试图创建相同主键时，数据库系统会检测到这种主键冲突并回滚其中一个事务。<ul>
<li>研究表明，在快照隔离环境下，执行主流事务处理基准测试<a href="https://www.tpc.org/tpcc/"><span class="heti-skip"><span class="heti-spacing"> </span>TPC-C<span class="heti-spacing"> </span></span></a>时，主键约束能确保所有事务不会出现不可串行性问题。但这类情况还是偶有发生，而一旦出现的话就必须妥善处理。</li>
</ul>
</li>
<li>在许多易受可串行化问题影响的应用场景中（例如<strong>写偏斜</strong><span>(write skew)<span class="heti-spacing"> </span></span>的情况<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，某些数据项上的事务会在其他数据项上产生冲突，从而确保这类事务无法并发执行；因此在快照隔离机制下，此类事务的执行仍能保持可串行化特性。</li>
</ul>
<details class="example">
<summary>一个关于写偏斜的例子</summary>
<p>如果事务是可串行化的，按顺序执行两个事务后的结果为：</p>
<p></p><div style="text-align: center">
<img src="images/lec14/42.png" width="80%/"/>
</div>
<p>但快照隔离可能会导致以下写偏斜问题的发生，导致结果不负预期（就是上面的结果<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>：</p>
<p></p><div style="text-align: center">
<img src="images/lec14/43.png" width="80%/"/>
</div>
</details>
<p>虽然“发生概率相对较少”，但是不可串行性的情况仍有发生的概率。对于许多应用而言，快照隔离导致的非串行化执行的影响并不十分严重。事实上，快照隔离允许长时间运行的读事务不阻塞更新操作的优势，对众多此类应用来说足以抵消偶尔出现的这类小问题。</p>
<p>但在其他场景下（比如金融领域<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>，不可串行性可能是不可接受的。不过我们有以下解决方案：</p>
<ul>
<li>如果数据库系统支持，那么可以使用一种称为<strong>可串行化快照隔离</strong><span>(serializable snapshot isolation, SSI)<span class="heti-spacing"> </span></span>的改进版本。该技术在原有快照隔离基础上进行了扩展，从而确保可串行性。<ul>
<li>该机制背后的直观原理如下：假设我们追踪事务间的所有冲突（即写<span class="heti-skip"><span class="heti-spacing"> </span>-<span class="heti-spacing"> </span></span>写、读<span class="heti-skip"><span class="heti-spacing"> </span>-<span class="heti-spacing"> </span></span>写和写<span class="heti-skip"><span class="heti-spacing"> </span>-<span class="heti-spacing"> </span></span>读冲突<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>。当事务<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_1\)</span><span class="heti-spacing"> </span></span>和<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_2\)</span><span class="heti-spacing"> </span></span>对同一元组存在操作冲突，且<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_1\)</span><span class="heti-spacing"> </span></span>的操作先于<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_2\)</span><span class="heti-spacing"> </span></span>时，我们可以构建一个从<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_1\)</span><span class="heti-spacing"> </span></span>指向<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_2\)</span><span class="heti-spacing"> </span></span>的有向边构成的事务优先图。确保可串行性的一种方法是检测事务优先图中的环路，若发现环路则回滚相应事务。</li>
<li>快照隔离导致可串行性丧失的关键原因在于：它未能追踪读写冲突——即当事务<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_1\)</span><span class="heti-spacing"> </span></span>写入某对象的一个版本后，事务<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_2\)</span><span class="heti-spacing"> </span></span>随后读取了该对象的更早版本。这种冲突可通过从<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_2\)</span><span class="heti-spacing"> </span></span>指向<span class="heti-skip"><span class="heti-spacing"> </span><span class="arithmatex">\(T_1\)</span><span class="heti-spacing"> </span></span>的读写冲突边来表示。</li>
<li>研究表明，在所有快照隔离允许非可串行化调度的情况下，必然存在一个事务同时具备传入读写冲突边和传出读写冲突边（冲突图中其他所有环状情况均已被快照隔离规则捕获<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>。因此，可串行化快照隔离的实现会追踪并发事务间所有<strong>读写冲突</strong>，以检测是否存在同时拥有传入与传出读写冲突边的事务。一旦发现这种情况，系统将回滚涉及该读写冲突的其中一个事务。尽管这种检查可能导致部分不必要的回滚操作，但其开销远低于追踪全部冲突并检测环路的方案。</li>
</ul>
</li>
<li>部分系统允许不同事务运行在不同隔离级别下，这一特性可用于规避前文所述的可串行性问题。</li>
<li>
<p>某些支持快照隔离的系统为<span class="heti-skip"><span class="heti-spacing"> </span>SQL<span class="heti-spacing"> </span></span>程序员提供了一种通过<span class="heti-skip"><span class="heti-spacing"> </span>SQL<span class="heti-spacing"> </span></span>中的 <code>FOR UPDATE</code> 子句创建人为冲突的方法，以保证可串行性。</p>
<details class="example" open="open">
<summary>例子</summary>
<div class="language-sql highlight"><pre><span></span><code><span id="__span-0-1"><a href="#__codelineno-0-1" id="__codelineno-0-1" name="__codelineno-0-1"></a><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span>
</span><span id="__span-0-2"><a href="#__codelineno-0-2" id="__codelineno-0-2" name="__codelineno-0-2"></a><span class="k">FROM</span><span class="w"> </span><span class="n">instructor</span>
</span><span id="__span-0-3"><a href="#__codelineno-0-3" id="__codelineno-0-3" name="__codelineno-0-3"></a><span class="k">WHERE</span><span class="w"> </span><span class="n">ID</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">22222</span>
</span><span id="__span-0-4"><a href="#__codelineno-0-4" id="__codelineno-0-4" name="__codelineno-0-4"></a><span class="k">FOR</span><span class="w"> </span><span class="k">UPDATE</span>
</span></code></pre></div>
</details>
<ul>
<li>添加 <code>FOR UPDATE</code> 子句会使系统在并发控制时，将读取的数据视为已被更新。</li>
</ul>
</li>
</ul>
<h2 id="weak-levels-of-consistency-in-practice">Weak Levels of Consistency in Practice<a class="headerlink" href="#weak-levels-of-consistency-in-practice" title="Permanent link">⚓︎</a></h2>
<p>在上一章，我们讨论过<span class="heti-skip"><span class="heti-spacing"> </span>SQL<span class="heti-spacing"> </span></span>标准制定的<a href="13.html#transcation-isolation-levels">隔离等级</a>，包括可串行、可重复读取、读取提交和读取未提交。本节将先简要概述一些比可串行化的一致性级别更弱的相关术语，并将其与<span class="heti-skip"><span class="heti-spacing"> </span>SQL<span class="heti-spacing"> </span></span>标准级别相联系；之后探讨涉及用户交互事务的并发控制问题。</p>
<h3 id="degree-two-consistency">Degree-Two Consistency<a class="headerlink" href="#degree-two-consistency" title="Permanent link">⚓︎</a></h3>
<p><strong>两级一致性</strong><span>(degree-two consitency)<span class="heti-spacing"> </span></span>目的是避免级联中止，而不必确保可串行性。二级一致性的锁协议采用与两阶段锁定协议相同的两种锁模式：共享（S）和独占（X<heti-adjacent class="heti-adjacent-half">）</heti-adjacent>。事务在访问数据项时必须持有适当的锁定模式，但不需要分为两个阶段。</p>
<p>与两阶段锁的情况不同，共享锁可以在任何时候释放和获取；但独占锁在事务提交或中止之前不能被释放。该协议不保证可串行性。实际上，一个事务对同一个数据项进行两次读取，但可能会得到不同的结果。</p>
<p>读取操作不可重复，但由于独占锁会一直保持到事务提交，任何事务都无法读取未提交的值。因此，二级一致性是<strong>读取提交</strong>隔离级别的一种特定实现。</p>
<p>值得注意的是，在二级一致性下，扫描索引的事务可能会看到记录的两个版本，甚至可能两个版本都看不到。</p>
<h3 id="cursor-stability">Cursor Stability<a class="headerlink" href="#cursor-stability" title="Permanent link">⚓︎</a></h3>
<p><strong>游标稳定性</strong><span>(cursor stability)<span class="heti-spacing"> </span></span>是一种二级一致性形式，专门为通过游标遍历关系元组的程序设计。它不会锁定整个关系，而是确保：</p>
<ul>
<li>在迭代中正在被处理的元组以共享模式被加锁；一旦处理好该元组，这个锁就会被释放</li>
<li>任何可修改的元组以独占模式被锁住，直到事务被提交</li>
</ul>
<p>这些规则确保了二级一致性得以实现，但并未采用两阶段方式进行锁定，因此无法保证可串行性。在实际应用中，游标稳定性经常用于被频繁访问的关系上，以此作为提升并发性和系统性能的手段。使用游标稳定性的应用程序必须通过编码方式确保数据库的一致性，即便存在不可串行性调度的可能性。因此，游标稳定性的应用仅限于具有简单一致性约束的特殊场景中。</p>
<p>在数据库支持的情况下，快照隔离是比二级一致性和游标稳定性更优的选择，因为它能提供相当甚至更高的并发度，同时降低非可串行化执行的风险。</p>
<h3 id="concurrency-control-across-user-interactions">Concurrency Control Across User Interactions<a class="headerlink" href="#concurrency-control-across-user-interactions" title="Permanent link">⚓︎</a></h3>
<p>对于有用户交互的事务，无论是两阶段锁、时间戳协议或验证，还是快照隔离，它们都无法给出完美的解决方案。相比这些方法而言，一种更好的并发控制方案是将涉及用户交互的事务拆分为两个或多个事务，确保没有事务跨越用户交互环节。该方案还利用了存储在元组中的版本号，以避免更新丢失。每个关系的模式通过增加一个额外的 <strong>version_number</strong> 属性（初始值为<span><span class="heti-spacing"> </span>0</span>）进行修改。当事务首次读取其打算更新的元组时，会记录该元组的版本号。</p>
<ul>
<li>读取操作作为数据库上的独立事务执行，因此获取的任何锁都会立即释放</li>
<li>
<p>更新操作先在本地完成，并在提交处理阶段将更改复制到数据库中，这一过程遵循以下按原子性执行的步骤：</p>
<ul>
<li>
<p>对于每个被更新的元组，事务检查当前版本号是否和元组第一次被事务读取时的版本号相同</p>
<ul>
<li>如果匹配上的话，那么就在数据库上更新该元组，并且版本号递增<span><span class="heti-spacing"> </span>1</span></li>
<li>如果没有匹配上，则中止该事务，并回滚其执行的所有更新</li>
</ul>
</li>
<li>
<p>如果所有被更新的元组都通过了版本号检查，那么提交该事务。值得注意的是，使用<strong>时间戳</strong>替代版本号完全不会对该方案造成任何影响。</p>
</li>
</ul>
</li>
</ul>
<p>上述方案和快照隔离十分相似：版本号检查实现了快照隔离中采用的<strong>先提交者胜</strong>的规则，该方案也适用于事务活跃时间很长的情况。但与快照隔离不同的是，事务执行的读取操作可能不对应数据库的某个快照；且不同于基于验证的协议，该事务执行的读取操作不会经过验证。</p>
<p>我们将上述方案称为<strong>无读验证的乐观并发控制</strong>(optimistic concurrency control without read validation)。它提供了一种较弱的可串行化保证，也就是说无法确保真正的可串行性。该方案的一个变体是：在提交时，除了验证写操作外，还可以通过版本号对读取操作进行校验，以确保事务读取的元组在初始读取后未被更新；此方案等效于我们先前讨论过的那个<a href="#validation-based-protocols">乐观并发控制机制</a>。</p>
<p>该方案已被广泛用于处理涉及用户交互的事务。其一大亮点是易于实现：作为提交处理环节的验证与更新步骤将以单一数据库事务的形式执行，借助数据库自身的并发控制机制确保提交处理的原子性。</p></div>
<aside class="md-source-file">
<span class="md-source-file__fact">
<span class="md-icon" title="最后更新">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M21 13.1c-.1 0-.3.1-.4.2l-1 1 2.1 2.1 1-1c.2-.2.2-.6 0-.8l-1.3-1.3c-.1-.1-.2-.2-.4-.2m-1.9 1.8-6.1 6V23h2.1l6.1-6.1zM12.5 7v5.2l4 2.4-1 1L11 13V7zM11 21.9c-5.1-.5-9-4.8-9-9.9C2 6.5 6.5 2 12 2c5.3 0 9.6 4.1 10 9.3-.3-.1-.6-.2-1-.2s-.7.1-1 .2C19.6 7.2 16.2 4 12 4c-4.4 0-8 3.6-8 8 0 4.1 3.1 7.5 7.1 7.9l-.1.2z"></path></svg>
</span>
<span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-datetime" title="2025年6月22日 19:26:01">2025年6月22日 19:26:01</span>
</span>
<span class="md-source-file__fact">
<span class="md-icon" title="创建日期">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M14.47 15.08 11 13V7h1.5v5.25l3.08 1.83c-.41.28-.79.62-1.11 1m-1.39 4.84c-.36.05-.71.08-1.08.08-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8c0 .37-.03.72-.08 1.08.69.1 1.33.32 1.92.64.1-.56.16-1.13.16-1.72 0-5.5-4.5-10-10-10S2 6.5 2 12s4.47 10 10 10c.59 0 1.16-.06 1.72-.16-.32-.59-.54-1.23-.64-1.92M18 15v3h-3v2h3v3h2v-3h3v-2h-3v-3z"></path></svg>
</span>
<span class="git-revision-date-localized-plugin git-revision-date-localized-plugin-datetime" title="2024年10月7日 21:20:16">2024年10月7日 21:20:16</span>
</span>
</aside>
<p style="font-size: 30px; font-weight: 600">评论区</p>
<div>
    如果大家有什么问题或想法，欢迎在下方留言~
  </div>
<!-- Insert generated snippet here -->
<script async="" crossorigin="anonymous" data-category="Announcements" data-category-id="DIC_kwDOMAb9Zs4CfmpP" data-emit-metadata="0" data-input-position="bottom" data-lang="zh-CN" data-mapping="pathname" data-reactions-enabled="1" data-repo="noughtq/notebook" data-repo-id="R_kgDOMAb9Zg" data-strict="0" data-theme="preferred_color_scheme" src="https://giscus.app/client.js">
</script>
<!-- Synchronize Giscus theme with palette -->
<script>
    var giscus = document.querySelector("script[src*=giscus]")

    // Set palette on initial load
    var palette = __md_get("__palette")
    if (palette && typeof palette.color === "object") {
      var theme = palette.color.scheme === "slate"
        ? "transparent_dark"
        : "light"

      // Instruct Giscus to set theme
      giscus.setAttribute("data-theme", theme) 
    }

    // Register event handlers after documented loaded
    document.addEventListener("DOMContentLoaded", function() {
      var ref = document.querySelector("[data-md-component=palette]")
      ref.addEventListener("change", function() {
        var palette = __md_get("__palette")
        if (palette && typeof palette.color === "object") {
          var theme = palette.color.scheme === "slate"
            ? "dark"
            : "light"

          // Instruct Giscus to change theme
          var frame = document.querySelector(".giscus-frame")
          frame.contentWindow.postMessage(
            { giscus: { setConfig: { theme } } },
            "https://giscus.app"
          )
        }
      })
    })
  </script>
<!-- 标题计数器 -->
<link href="/css/counter.css" rel="stylesheet"/>
<!-- 主页个性化 -->
</article>
</div>
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
</div>
<button class="md-top md-icon" data-md-component="top" hidden="" type="button">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8z"></path></svg>
  回到页面顶部
</button>
</main>
<footer class="md-footer">
<nav aria-label="页脚" class="md-footer__inner md-grid">
<a aria-label="上一页: Lec 13: Transactions" class="md-footer__link md-footer__link--prev" href="13.html">
<div class="md-footer__button md-icon">
<svg viewbox="0 0 320 512" xmlns="http://www.w3.org/2000/svg"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256l137.3-137.4c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"></path></svg>
</div>
<div class="md-footer__title">
<span class="md-footer__direction">
                上一页
              </span>
<div class="md-ellipsis">
                Lec 13: Transactions
              </div>
</div>
</a>
<a aria-label="下一页: Lec 15: Recovery System" class="md-footer__link md-footer__link--next" href="15.html">
<div class="md-footer__title">
<span class="md-footer__direction">
                下一页
              </span>
<div class="md-ellipsis">
                Lec 15: Recovery System
              </div>
</div>
<div class="md-footer__button md-icon">
<svg viewbox="0 0 320 512" xmlns="http://www.w3.org/2000/svg"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"></path></svg>
</div>
</a>
</nav>
<div class="md-footer-meta md-typeset">
<div class="md-footer-meta__inner md-grid">
<div class="md-copyright" style="margin-left: 33.5%">
<div class="md-copyright__highlight" style="text-align: center">
        Copyright © 2024-2025 <a href="https://github.com/NoughtQ">NoughtQ</a>
</div>
    
    
      Powered by
      <a href="https://www.mkdocs.org/" rel="noopener" target="_blank">
        MkDocs
      </a>
      with theme
      <a href="https://squidfunk.github.io/mkdocs-material/" rel="noopener" target="_blank">
        Material
      </a>
      modified by
      <a href="https://github.com/NoughtQ" rel="noopener" target="_blank">
        NoughtQ
      </a>
<!-- <br> -->
<div style="text-align: center;">
<a href="https://icp.gov.moe/?keyword=20252357" target="_blank">萌ICP备20252357号</a>
</div>
</div>
<div class="md-social">
<a class="md-social__link" href="https://github.com/noughtq" rel="noopener" target="_blank" title="github.com">
<svg viewbox="0 0 496 512" xmlns="http://www.w3.org/2000/svg"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6m-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3m44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9M244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8M97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1m-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7m32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1m-11.4-14.7c-1.6 1-1.6 3.6 0 5.9s4.3 3.3 5.6 2.3c1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2"></path></svg>
</a>
<a class="md-social__link" href="https://blog.noughtq.top" rel="noopener" target="_blank" title="blog.noughtq.top">
<svg viewbox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><!--! Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M192 32c0 17.7 14.3 32 32 32 123.7 0 224 100.3 224 224 0 17.7 14.3 32 32 32s32-14.3 32-32C512 128.9 383.1 0 224 0c-17.7 0-32 14.3-32 32m0 96c0 17.7 14.3 32 32 32 70.7 0 128 57.3 128 128 0 17.7 14.3 32 32 32s32-14.3 32-32c0-106-86-192-192-192-17.7 0-32 14.3-32 32m-96 16c0-26.5-21.5-48-48-48S0 117.5 0 144v224c0 79.5 64.5 144 144 144s144-64.5 144-144-64.5-144-144-144h-16v96h16c26.5 0 48 21.5 48 48s-21.5 48-48 48-48-21.5-48-48z"></path></svg>
</a>
<a class="md-social__link" href="mailto:noughtq666@gmail.com" rel="noopener" target="_blank" title="">
<svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="m20 8-8 5-8-5V6l8 5 8-5m0-2H4c-1.11 0-2 .89-2 2v12a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2"></path></svg>
</a>
</div>
</div>
</div>
</footer>
</div>
<div class="md-dialog" data-md-component="dialog">
<div class="md-dialog__inner md-typeset"></div>
</div>
<script id="__config" type="application/json">{"base": "../..", "features": ["content.action.edit", "content.action.view", "content.code.copy", "content.code.annotate", "content.footnote.tooltips", "navigation.tabs", "navigation.top", "navigation.footer", "navigation.indexes", "navigation.tracking", "navigation.prune", "search.share"], "search": "../../assets/javascripts/workers/search.d50fe291.min.js", "tags": null, "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}, "version": null}</script>
<script src="../../assets/javascripts/bundle.13a4f30d.min.js"></script>
<script src="../../js/anchor.js"></script>
<script src="../../js/katex.js"></script>
<script src="../../js/toc.js"></script>
<script src="../../js/typed.js"></script>
<script src="../../js/custom.js"></script>
<script src="https://unpkg.com/katex@0/dist/katex.min.js"></script>
<script src="https://unpkg.com/katex@0/dist/contrib/auto-render.min.js"></script>
</body>
</html>